/**
 * @file spi_slave.c
 * @date 2015-12-17
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * SPI_SLAVE v4.0.8 - Configures a USIC channel to implement SPI slave functionality.
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-08-06:
 *     - Initial version for DAVEv4
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "spi_slave.h"
#include "string.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
/*
 * Represents the bit mask of port pin alternate function
 */
#define SPI_SLAVE_PORT_ALTERNATE_FN_MSK (0x0fUL << PORT0_IOCR0_PC0_Pos)
/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
#ifdef SPI_SLAVE_TX_INTERRUPT_USED
/*Function used for handling transmit interrupt.*/
void SPI_SLAVE_lTransmitHandler(const SPI_SLAVE_t * const handle);
#endif
#ifdef SPI_SLAVE_RX_INTERRUPT_USED
/*Function used for handling data reception interrupts.*/
void SPI_SLAVE_lReceiveHandler(const SPI_SLAVE_t * const handle);
/*Function used for reconfiguring rx FIFO while receiving data.*/
static void SPI_SLAVE_lReconfigureRxFIFO(const SPI_SLAVE_t * const handle, uint32_t count);
#endif
#ifdef SPI_SLAVE_TX_DIRECT_USED
/*Function for transmitting data using polling.*/
static SPI_SLAVE_STATUS_t SPI_SLAVE_lTransmitPolling (const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count);
#endif
#ifdef SPI_SLAVE_RX_DIRECT_USED
/*Function for receiving data using polling.*/
static SPI_SLAVE_STATUS_t SPI_SLAVE_lReceivePolling (const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count);
#endif
#ifdef SPI_SLAVE_RX_DIRECT_USED
static void SPI_SLAVE_lTransferPolling(const SPI_SLAVE_t *const handle,
                                        uint8_t* tx_dataptr,
                                        uint8_t* rx_dataptr,
                                        uint32_t count);
#endif
#ifdef SPI_SLAVE_PROTOCOL_EVENT_USED
/*Function used for handling protocol related interrupt.*/
void SPI_SLAVE_lProtocolHandler(const SPI_SLAVE_t * const handle);
#endif
static SPI_SLAVE_STATUS_t SPI_SLAVE_lValidateModeChange(const SPI_SLAVE_t * const handle, XMC_SPI_CH_MODE_t mode);



/**********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/

/*
 * @brief API to retrieve the version of the SPI_SLAVE APP.
 *
 * @return DAVE_APP_VERSION_t Structure containing major version, minor version
 *         and patch version.
 */
DAVE_APP_VERSION_t SPI_SLAVE_GetAppVersion()
{
  DAVE_APP_VERSION_t version;

  version.major = SPI_SLAVE_MAJOR_VERSION;
  version.minor = SPI_SLAVE_MINOR_VERSION;
  version.patch = SPI_SLAVE_PATCH_VERSION;

  return version;
}

/*
 * @brief Function to initialize the USIC Channel with GUI configured values.
 *
 * @param[in]  handle SPI_SLAVE APP handle pointer of type SPI_SLAVE_t*
 *
 * @return  SPI_SLAVE_STATUS_t
 *          SPI_SLAVE_SUCCESS: for successful SPI_SLAVE initialization.<BR>
 *          SPI_SLAVE_STATUS_FAILURE  : If SPI_SLAVE initialization fails.<BR>
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_Init(const SPI_SLAVE_t *const handle)
{
  SPI_SLAVE_STATUS_t status = SPI_SLAVE_STATUS_SUCCESS;
  XMC_ASSERT("SPI_SLAVE_Init : SPI_SLAVE APP handle invalid", (((handle != NULL)&&
      (handle->config != NULL)) &&((handle->config->fptr_spi_slave_config != NULL)&&
      (handle->runtime != NULL))))
  /*Initialize the multiplexers required for SPI_SLAVE configuration*/
  status = handle->config->fptr_spi_slave_config();

  return status;
}

/*
 * @brief Common function to transmit data.
 *
 * @param[in]  handle SPI_SLAVE APP handle pointer of type SPI_SLAVE_t*
 * @param[in]  data_ptr Pointer to data of type uint8_t
 * @param[in]  count Number of uint8_t type bytes to be transmitted
 *
 * @return  SPI_SLAVE_STATUS_t
 *          SPI_SLAVE_SUCCESS: If the data is put to transmit.<BR>
 *          SPI_SLAVE_STATUS_BUSY  : If the channel is busy.<BR>
 *          SPI_SLAVE_STATUS_BUFFER_INVALID: Either if buffer is NULL or count is 0.<BR>
 *          SPI_SLAVE_STATUS_MODE_MISMATCH: If the configured mode is invalid.<BR>
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_Transmit(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count)
{
  SPI_SLAVE_STATUS_t ret_stat = SPI_SLAVE_STATUS_MODE_MISMATCH;

  switch(handle->config->transmit_mode)
  {
#ifdef SPI_SLAVE_TX_INTERRUPT_USED
  case SPI_SLAVE_TRANSFER_MODE_INTERRUPT:
    ret_stat = SPI_SLAVE_StartTransmitIRQ(handle, data_ptr, count);
    break;
#endif
#ifdef SPI_SLAVE_TX_DMA_USED
  case SPI_SLAVE_TRANSFER_MODE_DMA:
    ret_stat = SPI_SLAVE_StartTransmitDMA(handle, data_ptr, count);
    break;
#endif
#ifdef SPI_SLAVE_TX_DIRECT_USED
  case SPI_SLAVE_TRANSFER_MODE_DIRECT:
    ret_stat = SPI_SLAVE_STATUS_BUFFER_INVALID;
    if ((data_ptr != NULL) && (count > 0U))
    {
      ret_stat = SPI_SLAVE_STATUS_BUSY;
      if (handle->runtime->tx_busy == false)
      {
        ret_stat = SPI_SLAVE_lTransmitPolling(handle, data_ptr, count);
      }
    }
    break;
#endif
  default:
    break;
  }
  return ret_stat;
}

/*
 * @brief Common function to receive data.
 *
 * @param[in]  handle SPI_SLAVE APP handle pointer of type SPI_SLAVE_t*
 * @param[in]  data_ptr Pointer to data of type uint8_t
 * @param[in]  count Number of uint8_t type bytes to be received
 *
 * @return  SPI_SLAVE_STATUS_t
 *          SPI_SLAVE_SUCCESS: If the data is put to transmit.<BR>
 *          SPI_SLAVE_STATUS_BUSY  : If the channel is busy.<BR>
 *          SPI_SLAVE_STATUS_BUFFER_INVALID: Either if buffer is NULL or count is 0.<BR>
 *          SPI_SLAVE_STATUS_MODE_MISMATCH: If the configured mode is invalid.<BR>
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_Receive(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count)
{
  SPI_SLAVE_STATUS_t ret_stat = SPI_SLAVE_STATUS_MODE_MISMATCH;

  switch(handle->config->receive_mode)
  {
#ifdef SPI_SLAVE_RX_INTERRUPT_USED
  case SPI_SLAVE_TRANSFER_MODE_INTERRUPT:
    ret_stat = SPI_SLAVE_StartReceiveIRQ(handle, data_ptr, count);
    break;
#endif
#ifdef SPI_SLAVE_RX_DMA_USED
  case SPI_SLAVE_TRANSFER_MODE_DMA:
    ret_stat = SPI_SLAVE_StartReceiveDMA(handle, data_ptr, count);
    break;
#endif
#ifdef SPI_SLAVE_RX_DIRECT_USED
  case SPI_SLAVE_TRANSFER_MODE_DIRECT:
    ret_stat = SPI_SLAVE_STATUS_BUFFER_INVALID;
    if ((data_ptr != NULL) && (count > 0U))
    {
      ret_stat = SPI_SLAVE_STATUS_BUSY;
      if (handle->runtime->rx_busy == false)
      {
        ret_stat = SPI_SLAVE_lReceivePolling(handle, data_ptr, count);
      }
    }
    break;
#endif
  default:
    break;
  }
  return ret_stat;
}

#if (defined SPI_SLAVE_TX_INTERRUPT_USED || defined SPI_SLAVE_TX_DMA_USED)
/*
 * @brief Common function to abort ongoing transmission.
 *
 * @param[in]  handle SPI_SLAVE APP handle pointer of type SPI_SLAVE_t*
 *
 * @return  SPI_SLAVE_STATUS_t
 *          SPI_SLAVE_SUCCESS: If the transmission is aborted.<BR>
 *          SPI_SLAVE_STATUS_FAILURE: If the channel is not transmitting.<BR>
 *          SPI_SLAVE_STATUS_MODE_MISMATCH: If the configured mode is Direct.<BR>
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_AbortTransmit(const SPI_SLAVE_t *const handle)
{
  SPI_SLAVE_STATUS_t ret_stat = SPI_SLAVE_STATUS_SUCCESS;
#ifdef SPI_SLAVE_TX_DMA_USED
  const SPI_SLAVE_DMA_CONFIG_t * ptr_dma_config = handle->config->transmit_dma_config;
  XMC_DMA_t * ptr_gpdma = handle->config->global_dma->dma;
#endif

  XMC_ASSERT("SPI_SLAVE_AbortTransmit: SPI_SLAVE APP handle invalid", ((handle != NULL)&&
            (handle->runtime != NULL)))

  /*Reset the user buffer pointer to null*/
  handle->runtime->tx_busy = false;
  handle->runtime->tx_data = NULL;

  switch(handle->config->transmit_mode)
  {
#ifdef SPI_SLAVE_TX_INTERRUPT_USED
  case SPI_SLAVE_TRANSFER_MODE_INTERRUPT:
    /*Disable the transmit interrupts*/
    if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      /*Disable the transmit FIFO event*/
      XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
      XMC_USIC_CH_TXFIFO_Flush(handle->channel);
    }
    else
    {
      /*Disable the standard transmit event*/
      XMC_SPI_CH_DisableEvent(handle->channel, (uint32_t)XMC_SPI_CH_EVENT_TRANSMIT_BUFFER);
    }
    /*Invalidate TBUF*/
    XMC_USIC_CH_SetTransmitBufferStatus(handle->channel, XMC_USIC_CH_TBUF_STATUS_SET_IDLE);
    break;
#endif
#ifdef SPI_SLAVE_TX_DMA_USED
  case SPI_SLAVE_TRANSFER_MODE_DMA:
    /*Disable the standard transmit event*/
    if (XMC_DMA_CH_IsEnabled(ptr_gpdma, ptr_dma_config->dma_channel))
    {
      XMC_DMA_CH_Disable(ptr_gpdma, ptr_dma_config->dma_channel);
      while(XMC_DMA_CH_IsEnabled(ptr_gpdma, ptr_dma_config->dma_channel)==true)
      {
      }
      XMC_SPI_CH_DisableEvent(handle->channel, (uint32_t)XMC_SPI_CH_EVENT_RECEIVE_START);
    }
    /*Invalidate TBUF*/
    XMC_USIC_CH_SetTransmitBufferStatus(handle->channel, XMC_USIC_CH_TBUF_STATUS_SET_IDLE);
    break;
#endif
  default:
    ret_stat = SPI_SLAVE_STATUS_MODE_MISMATCH;
    break;
  }
  return ret_stat;
}
#endif

#if (defined SPI_SLAVE_RX_INTERRUPT_USED || defined SPI_SLAVE_RX_DMA_USED)
/*
 * @brief Common function to abort ongoing reception.
 *
 * @param[in]  handle SPI_SLAVE APP handle pointer of type SPI_SLAVE_t*
 *
 * @return  SPI_SLAVE_STATUS_t
 *          SPI_SLAVE_SUCCESS: If the reception is aborted.<BR>
 *          SPI_SLAVE_STATUS_FAILURE  : If the channel is not busy.<BR>
 *          SPI_SLAVE_STATUS_MODE_MISMATCH: If the configured mode is Direct.<BR>
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_AbortReceive(const SPI_SLAVE_t *const handle)
{
  SPI_SLAVE_STATUS_t ret_stat = SPI_SLAVE_STATUS_SUCCESS;
#ifdef SPI_SLAVE_RX_DMA_USED
  const SPI_SLAVE_DMA_CONFIG_t * ptr_dma_config = handle->config->receive_dma_config;
  XMC_DMA_t * ptr_gpdma = handle->config->global_dma->dma;
#endif
  XMC_ASSERT("SPI_SLAVE_AbortReceive: SPI_SLAVE APP handle invalid", ((handle != NULL)&&
            (handle->runtime != NULL)))

  /*Reset the user buffer pointer to null*/
  handle->runtime->rx_busy = false;
  handle->runtime->rx_data = NULL;
  switch(handle->config->receive_mode)
  {
#ifdef SPI_SLAVE_RX_INTERRUPT_USED
  case SPI_SLAVE_TRANSFER_MODE_INTERRUPT:
    /*Disable the receive interrupts*/
    if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
            ((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
            (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
    }
    else
    {
      XMC_SPI_CH_DisableEvent(handle->channel,
            ((uint32_t)XMC_SPI_CH_EVENT_STANDARD_RECEIVE |
            (uint32_t)XMC_SPI_CH_EVENT_ALTERNATIVE_RECEIVE));
    }
    break;
#endif
#ifdef SPI_SLAVE_RX_DMA_USED
  case SPI_SLAVE_TRANSFER_MODE_DMA:
    /*Disable the receive interrupts*/
    if (XMC_DMA_CH_IsEnabled(ptr_gpdma, ptr_dma_config->dma_channel))
    {
      XMC_DMA_CH_Disable(ptr_gpdma, ptr_dma_config->dma_channel);
      while(XMC_DMA_CH_IsEnabled(ptr_gpdma, ptr_dma_config->dma_channel)==true)
      {
      }
      XMC_SPI_CH_DisableEvent(handle->channel,
            ((uint32_t)XMC_SPI_CH_EVENT_STANDARD_RECEIVE |
            (uint32_t)XMC_SPI_CH_EVENT_ALTERNATIVE_RECEIVE));
    }
    break;
#endif
  default:
    ret_stat = SPI_SLAVE_STATUS_MODE_MISMATCH;
    break;
  }
  return ret_stat;
}
#endif

SPI_SLAVE_STATUS_t SPI_SLAVE_SetMode(const SPI_SLAVE_t * const handle, XMC_SPI_CH_MODE_t mode)
{
  SPI_SLAVE_STATUS_t status = SPI_SLAVE_STATUS_SUCCESS;
  const SPI_SLAVE_PIN_CONFIG_t * ptr_miso_config = handle->config->mosi1_pin_config;
  const SPI_SLAVE_PIN_CONFIG_t * ptr_mosi_config = handle->config->mosi0_pin_config;

  if(mode != handle->runtime->spi_current_mode)
  {
    status = SPI_SLAVE_STATUS_BUSY;
    if((!handle->runtime->tx_busy) && (!handle->runtime->rx_busy))
    {
      status = SPI_SLAVE_lValidateModeChange(handle, mode);
      if(status == SPI_SLAVE_STATUS_SUCCESS)
      {
        switch(mode)
        {
        case XMC_SPI_CH_MODE_STANDARD:
          XMC_GPIO_SetMode(ptr_mosi_config->port, ptr_mosi_config->pin, XMC_GPIO_MODE_INPUT_TRISTATE);
          XMC_GPIO_SetHardwareControl(ptr_mosi_config->port, ptr_mosi_config->pin, XMC_GPIO_HWCTRL_DISABLED);
          XMC_SPI_CH_SetInputSource(handle->channel, XMC_SPI_CH_INPUT_DIN0, (uint8_t)handle->config->dx0_source);
          XMC_GPIO_Init(ptr_miso_config->port, ptr_miso_config->pin, ptr_miso_config->config);
          break;
        case XMC_SPI_CH_MODE_STANDARD_HALFDUPLEX:
          XMC_GPIO_Init(ptr_mosi_config->port, ptr_mosi_config->pin, ptr_mosi_config->config);
          XMC_SPI_CH_SetInputSource(handle->channel, XMC_SPI_CH_INPUT_DIN0, (uint8_t)handle->config->dx0_source);
          XMC_GPIO_SetHardwareControl(ptr_mosi_config->port, ptr_mosi_config->pin, XMC_GPIO_HWCTRL_DISABLED);
          break;
        case XMC_SPI_CH_MODE_DUAL:
        case XMC_SPI_CH_MODE_QUAD:
          XMC_GPIO_SetHardwareControl(ptr_mosi_config->port, ptr_mosi_config->pin, ptr_mosi_config->hw_control);
          XMC_GPIO_SetHardwareControl(ptr_miso_config->port, ptr_miso_config->pin, ptr_miso_config->hw_control);
          break;
        default:
          break;
        }
        handle->runtime->spi_current_mode = mode;
      }
    }
  }
  return status;
}

/*Function to check if the request for mode change is valid*/
static SPI_SLAVE_STATUS_t SPI_SLAVE_lValidateModeChange(const SPI_SLAVE_t * const handle, XMC_SPI_CH_MODE_t mode)
{
  SPI_SLAVE_STATUS_t status = SPI_SLAVE_STATUS_SUCCESS;
  /*Mode cannot change from standard full duplex to half duplex or vice versa
   * Mode cannot change from Dual to quad mode*/
  if(((handle->config->spi_configured_mode == XMC_SPI_CH_MODE_STANDARD) ||
      (handle->config->spi_configured_mode == XMC_SPI_CH_MODE_STANDARD_HALFDUPLEX)) ||
      (handle->config->spi_configured_mode < mode))
  {
    status = SPI_SLAVE_STATUS_FAILURE;
  }
  else
  {
    if(mode == XMC_SPI_CH_MODE_STANDARD)
    {
      /*Configure DX0 multiplexer needed in full duplex mode for reception*/
      if((handle->config->dx0_source == SPI_SLAVE_INPUT_INVALID) ||
          (((uint32_t)handle->config->mosi1_pin_config->config->mode & SPI_SLAVE_PORT_ALTERNATE_FN_MSK) == 0U))
      {
        status = SPI_SLAVE_STATUS_FAILURE;
      }
    }
    else if(mode == XMC_SPI_CH_MODE_STANDARD_HALFDUPLEX)
    {
      /*Configure DX0 multiplexer needed in half duplex mode for reception*/
      if((handle->config->dx0_source == SPI_SLAVE_INPUT_INVALID) ||
          (((uint32_t)handle->config->mosi0_pin_config->config->mode & (uint32_t)SPI_SLAVE_PORT_ALTERNATE_FN_MSK) == 0U))
      {
        status = SPI_SLAVE_STATUS_FAILURE;
      }
    }
    else
    {
    }
  }
  return status;
}

#ifdef SPI_SLAVE_TX_INTERRUPT_USED
/*
 * @brief Registers a request for transmitting data over SPI_SLAVE channel.
 *
 * @param[in]  SPI_SLAVE_t*  SPI_SLAVE APP handle pointer of type SPI_SLAVE_t
 * @param[in]  uint8_t* Pointer to data
 * @param[in]  uint32_t Total no of words to be transmitted.
 *
 * @return  SPI_SLAVE_STATUS_t SPI_SLAVE_STATUS_SUCCESS if the request is accepted.
 *                        SPI_SLAVE_STATUS_BUSY if a transmission is in progress.
 * Details of function:
 * The data transmission is accomplished using transmit interrupt. User can configure
 * a callback function in the APP UI. When the data is fully transmitted, the callback
 * function will be executed. If transmit FIFO is enabled, the trigger limit is set to 0.
 * So the transmit interrupt will be generated when all the data in FIFO is moved from FIFO.
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_StartTransmitIRQ(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count)
{
  SPI_SLAVE_STATUS_t ret_stat = SPI_SLAVE_STATUS_MODE_MISMATCH;
  SPI_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;

  XMC_ASSERT("SPI_SLAVE_StartTransmitIRQ: SPI_SLAVE APP handle invalid", ((handle != NULL)&&
            (ptr_runtime != NULL)))

  if (handle->config->transmit_mode == SPI_SLAVE_TRANSFER_MODE_INTERRUPT)
  {
    ret_stat = SPI_SLAVE_STATUS_BUSY;
    if (ptr_runtime->tx_busy == false)
    {
      /*If there is no transmission in progress*/
      if ((data_ptr != NULL) && (count > 0U))
      {
        /*Obtain the address of data, size of data*/
        ptr_runtime->tx_data = data_ptr;
        ptr_runtime->tx_data_count = count;
        /*Initialize to first index and set the busy flag*/
        ptr_runtime->tx_data_index = 0U;
        ptr_runtime->tx_busy = true;

        /*Enable the transmit buffer event*/
        if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
        {
          /*Clear the transmit FIFO*/
          XMC_USIC_CH_TXFIFO_Flush(handle->channel);
          /*Enable transmit buffer interrupt*/
          XMC_USIC_CH_TXFIFO_EnableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
        }
        else
        {
          XMC_SPI_CH_EnableEvent(handle->channel, (uint32_t)XMC_SPI_CH_EVENT_TRANSMIT_BUFFER);
        }
        /*Invalidate TBUF*/
        XMC_USIC_CH_SetTransmitBufferStatus(handle->channel, XMC_USIC_CH_TBUF_STATUS_SET_IDLE);
        ret_stat = SPI_SLAVE_STATUS_SUCCESS;
        /*Trigger the transmit buffer interrupt*/
        XMC_USIC_CH_TriggerServiceRequest(handle->channel, (uint32_t)handle->config->tx_sr);
      }
      else
      {
        ret_stat = SPI_SLAVE_STATUS_BUFFER_INVALID;
      }
    }
  }
  return ret_stat;
}

/*
 * Transmit interrupt handler for the APP.
 * This is a common interrupt handling function called for different instances of the APP.
 *
 *  * param[in]  handle SPI_SLAVE APP handle pointer of type SPI_SLAVE_t*
 *
 *  * return void
 */
void SPI_SLAVE_lTransmitHandler(const SPI_SLAVE_t * const handle)
{
  SPI_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  uint32_t bytes_per_word = (uint32_t)ptr_runtime->data_size;
  uint16_t data_value;

  if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
  {
    if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      /*When Transmit FIFO is enabled*/
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
      {
        if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
        {
          memcpy((void *)&data_value, (void *)&ptr_runtime->tx_data[ptr_runtime->tx_data_index * bytes_per_word],
                 bytes_per_word);
          /*Load the FIFO byte by byte till either FIFO is full or all data is loaded*/
          XMC_SPI_CH_Transmit(handle->channel,data_value, ptr_runtime->spi_current_mode);
          ptr_runtime->tx_data_index++;
        }
        else
        {
          break;
        }
      }
    }
    else
    {
      /*When Transmit FIFO is disabled*/
      memcpy((void *)&data_value, (void *)&ptr_runtime->tx_data[ptr_runtime->tx_data_index * bytes_per_word], bytes_per_word);
      XMC_SPI_CH_Transmit(handle->channel,data_value, ptr_runtime->spi_current_mode);
      ptr_runtime->tx_data_index++;
    }
  }
  else
  {
    if (XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel) == true)
    {
      if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
      {
        /*Disable the transmit FIFO event*/
        XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
      }
      else
      {
        /*Disable the standard transmit event*/
        XMC_SPI_CH_DisableEvent(handle->channel, (uint32_t)XMC_SPI_CH_EVENT_TRANSMIT_BUFFER);
      }

      /*Wait for the transmit buffer to be free to ensure that all data is transmitted*/
      while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
      {

      }
      /*All data is transmitted*/
      ptr_runtime->tx_busy = false;
      ptr_runtime->tx_data = NULL;

      if (handle->config->tx_cbhandler != NULL)
      {
        /*Execute the callback function provided in the SPI_SLAVE APP UI*/
        handle->config->tx_cbhandler();
      }
    }
  }
}
#endif

#ifdef SPI_SLAVE_RX_INTERRUPT_USED
/*
 * @brief Registers a request to receive data over SPI_SLAVE channel.
 *
 * @param[in]  SPI_SLAVE_t* SPI_SLAVE APP handle pointer of type SPI_SLAVE_t
 * @param[in]  uint8_t*  Pointer to data array
 * @param[in]  uint32_t  Total no of bytes to be read.
 *
 * @return  SPI_SLAVE_STATUS_t SPI_SLAVE_STATUS_SUCCESS if the request is accepted.
 *                        SPI_SLAVE_STATUS_BUSY if a reception is in progress.
 * Details of function:
 * This function registers the receive request by configuring the SPI_SLAVE
 * receive FIFO/Standard buffer (depending on the user configuration). The data
 * is received asynchronously. When the requested number of data bytes are received,
 * optionally, the user configured callback function will be executed. If a callback
 * function is not configured on the APP UI, the user has to poll for the status of
 * rx_busy variable of the APP handle structure.
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_StartReceiveIRQ(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count)
{
  SPI_SLAVE_STATUS_t ret_stat = SPI_SLAVE_STATUS_MODE_MISMATCH;
  SPI_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;

  XMC_ASSERT("SPI_SLAVE_StartReceiveIRQ: SPI_SLAVE APP handle invalid", ((handle != NULL)&&
            (ptr_runtime != NULL)))

  if (handle->config->receive_mode == SPI_SLAVE_TRANSFER_MODE_INTERRUPT)
  {
    ret_stat = SPI_SLAVE_STATUS_BUSY;
    if (ptr_runtime->rx_busy == false)
    {
      /*If no active reception in progress*/
      if ((data_ptr != NULL) && (count > 0U))
      {
        /*Obtain the address of data buffer and
         * number of data bytes to be received*/
        ptr_runtime->rx_data = data_ptr;
        ptr_runtime->rx_data_count = count;
        ptr_runtime->rx_busy = true;
        ptr_runtime->rx_data_index = 0U;

        /*Configure hardware port direction required for half duplex mode reception*/
        XMC_SPI_CH_Receive(handle->channel, handle->runtime->spi_current_mode);

        if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
        {
          /*Clear the receive FIFO, configure the trigger lime
           * and enable the receive events*/
          XMC_USIC_CH_RXFIFO_Flush(handle->channel);

          /*Configure the FIFO trigger limit based on the required data size*/
          SPI_SLAVE_lReconfigureRxFIFO(handle, count);

          XMC_USIC_CH_RXFIFO_EnableEvent(handle->channel,
            (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
            (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
        }
        else
        {
          XMC_USIC_CH_EnableEvent(handle->channel,
          (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE));
        }
        /*Flush RBUF- Repeat for RBUF0 and RBUF1*/
        (void)XMC_SPI_CH_GetReceivedData(handle->channel);
        (void)XMC_SPI_CH_GetReceivedData(handle->channel);
        ret_stat = SPI_SLAVE_STATUS_SUCCESS;
      }
      else
      {
        ret_stat = SPI_SLAVE_STATUS_BUFFER_INVALID;
      }
    }
  }
  return ret_stat;
}

/*
 * Receive interrupt handler for the APP.
 * This is a common interrupt handling function for different instances of the SPI_SLAVE APP.
 *
 * param[in]  handle SPI_SLAVE APP handle pointer of type SPI_SLAVE_t*
 *
 * return void
 */
void SPI_SLAVE_lReceiveHandler(const SPI_SLAVE_t * const handle)
{
  SPI_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  uint32_t bytes_per_word = (uint32_t)ptr_runtime->data_size;
  uint16_t data_value;

  if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    /*When Receive FIFO is enabled*/
    while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
    {
      if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
      {
        /*Read all the content of Receive FIFO */
        data_value = XMC_SPI_CH_GetReceivedData(handle->channel);
        memcpy((void *)&ptr_runtime->rx_data[ptr_runtime->rx_data_index * bytes_per_word], (void *)&data_value, bytes_per_word);
        ptr_runtime->rx_data_index++;
      }

      if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
      {
        /*Reception complete*/
        ptr_runtime->rx_busy = false;
        /*Disable both standard receive and alternative receive FIFO events*/
        XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
            (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
            (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
        if (handle->config->rx_cbhandler != NULL)
        {
          /*Execute the 'End of reception' callback function*/
          handle->config->rx_cbhandler();
        }
        break;
      }
    }
    /*Set the trigger limit if data still to be received*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
    {
      SPI_SLAVE_lReconfigureRxFIFO(handle,
          (uint32_t)(ptr_runtime->rx_data_count - ptr_runtime->rx_data_index));
    }
  }
  else
  {
    /*When RxFIFO is disabled*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
    {
      data_value = XMC_SPI_CH_GetReceivedData(handle->channel);
      memcpy((void *)&ptr_runtime->rx_data[ptr_runtime->rx_data_index * bytes_per_word], (void *)&data_value, bytes_per_word);
      ptr_runtime->rx_data_index++;
    }

    if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
    {
      /*Reception complete*/
      ptr_runtime->rx_busy = false;
      /*Disable both standard receive and alternative receive FIFO events*/
      XMC_SPI_CH_DisableEvent(handle->channel,
          (uint32_t)((uint32_t)XMC_SPI_CH_EVENT_ALTERNATIVE_RECEIVE | (uint32_t)XMC_SPI_CH_EVENT_STANDARD_RECEIVE));

      if (handle->config->rx_cbhandler != NULL)
      {
        /*Execute the 'End of reception' callback function*/
        handle->config->rx_cbhandler();
      }
    }
  }
}

/*
 * A local function to reconfigure Receive FIFO with the given size and trigger limit.
 * Size is needed because the FIFO should be disabled before changing the trigger limit by
 * clearing the FIFO size.
 *
 * param[in] SPI_SLAVE_t * pointer to the SPI_SLAVE APP handle
 * param[in] uint8_t  number of bytes to be received.
 *
 * return void.
 */
static void SPI_SLAVE_lReconfigureRxFIFO(const SPI_SLAVE_t * const handle, uint32_t count)
{
  uint32_t fifo_size;
  uint32_t ret_limit_val = 0U;

  /*Get FIFO size in bytes*/
  fifo_size = (uint32_t)(0x01UL << (uint8_t)(handle->config->rx_fifo_size));
  /*If data size is more than FIFO size, configure the limit to the FIFO size*/
  if (count < fifo_size)
  {
    ret_limit_val = (uint32_t)(count - 1U);
  }
  else
  {
    ret_limit_val = (uint32_t)(fifo_size - 1U);
  }
  /*Set the limit value*/
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel,
        handle->config->rx_fifo_size, ret_limit_val);
}
#endif
/*
 * Transmit and receive the data at the same time. This is supported for full duplex mode only.
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_Transfer(const SPI_SLAVE_t *const handle,
                                        uint8_t* tx_dataptr,
                                        uint8_t* rx_dataptr,
                                        uint32_t count)
{
  SPI_SLAVE_STATUS_t status = SPI_SLAVE_STATUS_MODE_MISMATCH;
  SPI_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;

  XMC_ASSERT("SPI_SLAVE_Transfer: SPI_SLAVE APP handle invalid", (((handle != NULL)&&
            (ptr_runtime != NULL))&&(handle->config != NULL)))


  if (XMC_SPI_CH_MODE_STANDARD == ptr_runtime->spi_current_mode)
  {
    /* Check whether SPI channel is free or not */
    if ((tx_dataptr != NULL) && (rx_dataptr != NULL) && (count > 0U))
    {
      status = SPI_SLAVE_STATUS_BUSY;
      /*Check data pointer is valid or not*/
      if ((false == ptr_runtime->rx_busy) && (false == ptr_runtime->tx_busy))
      {
        if(handle->config->receive_mode != SPI_SLAVE_TRANSFER_MODE_DIRECT)
        {
          (void)SPI_SLAVE_Receive(handle, rx_dataptr, count);
          /* Call the transmit, to receive the data synchronously */
          (void)SPI_SLAVE_Transmit(handle, tx_dataptr, count);
        }
#ifdef SPI_SLAVE_RX_DIRECT_USED
        else
        {
          SPI_SLAVE_lTransferPolling(handle, tx_dataptr, rx_dataptr, count);
        }
#endif
        status = SPI_SLAVE_STATUS_SUCCESS;
      }
    }
    else
    {
      status = SPI_SLAVE_STATUS_BUFFER_INVALID;
    }
  }

  return status;
}

#ifdef SPI_SLAVE_RX_DIRECT_USED
static void SPI_SLAVE_lTransferPolling(const SPI_SLAVE_t *const handle,
                                        uint8_t* tx_dataptr,
                                        uint8_t* rx_dataptr,
                                        uint32_t count)
{
  SPI_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  uint32_t data_indx, bytes_per_word, loc_count;
  uint16_t data_value;
  uint32_t rx_events = ((uint32_t)XMC_SPI_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION |
                        (uint32_t)XMC_SPI_CH_STATUS_FLAG_RECEIVE_INDICATION);

  XMC_ASSERT("SPI_SLAVE_Transfer: SPI_SLAVE APP handle invalid", (((handle != NULL)&&
            (ptr_runtime != NULL))&&(handle->config != NULL)))

  bytes_per_word = (uint32_t)ptr_runtime->data_size;
  loc_count = count << (bytes_per_word - 1U);
  ptr_runtime->tx_busy = true;
  ptr_runtime->rx_busy = true;
  /*Flush tx buffers*/
  if(handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    XMC_USIC_CH_TXFIFO_Flush(handle->channel);
  }

  if(handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    XMC_USIC_CH_RXFIFO_Flush(handle->channel);
  }
  else
  {
    XMC_SPI_CH_ClearStatusFlag(handle->channel, rx_events);
  }
  /*Flush RBUF- Repeat for RBUF0 and RBUF1*/
  (void)XMC_SPI_CH_GetReceivedData(handle->channel);
  (void)XMC_SPI_CH_GetReceivedData(handle->channel);

  XMC_USIC_CH_SetTransmitBufferStatus(handle->channel, XMC_USIC_CH_TBUF_STATUS_SET_IDLE);

  memcpy((void *)&data_value, (void *)&tx_dataptr[0U], bytes_per_word);
  XMC_SPI_CH_Transmit(handle->channel, data_value, ptr_runtime->spi_current_mode);
  data_indx = bytes_per_word;

  if(handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    /*Load TBUF or TxFIFO with data and wait for receive interrupt*/
    while(data_indx < loc_count)
    {
      memcpy((void *)&data_value, (void *)&tx_dataptr[data_indx], bytes_per_word);
      XMC_SPI_CH_Transmit(handle->channel, data_value, ptr_runtime->spi_current_mode);

      while(XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel))
      {
      }

      data_value = XMC_SPI_CH_GetReceivedData(handle->channel);

      memcpy((void *)&rx_dataptr[data_indx - bytes_per_word], (void *)&data_value, bytes_per_word);
      data_indx = data_indx + bytes_per_word;
    }
    while(XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel))
    {
    }
  }
  else
  {
    /*Load TBUF or TxFIFO with data and wait for receive interrupt*/
    while(data_indx < loc_count)
    {
      memcpy((void *)&data_value, (void *)&tx_dataptr[data_indx], bytes_per_word);
      XMC_SPI_CH_Transmit(handle->channel, data_value, ptr_runtime->spi_current_mode);

      while(!(XMC_SPI_CH_GetStatusFlag(handle->channel) & rx_events))
      {
      }
      XMC_SPI_CH_ClearStatusFlag(handle->channel, rx_events);
      data_value = XMC_SPI_CH_GetReceivedData(handle->channel);

      memcpy((void *)&rx_dataptr[data_indx - bytes_per_word], (void *)&data_value, bytes_per_word);
      data_indx = data_indx + bytes_per_word;
    }
    while(!(XMC_SPI_CH_GetStatusFlag(handle->channel) & rx_events))
    {
    }
    XMC_SPI_CH_ClearStatusFlag(handle->channel, rx_events);
  }

  data_value = XMC_SPI_CH_GetReceivedData(handle->channel);
  memcpy((void *)&rx_dataptr[data_indx - bytes_per_word], (void *)&data_value, bytes_per_word);
  ptr_runtime->tx_busy = false;
  ptr_runtime->rx_busy = false;
}
#endif

#ifdef SPI_SLAVE_TX_DMA_USED
/*
 * @brief Registers a request for transmitting data over SPI_SLAVE channel using DMA.
 *
 * @param[in]  SPI_SLAVE_t*  SPI_SLAVE APP handle pointer of type SPI_SLAVE_t
 * @param[in]  uint8_t* Pointer to data
 * @param[in]  uint32_t Total no of words to be transmitted.
 *
 * @return  SPI_SLAVE_STATUS_t SPI_SLAVE_STATUS_SUCCESS if the request is accepted.
 *                        SPI_SLAVE_STATUS_BUSY if a transmission is in progress.
 * Details of function:
 * The data transmission is accomplished using a DMA channel. User can configure
 * a callback function in the APP UI. When the data is fully transmitted, the callback
 * function will be executed.
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_StartTransmitDMA(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count)
{
  SPI_SLAVE_STATUS_t ret_stat = SPI_SLAVE_STATUS_MODE_MISMATCH;
  SPI_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const SPI_SLAVE_DMA_CONFIG_t * ptr_dma_config = handle->config->transmit_dma_config;
  XMC_DMA_t * ptr_gpdma = handle->config->global_dma->dma;
  uint32_t slave_mode = (uint32_t)handle->runtime->spi_current_mode;

  XMC_ASSERT("SPI_SLAVE_StartTransmitDMA: SPI_SLAVE APP handle invalid", (((handle != NULL)&&
            (ptr_runtime != NULL))&&(handle->config != NULL)))

  if (handle->config->transmit_mode == SPI_SLAVE_TRANSFER_MODE_DMA)
  {
    ret_stat = SPI_SLAVE_STATUS_BUSY;
    if (ptr_runtime->tx_busy == false)
    {
      /*If there is no transmission in progress*/
      if ((data_ptr != NULL) && ((count > 0U) &&(count <= SPI_SLAVE_DMA_MAXCOUNT)))
      {
        /*Obtain the address of data, size of data*/
        ptr_runtime->tx_data = data_ptr;
        ptr_runtime->tx_data_count = count;
        /*Initialize to first index and set the busy flag*/
        ptr_runtime->tx_data_index = 0U;
        ptr_runtime->tx_busy = true;
        XMC_USIC_CH_SetTransmitBufferStatus(handle->channel, XMC_USIC_CH_TBUF_STATUS_SET_IDLE);
        /*Clear pending triggers*/
        XMC_DMA_ClearRequestLine(ptr_gpdma, handle->config->tx_dlr_line);

        /*Enable transmit event generation*/
        XMC_SPI_CH_EnableEvent(handle->channel, (uint32_t)XMC_SPI_CH_EVENT_RECEIVE_START);

        /*Enable DMA channel*/
        XMC_DMA_CH_SetBlockSize(ptr_gpdma, ptr_dma_config->dma_channel, count);
        XMC_DMA_CH_SetSourceAddress(ptr_gpdma, ptr_dma_config->dma_channel, (uint32_t)data_ptr);
        XMC_DMA_CH_SetDestinationAddress(ptr_gpdma, ptr_dma_config->dma_channel,
                                         (uint32_t)&(handle->channel->TBUF[slave_mode]));
        XMC_DMA_CH_Enable(ptr_gpdma, ptr_dma_config->dma_channel);
        /*First trigger to load TBUF*/
        XMC_USIC_CH_TriggerServiceRequest(handle->channel, handle->config->tx_sr);
        ret_stat = SPI_SLAVE_STATUS_SUCCESS;
      }
      else
      {
        ret_stat = SPI_SLAVE_STATUS_BUFFER_INVALID;
      }
    }
  }
  return ret_stat;
}
#endif

#ifdef SPI_SLAVE_RX_DMA_USED
/*
 * @brief Registers a request to receive data over SPI_SLAVE channel using DMA.
 *
 * @param[in]  SPI_SLAVE_t* SPI_SLAVE APP handle pointer of type SPI_SLAVE_t
 * @param[in]  uint8_t*  Pointer to data array
 * @param[in]  uint32_t  Total no of bytes to be read.
 *
 * @return  SPI_SLAVE_STATUS_t SPI_SLAVE_STATUS_SUCCESS if the request is accepted.
 *                        SPI_SLAVE_STATUS_BUSY if a reception is in progress.
 * Details of function:
 * This function registers the receive request by configuring the SPI_SLAVE
 * receive Standard buffer and the DMA channel. The data
 * is received asynchronously. When the requested number of data bytes are received,
 * optionally, the user configured callback function will be executed.
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_StartReceiveDMA(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count)
{
  SPI_SLAVE_STATUS_t ret_stat = SPI_SLAVE_STATUS_MODE_MISMATCH;
  SPI_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const SPI_SLAVE_DMA_CONFIG_t * ptr_dma_config = handle->config->receive_dma_config;
  XMC_DMA_t * ptr_gpdma = handle->config->global_dma->dma;

  XMC_ASSERT("SPI_SLAVE_StartReceiveDMA: SPI_SLAVE APP handle invalid", (((handle != NULL)&&
            (ptr_runtime != NULL)) && (handle->config != NULL)))

  if (handle->config->receive_mode == SPI_SLAVE_TRANSFER_MODE_DMA)
  {
    ret_stat = SPI_SLAVE_STATUS_BUSY;
    if (ptr_runtime->rx_busy == false)
    {
      /*If no active reception in progress*/
      if ((data_ptr != NULL) && ((count > 0U) && (count <= SPI_SLAVE_DMA_MAXCOUNT)))
      {
        /*Configure hardware port direction required for half duplex mode reception*/
        XMC_SPI_CH_Receive(handle->channel, handle->runtime->spi_current_mode);
        /*Obtain the address of data buffer and
         * number of data bytes to be received*/
        ptr_runtime->rx_data = data_ptr;
        ptr_runtime->rx_data_count = count;
        ptr_runtime->rx_busy = true;
        ptr_runtime->rx_data_index = 0U;
        /*Flush RBUF- Repeat for RBUF0 and RBUF1*/
        (void)XMC_SPI_CH_GetReceivedData(handle->channel);
        (void)XMC_SPI_CH_GetReceivedData(handle->channel);

        XMC_SPI_CH_EnableEvent(handle->channel,
          (uint32_t)((uint32_t)XMC_SPI_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_SPI_CH_EVENT_ALTERNATIVE_RECEIVE));
        ret_stat = SPI_SLAVE_STATUS_SUCCESS;

        /*Enable DMA channel*/
        XMC_DMA_CH_SetBlockSize(ptr_gpdma, ptr_dma_config->dma_channel, count);
        XMC_DMA_CH_SetSourceAddress(ptr_gpdma, ptr_dma_config->dma_channel, (uint32_t)&(handle->channel->RBUF));
        XMC_DMA_CH_SetDestinationAddress(ptr_gpdma, ptr_dma_config->dma_channel, (uint32_t)data_ptr);
        XMC_DMA_CH_Enable(ptr_gpdma, ptr_dma_config->dma_channel);
      }
      else
      {
        ret_stat = SPI_SLAVE_STATUS_BUFFER_INVALID;
      }
    }
  }
  return ret_stat;
}
#endif

#ifdef SPI_SLAVE_TX_DIRECT_USED
/*
 * Polling method to transmit data.
 * @param[in] SPI_SLAVE_t* handle SPI_SLAVE APP handle pointer
 * @param[in] uint8_t*  Pointer to data array
 * @param[in] uint32_t number of bytes to be transmitted.
 *
 * @return SPI_SLAVE_STATUS_t Status of transmit request handling.
 *
 * Description:
 * Transmits data by blocking the CPU until all data is sent. Transmission
 * cannot be aborted since it is blocking implementation. Based on FIFO selection,
 * either TBUF or IN register is updated with the data.
 *
 */
static SPI_SLAVE_STATUS_t SPI_SLAVE_lTransmitPolling(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count)
{
  SPI_SLAVE_STATUS_t ret_stat = SPI_SLAVE_STATUS_BUFFER_INVALID;
  uint32_t loc_index;
  SPI_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  uint16_t * ptr_data_16bit;


  ptr_runtime->tx_busy = true;
  if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    /*Clear the transmit FIFO*/
    XMC_USIC_CH_TXFIFO_Flush(handle->channel);
  }
  else
  {
    XMC_SPI_CH_ClearStatusFlag(handle->channel, (uint32_t)XMC_SPI_CH_STATUS_FLAG_RECEIVER_START_INDICATION);
  }
  /*Invalidate TBUF*/
  XMC_USIC_CH_SetTransmitBufferStatus(handle->channel, XMC_USIC_CH_TBUF_STATUS_SET_IDLE);

  /*Loop through each byte*/
  for (loc_index = 0U; loc_index < count; loc_index++)
  {
    if(ptr_runtime->data_size == SPI_SLAVE_DATA_SIZE_8BITS)
    {
      XMC_SPI_CH_Transmit(handle->channel,(uint16_t)data_ptr[loc_index], ptr_runtime->spi_current_mode);
    }
    else
    {
      ptr_data_16bit = (uint16_t*)data_ptr;
      XMC_SPI_CH_Transmit(handle->channel, ptr_data_16bit[loc_index], ptr_runtime->spi_current_mode);
    }
    /*If FIFO is enabled, FIFO filling status should be checked
     * to avoid overflow error*/
    if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      /*Wait if transmit FIFO is full*/
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == true)
      {
      }
    }
    else
    {
      while(!(XMC_SPI_CH_GetStatusFlag(handle->channel) & (uint32_t)XMC_SPI_CH_STATUS_FLAG_RECEIVER_START_INDICATION))
      {
      }
    }
  }

  if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    /*Wait till FIFO is empty*/
    while (XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel) == false)
    {
    }
  }
  ret_stat = SPI_SLAVE_STATUS_SUCCESS;
  ptr_runtime->tx_busy = false;
  return ret_stat;
}
#endif

#ifdef SPI_SLAVE_RX_DIRECT_USED
/*
 * Polling method to receive data.
 * @param[in] SPI_SLAVE_t* handle SPI_SLAVE APP handle pointer
 * @param[in] uint8_t*  Pointer to data array
 * @param[in] uint32_t number of bytes to be received.
 *
 * @return SPI_SLAVE_STATUS_t Status of receive request handling.
 *
 * Description:
 * Receives data by blocking the CPU until all data is received. Reception
 * cannot be aborted since it is blocking implementation. Based on FIFO selection,
 * either RBUF or OUT register will be read.
 *
 */
static SPI_SLAVE_STATUS_t SPI_SLAVE_lReceivePolling(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count)
{
  SPI_SLAVE_STATUS_t ret_stat = SPI_SLAVE_STATUS_BUFFER_INVALID;
  uint32_t loc_index;
  uint32_t loc_status;
  SPI_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  uint16_t * ptr_data_16bit;
  uint32_t rx_events = ((uint32_t)XMC_SPI_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION |
                        (uint32_t)XMC_SPI_CH_STATUS_FLAG_RECEIVE_INDICATION);


  ptr_runtime->rx_busy = true;
  /*Configure hardware port direction required for half duplex mode reception*/
  XMC_SPI_CH_Receive(handle->channel, handle->runtime->spi_current_mode);

  if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    /*Clear the receive FIFO, configure the trigger lime
     * and enable the receive events*/
    XMC_USIC_CH_RXFIFO_Flush(handle->channel);
  }
  else
  {
    XMC_SPI_CH_ClearStatusFlag(handle->channel, rx_events);
  }
  /*Flush RBUF- Repeat for RBUF0 and RBUF1*/
  (void)XMC_SPI_CH_GetReceivedData(handle->channel);
  (void)XMC_SPI_CH_GetReceivedData(handle->channel);


  for (loc_index = 0U; loc_index < count; loc_index++)
  {
    /*If receive FIFO is configured, wait for FIFO to get data.*/
    if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      /*Wait if FIFO empty*/
      while(XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == true)
      {
      }
    }
    else
    {
      /*Wait for RIF or AIF flag update*/
      do
      {
        loc_status = XMC_SPI_CH_GetStatusFlag(handle->channel);
      }while (!(loc_status & rx_events));

      /*Clear the detected event.
       * Both events should not be cleared at once, otherwise if 2 bytes are received, only
       * one byte will be read.*/
      XMC_SPI_CH_ClearStatusFlag(handle->channel, rx_events);
    }
    if(ptr_runtime->data_size == SPI_SLAVE_DATA_SIZE_8BITS)
    {
      data_ptr[loc_index] = (uint8_t)XMC_SPI_CH_GetReceivedData(handle->channel);
    }
    else
    {
      ptr_data_16bit = (uint16_t*)data_ptr;
      ptr_data_16bit[loc_index] = (uint16_t)XMC_SPI_CH_GetReceivedData(handle->channel);
    }
  }
  ret_stat = SPI_SLAVE_STATUS_SUCCESS;
  ptr_runtime->rx_busy = false;
  return ret_stat;
}
#endif

#ifdef SPI_SLAVE_PROTOCOL_EVENT_USED
/*
 * Protocol interrupt handling function.
 * The function is common for different instances of the SPI_SLAVE APP.
 *
 * param[in]  handle SPI_SLAVE APP handle pointer of type SPI_SLAVE_t*
 *
 * return void
 */
void SPI_SLAVE_lProtocolHandler(const SPI_SLAVE_t * const handle)
{
  /*Protocol status value to check which event occured*/
  uint32_t psr_status = XMC_SPI_CH_GetStatusFlag(handle->channel);

  /*Check if slave select event generated*/
  if((psr_status & (uint32_t)XMC_SPI_CH_STATUS_FLAG_DX2T_EVENT_DETECTED) && (handle->config->slave_select_cbhandler != NULL))
  {
    XMC_SPI_CH_ClearStatusFlag(handle->channel, (uint32_t)XMC_SPI_CH_STATUS_FLAG_DX2T_EVENT_DETECTED);
    /*Call the callback function if it is valid*/
    handle->config->slave_select_cbhandler();
  }/*Check if parity error has occured*/
  else if((psr_status & (uint32_t)XMC_SPI_CH_STATUS_FLAG_PARITY_ERROR_EVENT_DETECTED) && (handle->config->parity_error_cbhandler != NULL))
  {
    XMC_SPI_CH_ClearStatusFlag(handle->channel, (uint32_t)XMC_SPI_CH_STATUS_FLAG_PARITY_ERROR_EVENT_DETECTED);
    /*Call the callback function if it is valid*/
    handle->config->parity_error_cbhandler();
  }
  else
  {
  }
}
#endif
