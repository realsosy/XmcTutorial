/**
 * @file counter.h
 * @date 2016-07-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * COUNTER v4.1.10 - Counts the occurrences of external events using one timer slice of CCU4 or CCU8
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version for DAVEv4.<BR>
 *
 * 2015-04-06:
 *     - Modified the config structure of the COUNTER.<BR>
 *     - Enables usage of external event-2 for gating.<BR>
 *     - UI modified to support the edge selection for Count Direction and Gating.<BR>
 *     - API name change COUNTER_AcknowledgeInterrupt to COUNTER_ClearEvent.<BR>
 *
 * 2015-07-09:
 *     - Documentation updated.<BR>
 *
 * 2015-09-01:
 *     - XMC14 device support added..<BR>
 *
 * 2015-10-08:
 *     - Added support for XMC4700/XMC4800 devices.<BR>
 *
 * 2015-12-16:
 *     - Added support for XMC4300 devices.<BR>
 *
 * 2016-07-08:
 *     - Fixed incorrect case for an included header.<br>
 *     - All event signals are made mandatory.<BR>
 *
 * @endcond
 *
 */

/*CODE_BLOCK_BEGIN*/
#ifndef COUNTER_H
#define COUNTER_H


/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "counter_conf.h"
#include <DAVE_Common.h>

 /**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "COUNTER requires XMC Peripheral Library v2.0.0 or higher"
#endif

 /**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
/**
 * @ingroup COUNTER_enumerations
 * @{
 */
/**@brief Return value of an API  */
typedef enum COUNTER_STATUS
{
  COUNTER_STATUS_SUCCESS    = 0,  /**< App is Initialized*/
  COUNTER_STATUS_FAILURE, 		   /**< Initialization failed*/
  COUNTER_STATUS_UNINITIALIZED,   /**< App is Uninitialized*/
  COUNTER_STATUS_RUNNING,         /**< The counter instance is running*/
  COUNTER_STATUS_IDLE             /**< The counter instance has stopped and the Slice is idle*/
} COUNTER_STATUS_t;

/**
 * @brief Selected peripheral either CCU4 or CCU8
 */
typedef enum COUNTER_TYPE
{
  COUNTER_CCU4 = 0, /**< the selected peripheral is CCU4*/
  COUNTER_CCU8      /**< the selected peripheral is CCU8*/
} COUNTER_CCU_t;

/**
 * @brief Selected event of CCUx
 */
typedef enum COUNTER_EVENT_TYPE
{
  COUNTER_EVENT_ROLLOVER_MATCH = 0U, /**< Event for Rollover condition*/
  COUNTER_EVENT_COUNT_MATCH    = 2U, /**< Event for count match condition*/
  COUNTER_EVENT_EDGE_EVENT     = 8U, /**< Event for event edge */
  COUNTER_EVENT_COUNT_DIR      = 9U,  /**< Event for count direction */
  COUNTER_EVENT_GATING_LEVEL   = 10U /**< Event for gating level */
}COUNTER_EVENT_t;

/**
 * @brief Mapping of External Event-1 of the CCUx
 */
typedef enum COUNTER_EXT_SIG
{
  COUNTER_EXT_SIG_NONE,
  COUNTER_EXT_SIG_COUNT_DIR,  /**< Used for using external signal for changing the count direction*/
  COUNTER_EXT_SIG_GATING /**<Used for using external gating signal for the counter operation*/
}COUNTER_EXT_SIG_t;

/**
 * @}
 */
/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/**
 * @ingroup COUNTER_datastructures
 * @{
 */
#ifdef COUNTER_CCU4_USED
/**
 * @brief Configuration information needed for CCU4 based COUNTER
 */
typedef struct COUNTER_CCU4_CONFIG
{
  GLOBAL_CCU4_t *const global_handle; /**< Holds the global handle for GLOBAL_CCU4 APP */

  XMC_CCU4_MODULE_t *const kernel_ptr; /**< Hold the base address of CCU4 kernel.*/

  XMC_CCU4_SLICE_t *const slice_ptr; /**< Hold the address of CCU4 slice.*/

  const XMC_CCU4_SLICE_EVENT_CONFIG_t *const event0_config; /**< Configure the event-0 for the count operation*/

  const XMC_CCU4_SLICE_EVENT_CONFIG_t *const count_dir_event_config; /**<Configure the External
                                                                         event for count direction*/

  const XMC_CCU4_SLICE_EVENT_CONFIG_t *const gating_event_config; /**<Configure the External
                                                                           event for gating signal*/

  const uint32_t shadow_mask;       /**< Holds the shadow transfer mask of the consumed slice*/

  const uint16_t count_match_value; /**< The number of edges to be counted to generate a count match interrupt*/

  const XMC_CCU4_SLICE_EVENT_t countdir_event; /**<Configures the External count direction function of the CCU slice*/

  const XMC_CCU4_SLICE_EVENT_t gating_event;   /**< Configures the External gating function of the CCU slice*/

  const XMC_CCU4_SLICE_SR_ID_t count_match_node_id; /**< SR line for count match */

  const XMC_CCU4_SLICE_SR_ID_t count_rollover_node_id; /**< SR line for count rollover event */

  const XMC_CCU4_SLICE_SR_ID_t event_edge_det_node_id; /**< SR line for event edge detection*/

  const XMC_CCU4_SLICE_SR_ID_t event1_node_id; /**< SR line for gating level detection/count direction detection */

  const XMC_CCU4_SLICE_SR_ID_t event2_node_id; /**< SR line for gating level detection if count direction
                                                    is used by event-1 */

  COUNTER_STATUS_t state; /**< The current state of the APP*/

  const uint8_t kernel_number; /**< The CCU4 kernel number in which the counter is configured*/

  const uint8_t slice_number; /**< The CCU4 slice which is used a counter*/

  const bool intr_count_match; /**< Enable/Disable the count match event */

  const bool intr_count_rollover; /**<  Enable/Disable the count rollover event */

  const bool intr_evt_edge_detect; /**<  Enable/Disable the event edge event */

  const bool intr_event1_detect; /**<  Enable/Disable the count direction detection event or gating level event */

  const bool intr_event2_detect; /**<  Enable/Disable the gating level event*/

  const bool init_start; /**< Start the counter after initialization. */
}COUNTER_CCU4_CONFIG_t;
#endif

#ifdef COUNTER_CCU8_USED
/**
 * @brief Configuration information needed for CCU8 based COUNTER
 */
typedef struct COUNTER_CCU8_CONFIG
{
  GLOBAL_CCU8_t *const global_handle; /**< Holds the global handle for GLOBAL_CCU8 APP */

  XMC_CCU8_MODULE_t *const kernel_ptr; /**< Hold the base address of CCU8 kernel.*/

  XMC_CCU8_SLICE_t *const slice_ptr; /**< Hold the address of CCU8 slice.*/

  const XMC_CCU8_SLICE_EVENT_CONFIG_t *const event0_config; /**< Configure the event for the count operation*/

  const XMC_CCU8_SLICE_EVENT_CONFIG_t *const count_dir_event_config; /**<Configure the External
                                                                         event for count direction*/

  const XMC_CCU8_SLICE_EVENT_CONFIG_t *const gating_event_config; /**<Configure the External
                                                                           event for gating signal*/

  const uint32_t shadow_mask;       /**< Holds the shadow transfer mask of the consumed slice*/

  const uint16_t count_match_value; /**< The number of edges to be counted to generate a count match interrupt*/

  const XMC_CCU8_SLICE_EVENT_t countdir_event; /**<Configures the External count direction function of the CCU slice*/

  const XMC_CCU8_SLICE_EVENT_t gating_event;  /**< Configures the External gating function of the CCU slice*/

  const XMC_CCU8_SLICE_SR_ID_t count_match_node_id; /**< SR line for count match */

  const XMC_CCU8_SLICE_SR_ID_t count_rollover_node_id; /**< SR line for count rollover event */

  const XMC_CCU8_SLICE_SR_ID_t event_edge_det_node_id; /**< SR line for event edge detection*/

  const XMC_CCU8_SLICE_SR_ID_t event1_node_id; /**< SR line for gating level detection/count direction detection */

  const XMC_CCU8_SLICE_SR_ID_t event2_node_id; /**< SR line for gating level detection if count direction
                                                    is used by event-1 */

  COUNTER_STATUS_t state; /**< The current state of the APP*/

  const uint8_t kernel_number; /**< The CCU8 kernel number in which the counter is configured*/

  const uint8_t slice_number; /**< The CCU8 slice which is used a counter*/

  const bool intr_count_match; /**< Enable/Disable the count match event */

  const bool intr_count_rollover; /**<  Enable/Disable the count rollover event */

  const bool intr_evt_edge_detect; /**<  Enable/Disable the event edge event */

  const bool intr_event1_detect; /**<  Enable/Disable the count direction detection event or gating level event */

  const bool intr_event2_detect; /**<  Enable/Disable the gating level event if event-1 is used by count direction*/

  const bool init_start; /**< Start the counter after initialization. */
}COUNTER_CCU8_CONFIG_t;
#endif

/**
 * @brief Configuration structure for COUNTER APP
 */
typedef struct COUNTER_handle
{
  COUNTER_CCU_t counter_type; /**< Determines which peripheral the Counter will run in*/
#ifdef COUNTER_CCU4_USED
  COUNTER_CCU4_CONFIG_t *const ccu4_handle; /**< Pointer to the CC4 configuration handler*/
#endif
#ifdef COUNTER_CCU8_USED
  COUNTER_CCU8_CONFIG_t *const ccu8_handle; /**< Pointer to the CC8 configuration handler*/
#endif
}COUNTER_t;

/**
 * @}
 */

#ifdef __cplusplus
extern "C" {
#endif
/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @ingroup COUNTER_apidoc
 * @{
 */

/**
 * @brief Get COUNTER APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * int main(void) {
 *   DAVE_STATUS_t init_status;
 *   DAVE_APP_VERSION_t version;
 *
 *   // Initialize COUNTER APP:
 *   // COUNTER_Init() is called from within DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   version = COUNTER_GetAppVersion();
 *   if (version.major != 1U) {
 *     // Probably, not the right version.
 *   }
 *
 *   // More code here
 *   while(1) {
 *
 *   }
 *   return (0);
 * }
 * @endcode
 */
DAVE_APP_VERSION_t COUNTER_GetAppVersion(void);

/**
 * @brief Initializes COUNTER APP <BR>
 * @param handle_ptr pointer to the Instance variable<BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Initializes the CCU counter with the configured parameters. Initialization of CCU global and slice registers.
 * Init would invoke the GLOBAL_CCx init API. It also configures the External Event-0 & External Event-1 (conditionally)
 * of CCUx.
 *
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *    DAVE_Init(); //COUNTER_Init is called within DAVE_Init
 *    while(1);
 *    return 0;
 * }
 @endcode
 */
COUNTER_STATUS_t COUNTER_Init(COUNTER_t *const handle_ptr);

/**
 * @brief Starts the counter.<BR>
 * @param handle_ptr pointer to the Instance variable<BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Start the counter operation. To be called if "Start after initialization" is
 * unchecked in the UI. This API would enable the clock for the CCUx slice and also starts the counter operation.
 * Invoke this API only after initialization and when the counter is not running. If invoked outside
 * these conditions, the API will have no effect.
 *
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *    DAVE_Init(); //COUNTER_Init is called within DAVE_Init
 *
 *    COUNTER_Start(&COUNTER_0);
 *    while(1);
 *    return 0;
 * }
 @endcode
 */
void COUNTER_Start(COUNTER_t *const handle_ptr);

/**
 * @brief Stops the counter<BR>
 * @param handle_ptr pointer to the Instance variable<BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Stop the counter operation. This API would disable the clock for the CCUx slice and also
 * stops the counter operation. Invoke this API only after initialization and when the counter is running.
 * If invoked outside these conditions, the API will have no effect.
 *
 * @code
 *  // Drag an INTERRUPT,PWM ,DIGITAL_IO APPs into the project.
 *  // Enable Count match event in the UI editor of COUNTER APP.
 *  // Configure the handler name in the INTERRUPT APP as count_match_handler. Goto the HW signal connections
 *  // connect the event_count_match from the COUNTER_0 APP to the NVIC node in the INTERRUPT APP.
 *  // In the PWM APP UI editor enable the start after initialization option.
 *  // In the DIGITAL_IO configure the pin as input. goto to the HW signal connections and connect counter_input to the
 *  // DIGITAL_IO_0
 *  // Externally give connections of the PWM output to the DIGITAL_IO_0 pin.
 *
 * #include <DAVE.h>
 *  //count match interrupt
 * void count_match_handler(void)
 * {
 * 	COUNTER_Stop(&COUNTER_0);
 * 	COUNTER_ClearEvent(&COUNTER_0,COUNTER_EVENT_COUNT_MATCH);
 * }
 *
 * int main(void)
 * {
 *    DAVE_Init(); //COUNTER_Init is called within DAVE_Init
 *    COUNTER_Start(&COUNTER_0);
 *
 *    while(1);
 *    return 0;
 * }
 @endcode
 */
void COUNTER_Stop(COUNTER_t *const handle_ptr);

/**
 * @brief Gets the captured events.<BR>
 * @param handle_ptr pointer to the Instance variable<BR>
 * @return The function will return the value of the count using this variable.<BR>
 *
 * \par<b>Description:</b><br>
 * Gets total number of captured events. Returns the TIMER register value which holds the number of events captured
 * till now.
 *
 * @code
 *  // Drag an INTERRUPT,PWM ,DIGITAL_IO APPs into the project.
 *  // Enable Count match event in the UI editor of COUNTER APP and the count value to 200.
 *  // Configure the handler name in the INTERRUPT APP as count_match_handler. Goto the HW signal connections
 *  // connect the event_count_match from the COUNTER_0 APP to the NVIC node in the INTERRUPT APP.
 *  // In the PWM APP UI editor enable the start after initialization option.
 *  // In the DIGITAL_IO configure the pin as input. goto to the HW signal connections and connect counter_input to the
 *  // DIGITAL_IO_0.
 *  // Externally give connections of the PWM output to the DIGITAL_IO_0 pin.
 *
 * #include <DAVE.h>
 * uint16_t count_value;
 *
 *  //count match interrupt
 * void count_match_handler(void)
 * {
 * 	count_value = COUNTER_GetCurrentCount(&COUNTER_0);
 * 	if (count_value == 200)
 * 	{
 * 	  //count operation successful
 * 	  //DO something
 * 	}
 * 	COUNTER_ClearEvent(&COUNTER_0,COUNTER_EVENT_COUNT_MATCH);
 * }
 *
 * int main(void)
 * {
 *    DAVE_Init(); //COUNTER_Init is called within DAVE_Init
 *    COUNTER_Start(&COUNTER_0);
 *    while(1);
 *    return 0;
 * }
 @endcode
 */
uint16_t COUNTER_GetCurrentCount(COUNTER_t *const handle_ptr);

/**
 * @brief Gets count match value for the slice.<BR>
 * @param handle_ptr pointer to the Instance variable<BR>
 * @return The function will return the value of the count match using this variable.<BR>
 *
 * \par<b>Description:</b><br>
 * Returns the current count match value. Reads the compare register of the CCUx, this holds the count match value.
 * In case of CCU8 it reads from compare register 1.
 *
 * @code
 *  // Drag an INTERRUPT,PWM ,DIGITAL_IO APPs into the project.
 *  // Enable Count match event in the UI editor of COUNTER APP.
 *  // Configure the handler name in the INTERRUPT APP as count_match_handler. Goto the HW signal connections
 *  // connect the event_count_match from the COUNTER_0 APP to the NVIC node in the INTERRUPT APP.
 *  // In the PWM APP UI editor enable the start after initialization option.
 *  // In the DIGITAL_IO configure the pin as input. goto to the HW signal connections and connect counter_input to the
 *  // DIGITAL_IO_0
 *  // Externally give connections of the PWM output to the DIGITAL_IO_0 pin.
 *
 * #include <DAVE.h>
 * uint16_t count_value,count_match;
 *
 *  //count match interrupt
 * void count_match_handler(void)
 * {
 * 	count_value = COUNTER_GetCurrentCount(&COUNTER_0);
 * 	count_match = COUNTER_GetCountMatch(&COUNTER_0);
 * 	if(count_match == count_value)
 * 	{
 * 	  // The captured events value will be the same as that of the count match
 * 	}
 * 	COUNTER_ClearEvent(&COUNTER_0,COUNTER_EVENT_COUNT_MATCH);
 * }
 *
 * int main(void)
 * {
 *    DAVE_Init(); //COUNTER_Init is called within DAVE_Init
 *    COUNTER_Start(&COUNTER_0);
 *
 *    while(1);
 *    return 0;
 * }
 @endcode
 */
uint16_t COUNTER_GetCountMatch(COUNTER_t *const handle_ptr);

/**
 * @brief Sets the count match value for the slice.<BR>
 * @param handle_ptr pointer to the Instance variable<BR>
 * @param count_match value to be set as the count match<BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Configures the COUNTER with new count match value. Sets the count match value in the compare register of the CCUx.
 * In case of CCU8 it sets the value into compare register 1.
 *
 * @code
 *  // Drag an INTERRUPT,PWM ,DIGITAL_IO APPs into the project.
 *  // Enable Count match event in the UI editor of COUNTER APP and the count value to 200.
 *  // Configure the handler name in the INTERRUPT APP as count_match_handler. Goto the HW signal connections
 *  // connect the event_count_match from the COUNTER_0 APP to the NVIC node in the INTERRUPT APP.
 *  // In the PWM APP UI editor enable the start after initialization option.
 *  // In the DIGITAL_IO configure the pin as input. goto to the HW signal connections and connect counter_input to the
 *  // DIGITAL_IO_0.
 *  // Externally give connections of the PWM output to the DIGITAL_IO_0 pin.
 *
 * #include <DAVE.h>
 * uint16_t count_value;
 *
 * //count match interrupt
 * void count_match_handler(void)
 * {
 * 	count_value = COUNTER_GetCurrentCount(&COUNTER_0);
 * 	if((uint16_t)5000 == count_value)
 * 	{
 * 	  //The New Count Match value was set
 * 	  //do something
 * 	  COUNTER_Stop(&COUNTER_0);
 * 	}
 * 	COUNTER_ClearEvent(&COUNTER_0,COUNTER_EVENT_COUNT_MATCH);
 * }
 *
 * int main(void)
 * {
 *    DAVE_Init(); //COUNTER_Init is called within DAVE_Init
 *
 *    COUNTER_SetCountMatch(&COUNTER_0,(uint16_t)5000);
 *    COUNTER_Start(&COUNTER_0);
 *    while(1);
 *    return 0;
 * }
 @endcode
 */
void COUNTER_SetCountMatch(COUNTER_t *const handle_ptr, uint16_t count_match);

/**
 * @brief Return the status of the counter.<BR>
 * @param handle_ptr pointer to the Instance variable<BR>
 * @return Status of the CCU slice. Returns either running or idle.<BR>
 *
 * \par<b>Description:</b><br>
 * Returns the current state of the counter slice. Checks for the counter status if the associated timer is
 * idle or running. A call to this API is invalid if invoked before initialization.
 *
 * @code
 *  // Drag a PWM ,DIGITAL_IO APPs into the project.
 *  // Enable Count match event in the UI editor of COUNTER APP and the count value to 200.
 *  // In the PWM APP UI editor enable the start after initialization option.
 *  // In the DIGITAL_IO configure the pin as input. goto to the HW signal connections and connect counter_input to the
 *  // DIGITAL_IO_0.
 *  // Externally give connections of the PWM output to the DIGITAL_IO_0 pin.
 *
 * #include <DAVE.h>
 * int main(void)
 * {
 *    COUNTER_STATUS_t state;
 *    DAVE_Init(); //COUNTER_Init is called within DAVE_Init
 *    COUNTER_Start(&COUNTER_0);
 *
 *    state = COUNTER_GetCounterStatus(&COUNTER_0);
 *    if(state == COUNTER_STATUS_IDLE)
 *    {
 *       //Something went wrong
 *       while(1);
 *    }
 *
 *    // Do something
 *
 *    while(1);
 *    return 0;
 * }
 @endcode
 */
COUNTER_STATUS_t COUNTER_GetCounterStatus(COUNTER_t *const handle_ptr);

/**
 * @brief Clear pending event.<BR>
 * @param handle_ptr pointer to the Instance variable<BR>
 * @param event The event that has to be cleared.<BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Clears the CCUx related interrupt. When an interrupt occurs it must be acknowledged by clearing the
 * respective flag in the hardware. After servicing the interrupt, this function should be called to
 * clear the pending bit. This API would clear the interrupt type ::COUNTER_EVENT_t.
 *
 * @code
 *  // Drag an INTERRUPT,PWM ,DIGITAL_IO APPs into the project.
 *  // Enable Count match event in the UI editor of COUNTER APP and the count value to 200.
 *  // Configure the handler name in the INTERRUPT APP as count_match_handler. Goto the HW signal connections
 *  // connect the event_count_match from the COUNTER_0 APP to the NVIC node in the INTERRUPT APP.
 *  // In the PWM APP UI editor enable the start after initialization option.
 *  // In the DIGITAL_IO configure the pin as input. goto to the HW signal connections and connect counter_input to the
 *  // DIGITAL_IO_0.
 *  // Externally give connections of the PWM output to the DIGITAL_IO_0 pin.
 *
 * #include <DAVE.h>
 * uint16_t count_value;
 *
 * //count match interrupt
 * void count_match_handler(void)
 * {
 * 	count_value = COUNTER_GetCurrentCount(&COUNTER_0);
 * 	if((uint16_t)5000 == count_value)
 * 	{
 * 	  //The New Count Match value was set
 * 	  //do something
 * 	  COUNTER_Stop(&COUNTER_0);
 * 	}
 * 	COUNTER_ClearEvent(&COUNTER_0,COUNTER_EVENT_COUNT_MATCH);
 * }
 *
 * int main(void)
 * {
 *    DAVE_Init(); //COUNTER_Init is called within DAVE_Init
 *
 *    COUNTER_SetCountMatch(&COUNTER_0,(uint16_t)5000);
 *    COUNTER_Start(&COUNTER_0);
 *    while(1);
 *    return 0;
 * }
 @endcode
 */
void COUNTER_ClearEvent(COUNTER_t *const handle_ptr,COUNTER_EVENT_t event);

/**
 * @brief Gets the status of the interrupt.<BR>
 * @param handle_ptr pointer to the Instance variable<BR>
 * @param event The event whose information has to be returned.<BR>
 * @return Returns true if the event is pending.<BR>
 *
 * \par<b>Description:</b><br>
 * Returns the status of the corresponding interrupt. Reads the appropriate flag in the hardware register
 * and would return true if the event was asserted.
 *
 * @code
 *  // Drag an INTERRUPT,PWM ,DIGITAL_IO APPs into the project.
 *  // Enable Count match event and period match event in the UI editor of COUNTER APP.
 *  // Configure the handler name in the INTERRUPT APP as period_and_count_match_handler. Goto the HW signal connections
 *  // connect the event_count_match and period match from the COUNTER_0 APP to the same NVIC node in the INTERRUPT APP.
 *  // In the PWM APP UI editor enable the start after initialization option.
 *  // In the DIGITAL_IO configure the pin as input. goto to the HW signal connections and connect counter_input to the
 *  // DIGITAL_IO_0
 *  // Externally give connections of the PWM output to the DIGITAL_IO_0 pin.
 *
 * #include <DAVE.h>
 *
 * //count match interrupt
 * void period_and_count_match_handler(void)
 * {
 * 	if(COUNTER_GetInterruptStatus(&COUNTER_0,COUNTER_EVENT_COUNT_MATCH))
 * 	{
 * 	    // Do something for count match event
 *  	COUNTER_ClearEvent(&COUNTER_0,COUNTER_EVENT_COUNT_MATCH);
 *  }
 *  if(COUNTER_GetInterruptStatus(&COUNTER_0,COUNTER_EVENT_ROLLOVER_MATCH))
 * 	{
 * 	    // Do something for rollover event
 * 	    COUNTER_Stop(&COUNTER_0);
 *  	COUNTER_ClearEvent(&COUNTER_0,COUNTER_EVENT_ROLLOVER_MATCH);
 *  }
 * }
 *
 * int main(void)
 * {
 *    DAVE_Init(); //COUNTER_Init is called within DAVE_Init
 *
 *    COUNTER_SetCountMatch(&COUNTER_0,(uint16_t)5000);
 *    COUNTER_Start(&COUNTER_0);
 *    while(1);
 *    return 0;
 * }
 @endcode
 */
bool COUNTER_GetInterruptStatus(COUNTER_t *const handle_ptr,COUNTER_EVENT_t event);

/**
 * @brief Clears the counter value.<BR>
 * @param handle_ptr pointer to the Instance variable<BR>
 * @return None <BR>
 *
 * \par<b>Description:</b><br>
 * Clears the captured events. Invoking this API will result in the captured events in the timer register
 * to be cleared.
 *
 * @code
 *  // Drag an INTERRUPT,PWM ,DIGITAL_IO APPs into the project.
 *  // Enable Count match event in the UI editor of COUNTER APP and the count value to 200.
 *  // Configure the handler name in the INTERRUPT APP as count_match_handler. Goto the HW signal connections
 *  // connect the event_count_match from the COUNTER_0 APP to the NVIC node in the INTERRUPT APP.
 *  // In the PWM APP UI editor enable the start after initialization option.
 *  // In the DIGITAL_IO configure the pin as input. goto to the HW signal connections and connect counter_input to the
 *  // DIGITAL_IO_0.
 *  // Externally give connections of the PWM output to the DIGITAL_IO_0 pin.
 *  // This generates an interrupt for every 200 counts.
 *
 * #include <DAVE.h>
 * uint16_t count_value;
 *
 * //count match interrupt
 * void count_match_handler(void)
 * {
 * 	COUNTER_Stop(&COUNTER_0);
 * 	COUNTER_ResetCounter(&COUNTER_0);
 * 	COUNTER_ClearEvent(&COUNTER_0,COUNTER_EVENT_COUNT_MATCH);
 * }
 *
 * int main(void)
 * {
 *    DAVE_Init(); //COUNTER_Init is called within DAVE_Init
 *
 *    COUNTER_Start(&COUNTER_0);
 *    while(1);
 *    return 0;
 * }
 @endcode
 */
void COUNTER_ResetCounter(COUNTER_t *const handle_ptr);
/**
 * @}
 */
#include "counter_extern.h"
#ifdef __cplusplus
}
#endif

#endif /* COUNTER_H_ */
