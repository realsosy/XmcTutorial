/**
 * @file counter.c
 * @date 2016-07-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * COUNTER v4.1.10 - Counts the occurrences of external events using one timer slice of CCU4 or CCU8
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version for DAVEv4.<BR>
 *
 * 2015-04-06:
 *     - Modified the config structure of the COUNTER.<BR>
 *     - Enables usage of external event-2 for gating.<BR>
 *     - UI modified to support the edge selection for Count Direction and Gating.<BR>
 *     - API name change COUNTER_AcknowledgeInterrupt to COUNTER_ClearEvent.<BR>
 *
 * 2015-07-09:
 *     - Documentation updated.<BR>
 *
 * 2015-09-01:
 *     - XMC14 device support added..<BR>
 *
 * 2015-10-08:
 *     - Added support for XMC4700/XMC4800 devices.<BR>
 *
 * 2015-12-16:
 *     - Added support for XMC4300 devices.<BR>
 *
 * 2016-07-08:
 *     - Fixed incorrect case for an included header.<br>
 *     - All event signals are made mandatory.<BR>
 *
 * @endcond
 *
 */

/*CODE_BLOCK_BEGIN*/
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "counter.h"

 /**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

#define COUNTER_PERIOD_MAX_VALUE ((uint16_t)0xFFFF)

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
#ifdef COUNTER_CCU4_USED
COUNTER_STATUS_t COUNTER_CCU4_lInit(COUNTER_CCU4_CONFIG_t *const handle_ptr);

void COUNTER_CC4_lStart(COUNTER_CCU4_CONFIG_t *const handle_ptr);

void COUNTER_CC4_lStop(COUNTER_CCU4_CONFIG_t *const handle_ptr);

void COUNTER_CC4_lEvtConfig(XMC_CCU4_SLICE_t *const slice_ptr,XMC_CCU4_SLICE_IRQ_ID_t event_id,
		                    XMC_CCU4_SLICE_SR_ID_t sr_line);
#endif

#ifdef COUNTER_CCU8_USED
COUNTER_STATUS_t COUNTER_CCU8_lInit(COUNTER_CCU8_CONFIG_t *const handle_ptr);

void COUNTER_CC8_lStart(COUNTER_CCU8_CONFIG_t *const handle_ptr);

void COUNTER_CC8_lStop(COUNTER_CCU8_CONFIG_t *const handle_ptr);

void COUNTER_CC8_lEvtConfig(XMC_CCU8_SLICE_t *const slice_ptr,XMC_CCU8_SLICE_IRQ_ID_t event_id,
		                    XMC_CCU8_SLICE_SR_ID_t sr_line);
#endif

#ifdef COUNTER_CCU4_USED
COUNTER_STATUS_t COUNTER_CCU4_lInit(COUNTER_CCU4_CONFIG_t *const handle_ptr)
{
  COUNTER_STATUS_t status;

  XMC_ASSERT("COUNTER_CCU4_lInit:Invalid handle_ptr", (handle_ptr != NULL))

  status = handle_ptr->state;

  if (COUNTER_STATUS_UNINITIALIZED == status)
  {
     status = (COUNTER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_handle);

     /* Select the count mode as Edge Aligned*/
     XMC_CCU4_SLICE_SetTimerCountingMode(handle_ptr->slice_ptr,XMC_CCU4_SLICE_TIMER_COUNT_MODE_EA);

     /* Configure the count operation for event-0*/
     XMC_CCU4_SLICE_CountConfig(handle_ptr->slice_ptr,XMC_CCU4_SLICE_EVENT_0);

     /* Configure various parameters for the event-0*/
     XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->slice_ptr,XMC_CCU4_SLICE_EVENT_0, handle_ptr->event0_config);

     if ( XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->countdir_event)
     {
       /* Configure the Event 1 for external count direction*/
       XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_1,
    		                         handle_ptr->count_dir_event_config);

       /* Configure the external count direction for Event 1*/
       XMC_CCU4_SLICE_DirectionConfig(handle_ptr->slice_ptr, XMC_CCU4_SLICE_EVENT_1);
     }
     if ( XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->gating_event)
     {
       /* Configure the External Event 1 or 2 for external gating*/
       XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->slice_ptr,handle_ptr->gating_event,
    		                         handle_ptr->gating_event_config);

       /* Configure the external gating level for the counter to slice Event 1*/
       XMC_CCU4_SLICE_GateConfig(handle_ptr->slice_ptr,handle_ptr->gating_event);
     }

     /* Set the period register values */
     XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->slice_ptr,COUNTER_PERIOD_MAX_VALUE);

     /* Set the compare register values */
     XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->slice_ptr,handle_ptr->count_match_value);

     /*Requesting the shadow transfer for the CCU4 slice  */
     XMC_CCU4_EnableShadowTransfer(handle_ptr->kernel_ptr,handle_ptr->shadow_mask);

     /* Configure the Interrupts for the various events*/
     if (handle_ptr->intr_count_match != (bool)false)
     {
       /* Enable the count match event */
       COUNTER_CC4_lEvtConfig(handle_ptr->slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP,
    		                  handle_ptr->count_match_node_id);
     }

     if (handle_ptr->intr_count_rollover != (bool)false)
     {
       /* Enable the count rollover event */
       COUNTER_CC4_lEvtConfig(handle_ptr->slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
    		                  handle_ptr->count_rollover_node_id);
     }

     if (handle_ptr->intr_evt_edge_detect != (bool)false)
     {
       /* Enable the event edge detection */
       COUNTER_CC4_lEvtConfig(handle_ptr->slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT0,
    		                  handle_ptr->event_edge_det_node_id);
     }

     if (handle_ptr->intr_event1_detect != (bool)false)
     {
       /* Enable the event generation for External Event-1 */
       COUNTER_CC4_lEvtConfig(handle_ptr->slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT1, handle_ptr->event1_node_id);
     }

     if (handle_ptr->intr_event2_detect != (bool)false)
     {
       /* Enable the event generation for External Event-2 */
       COUNTER_CC4_lEvtConfig(handle_ptr->slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT2, handle_ptr->event2_node_id);
     }

     handle_ptr->state = COUNTER_STATUS_SUCCESS;

     /*if counter start after initialization  is needed */
     if ((bool) true == handle_ptr->init_start)
     {
       COUNTER_CC4_lStart(handle_ptr);
     }
  }
  return status;
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void COUNTER_CC4_lStart(COUNTER_CCU4_CONFIG_t *const handle_ptr)
{
  XMC_ASSERT("COUNTER_CC4_lStart:Invalid handle_ptr", (handle_ptr != NULL))
  if ((COUNTER_STATUS_SUCCESS == handle_ptr->state) &&
      ((bool)false == XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->slice_ptr)))
  {
    /* Enable the clock for the counter slice*/
    XMC_CCU4_EnableClock(handle_ptr->kernel_ptr,handle_ptr->slice_number);

    /* Start the counter operation*/
    XMC_CCU4_SLICE_StartTimer(handle_ptr->slice_ptr);
  }
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void COUNTER_CC4_lStop(COUNTER_CCU4_CONFIG_t *const handle_ptr)
{
  XMC_ASSERT("COUNTER_CC4_lStop:Invalid handle_ptr", (handle_ptr != NULL))
  if ((COUNTER_STATUS_SUCCESS == handle_ptr->state) &&
      ((bool)true == XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->slice_ptr)))
  {
    /* Stop the counter*/
    XMC_CCU4_SLICE_StopTimer(handle_ptr->slice_ptr);

    /* Clear the value in the timer register*/
    XMC_CCU4_SLICE_ClearTimer(handle_ptr->slice_ptr);

    /* Disable the Clock for the counter slice*/
    XMC_CCU4_DisableClock(handle_ptr->kernel_ptr,handle_ptr->slice_number);
  }
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void COUNTER_CC4_lEvtConfig(XMC_CCU4_SLICE_t *const slice_ptr,XMC_CCU4_SLICE_IRQ_ID_t event_id,
                            XMC_CCU4_SLICE_SR_ID_t sr_line)
{
   /* Enable the event generation for event_id */
   XMC_CCU4_SLICE_EnableEvent(slice_ptr,event_id);

   /* Configure the SR line for the event*/
   XMC_CCU4_SLICE_SetInterruptNode(slice_ptr,event_id,sr_line);
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#endif

#ifdef COUNTER_CCU8_USED
COUNTER_STATUS_t COUNTER_CCU8_lInit(COUNTER_CCU8_CONFIG_t *const handle_ptr)
{
  COUNTER_STATUS_t status;
  XMC_ASSERT("COUNTER_CCU8_lInit:Invalid handle_ptr", (handle_ptr != NULL))

  status = handle_ptr->state;

  if (COUNTER_STATUS_UNINITIALIZED == status)
  {

    status = (COUNTER_STATUS_t)GLOBAL_CCU8_Init(handle_ptr->global_handle);

    /* Select the count mode as Edge Aligned*/
    XMC_CCU8_SLICE_SetTimerCountingMode(handle_ptr->slice_ptr,XMC_CCU8_SLICE_TIMER_COUNT_MODE_EA);

    /* Configure the count operation for event-0*/
    XMC_CCU8_SLICE_CountConfig(handle_ptr->slice_ptr,XMC_CCU8_SLICE_EVENT_0);

    /* Configure various parameters for the event-0*/
    XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->slice_ptr,XMC_CCU8_SLICE_EVENT_0, handle_ptr->event0_config);

    if ( XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->countdir_event)
    {
      /* Configure the External Event 1 for external count direction*/
      XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->slice_ptr,XMC_CCU8_SLICE_EVENT_1,
    		                        handle_ptr->count_dir_event_config);

      /* Enable the external count direction for Event 1*/
      XMC_CCU8_SLICE_DirectionConfig(handle_ptr->slice_ptr,XMC_CCU8_SLICE_EVENT_1);
    }
    if ( XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->gating_event)
    {
      /* Configure the Event 1 for external gating*/
      XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->slice_ptr,handle_ptr->gating_event,
                                    handle_ptr->gating_event_config);

      /* Configure the external gating level for the counter to slice Event 1*/
      XMC_CCU8_SLICE_GateConfig(handle_ptr->slice_ptr,handle_ptr->gating_event);
    }

    /* Set the period register values */
    XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->slice_ptr,COUNTER_PERIOD_MAX_VALUE);

    /* Set the compare register values */
    XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->slice_ptr,XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                        handle_ptr->count_match_value);

    /*Requesting the shadow transfer for the CCU8 slice  */
    XMC_CCU8_EnableShadowTransfer(handle_ptr->kernel_ptr,handle_ptr->shadow_mask);


    /* Configure the Interrupts for the various events*/
    if (handle_ptr->intr_count_match != (bool)false)
    {
      /* Enable the count match event */
      COUNTER_CC8_lEvtConfig(handle_ptr->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1,
    		                 handle_ptr->count_match_node_id);
    }

    if (handle_ptr->intr_count_rollover != (bool)false)
    {
      /* Enable the count rollover event */
      COUNTER_CC8_lEvtConfig(handle_ptr->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH,
    		                 handle_ptr->count_rollover_node_id);
    }

    if (handle_ptr->intr_evt_edge_detect != (bool)false)
    {
      /* Enable the event edge detection */
      COUNTER_CC8_lEvtConfig(handle_ptr->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT0, handle_ptr->event_edge_det_node_id);
    }

    if (handle_ptr->intr_event1_detect != (bool)false)
    {
      /* Enable the event generation for External Event-1 */
      COUNTER_CC8_lEvtConfig(handle_ptr->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT1, handle_ptr->event1_node_id);
    }

    if (handle_ptr->intr_event2_detect != (bool)false)
    {
      /* Enable the event generation for External Event-2 */
      COUNTER_CC8_lEvtConfig(handle_ptr->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT2, handle_ptr->event2_node_id);
    }

    handle_ptr->state = COUNTER_STATUS_SUCCESS;

    /*if counter start after initialization is needed */
    if ((bool) true == handle_ptr->init_start)
    {
      COUNTER_CC8_lStart(handle_ptr);
    }
  }
  return status;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void COUNTER_CC8_lStart(COUNTER_CCU8_CONFIG_t *const handle_ptr)
{
  XMC_ASSERT("COUNTER_CC8_lStart:Invalid handle_ptr", (handle_ptr != NULL))

  if ((COUNTER_STATUS_SUCCESS == handle_ptr->state) &&
      ((bool)false == XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->slice_ptr)))
  {
    /* Enable the clock for the counter slice*/
    XMC_CCU8_EnableClock(handle_ptr->kernel_ptr,handle_ptr->slice_number);

    /* Start the counter operation*/
    XMC_CCU8_SLICE_StartTimer(handle_ptr->slice_ptr);
  }
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void COUNTER_CC8_lStop(COUNTER_CCU8_CONFIG_t *const handle_ptr)
{
  XMC_ASSERT("COUNTER_CC8_lStop:Invalid handle_ptr", (handle_ptr != NULL))

  if ((COUNTER_STATUS_SUCCESS == handle_ptr->state) &&
      ((bool)true == XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->slice_ptr)))
  {
    /* Stop the counter*/
    XMC_CCU8_SLICE_StopTimer(handle_ptr->slice_ptr);

    /* Clear the value in the timer register*/
    XMC_CCU8_SLICE_ClearTimer(handle_ptr->slice_ptr);

    /* Disable the Clock for the counter slice*/
    XMC_CCU8_DisableClock(handle_ptr->kernel_ptr,handle_ptr->slice_number);
  }
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void COUNTER_CC8_lEvtConfig(XMC_CCU8_SLICE_t *const slice_ptr,XMC_CCU8_SLICE_IRQ_ID_t event_id,
                            XMC_CCU8_SLICE_SR_ID_t sr_line)
{
   /* Enable the event generation for event_id */
   XMC_CCU8_SLICE_EnableEvent(slice_ptr,event_id);

   /* Configure the SR line for the event*/
   XMC_CCU8_SLICE_SetInterruptNode(slice_ptr,event_id,sr_line);
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#endif

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
/*This function returns the version of the COUNTER App*/
DAVE_APP_VERSION_t COUNTER_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = (uint8_t) COUNTER_MAJOR_VERSION;
  version.minor = (uint8_t) COUNTER_MINOR_VERSION;
  version.patch = (uint8_t) COUNTER_PATCH_VERSION;

  return version;
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
COUNTER_STATUS_t COUNTER_Init(COUNTER_t *const handle_ptr)
{
  COUNTER_STATUS_t status;
  status = COUNTER_STATUS_FAILURE;
  XMC_ASSERT("COUNTER_Init:Invalid handle_ptr", (handle_ptr != NULL))
#ifdef COUNTER_CCU4_USED
  if (COUNTER_CCU4 == handle_ptr->counter_type)
  {
    status = COUNTER_CCU4_lInit(handle_ptr->ccu4_handle);
  }
#endif
#ifdef COUNTER_CCU8_USED
  if (COUNTER_CCU8 == handle_ptr->counter_type)
  {
    status = COUNTER_CCU8_lInit(handle_ptr->ccu8_handle);
  }
#endif
  return status;
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void COUNTER_Start(COUNTER_t *const handle_ptr)
{
  XMC_ASSERT("COUNTER_Start:Invalid handle_ptr", (handle_ptr != NULL))
#ifdef COUNTER_CCU4_USED
  if (COUNTER_CCU4 == handle_ptr->counter_type)
  {
    COUNTER_CC4_lStart(handle_ptr->ccu4_handle);
  }
#endif
#ifdef COUNTER_CCU8_USED
  if (COUNTER_CCU8 == handle_ptr->counter_type)
  {
    COUNTER_CC8_lStart(handle_ptr->ccu8_handle);
  }
#endif
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void COUNTER_Stop(COUNTER_t *const handle_ptr)
{
  XMC_ASSERT("COUNTER_Stop:Invalid handle_ptr", (handle_ptr != NULL))
#ifdef COUNTER_CCU4_USED
  if (COUNTER_CCU4 == handle_ptr->counter_type)
  {
    COUNTER_CC4_lStop(handle_ptr->ccu4_handle);
  }
#endif
#ifdef COUNTER_CCU8_USED
  if (COUNTER_CCU8 == handle_ptr->counter_type)
  {
    COUNTER_CC8_lStop(handle_ptr->ccu8_handle);
  }
#endif
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
uint16_t COUNTER_GetCurrentCount(COUNTER_t *const handle_ptr)
{
  XMC_ASSERT("COUNTER_GetEventCount:Invalid handle_ptr", (handle_ptr != NULL))

  uint16_t count_value;
  count_value = (uint16_t)0;
#ifdef COUNTER_CCU4_USED
  if (COUNTER_CCU4 == handle_ptr->counter_type)
  {
    count_value = XMC_CCU4_SLICE_GetTimerValue(handle_ptr->ccu4_handle->slice_ptr);
  }
#endif
#ifdef COUNTER_CCU8_USED
  if (COUNTER_CCU8 == handle_ptr->counter_type)
  {
    count_value = XMC_CCU8_SLICE_GetTimerValue(handle_ptr->ccu8_handle->slice_ptr);
  }
#endif
  return (count_value);
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
uint16_t COUNTER_GetCountMatch(COUNTER_t *const handle_ptr)
{
  XMC_ASSERT("COUNTER_GetCountMatch:Invalid handle_ptr", (handle_ptr != NULL))

  uint16_t count_match;
  count_match = (uint16_t)0;
#ifdef COUNTER_CCU4_USED
  if (COUNTER_CCU4 == handle_ptr->counter_type)
  {
    count_match = XMC_CCU4_SLICE_GetTimerCompareMatch(handle_ptr->ccu4_handle->slice_ptr);
  }
#endif
#ifdef COUNTER_CCU8_USED
  if (COUNTER_CCU8 == handle_ptr->counter_type)
  {
    count_match = XMC_CCU8_SLICE_GetTimerCompareMatch(handle_ptr->ccu8_handle->slice_ptr,
                                                       XMC_CCU8_SLICE_COMPARE_CHANNEL_1);
  }
#endif
  return (count_match);
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void COUNTER_SetCountMatch(COUNTER_t *const handle_ptr, uint16_t count_match)
{
  XMC_ASSERT("COUNTER_SetCountMatch:Invalid handle_ptr", (handle_ptr != NULL))

#ifdef COUNTER_CCU4_USED
  if (COUNTER_CCU4 == handle_ptr->counter_type)
  {
    XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_handle->slice_ptr,count_match);

    /*Requesting the shadow transfer for the CCU4 slice  */
    XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_handle->kernel_ptr,
                                  (uint32_t)((uint32_t)XMC_CCU4_SHADOW_TRANSFER_SLICE_0  <<
                                  (uint32_t)((uint32_t)handle_ptr->ccu4_handle->slice_number << (uint32_t)2)));
  }
#endif
#ifdef COUNTER_CCU8_USED
  if (COUNTER_CCU8 == handle_ptr->counter_type)
  {
    XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_handle->slice_ptr,XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                        count_match);

    /*Requesting the shadow transfer for the CCU8 slice  */
    XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_handle->kernel_ptr,
                                  (uint32_t)((uint32_t)XMC_CCU8_SHADOW_TRANSFER_SLICE_0  <<
                                  (uint32_t)((uint32_t)handle_ptr->ccu8_handle->slice_number << (uint32_t)2)));
  }
#endif
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
COUNTER_STATUS_t COUNTER_GetCounterStatus(COUNTER_t *const handle_ptr)
{
  bool status;
  COUNTER_STATUS_t state;
  state = COUNTER_STATUS_IDLE;
  status = (bool)false;
  XMC_ASSERT("COUNTER_GetCounterStatus:Invalid handle_ptr", (handle_ptr != NULL))
#ifdef COUNTER_CCU4_USED
  if (COUNTER_CCU4 == handle_ptr->counter_type)
  {
    status =  XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_handle->slice_ptr);
  }
#endif
#ifdef COUNTER_CCU8_USED
  if (COUNTER_CCU8 == handle_ptr->counter_type)
  {
    status =  XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->ccu8_handle->slice_ptr);
  }
#endif
  if (status != (bool)false)
  {
  	state = COUNTER_STATUS_RUNNING;
  }
  return (state);
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void COUNTER_ClearEvent(COUNTER_t *const handle_ptr,COUNTER_EVENT_t event)
{
  XMC_ASSERT("COUNTER_ClearEvent:Invalid handle_ptr", (handle_ptr != NULL))
#ifdef COUNTER_CCU4_USED
  if (COUNTER_CCU4 == handle_ptr->counter_type)
  {
    if ((COUNTER_EVENT_GATING_LEVEL == event) && (XMC_CCU4_SLICE_EVENT_1 == handle_ptr->ccu4_handle->gating_event))
    {
      event = (COUNTER_EVENT_t) XMC_CCU4_SLICE_IRQ_ID_EVENT1;
    }
    XMC_CCU4_SLICE_ClearEvent(handle_ptr->ccu4_handle->slice_ptr, (XMC_CCU4_SLICE_IRQ_ID_t) event);
  }
#endif
#ifdef COUNTER_CCU8_USED
  if (COUNTER_CCU8 == handle_ptr->counter_type)
  {
    if ((COUNTER_EVENT_GATING_LEVEL == event) && (XMC_CCU8_SLICE_EVENT_1 == handle_ptr->ccu8_handle->gating_event))
    {
      event = (COUNTER_EVENT_t) XMC_CCU8_SLICE_IRQ_ID_EVENT1;
    }
    XMC_CCU8_SLICE_ClearEvent(handle_ptr->ccu8_handle->slice_ptr, (XMC_CCU8_SLICE_IRQ_ID_t) event);
  }
#endif
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
bool COUNTER_GetInterruptStatus(COUNTER_t *const handle_ptr,COUNTER_EVENT_t event)
{
  XMC_ASSERT("COUNTER_GetInterruptStatus:Invalid handle_ptr", (handle_ptr != NULL))

  bool event_status;
  event_status = (bool)false;
#ifdef COUNTER_CCU4_USED
  if (COUNTER_CCU4 == handle_ptr->counter_type)
  {
    if ((COUNTER_EVENT_GATING_LEVEL == event) && (XMC_CCU4_SLICE_EVENT_1 == handle_ptr->ccu4_handle->gating_event))
    {
      event = (COUNTER_EVENT_t) XMC_CCU4_SLICE_IRQ_ID_EVENT1;
    }
    event_status = XMC_CCU4_SLICE_GetEvent(handle_ptr->ccu4_handle->slice_ptr, (XMC_CCU4_SLICE_IRQ_ID_t) event);
  }
#endif
#ifdef COUNTER_CCU8_USED
  if (COUNTER_CCU8 == handle_ptr->counter_type)
  {
    if ((COUNTER_EVENT_GATING_LEVEL == event) && (XMC_CCU8_SLICE_EVENT_1 == handle_ptr->ccu8_handle->gating_event))
    {
      event = (COUNTER_EVENT_t) XMC_CCU8_SLICE_IRQ_ID_EVENT1;
    }
    event_status = XMC_CCU8_SLICE_GetEvent(handle_ptr->ccu8_handle->slice_ptr, (XMC_CCU8_SLICE_IRQ_ID_t) event);
  }
#endif
  return (event_status);
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
void COUNTER_ResetCounter(COUNTER_t *const handle_ptr)
{
  XMC_ASSERT("COUNTER_ResetCounter:Invalid handle_ptr", (handle_ptr != NULL))
#ifdef COUNTER_CCU4_USED
  if (COUNTER_CCU4 == handle_ptr->counter_type)
  {
    XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_handle->slice_ptr);
  }
#endif
#ifdef COUNTER_CCU8_USED
  if (COUNTER_CCU8 == handle_ptr->counter_type)
  {
    XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_handle->slice_ptr);
  }
#endif
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
