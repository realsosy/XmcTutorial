/**
 * @file dac.h
 * @date 2016-07-08
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 * @cond
 ***********************************************************************************************************************
 * DAC v4.0.16 - Generates Pattern, Noise and Ramp waveform. It can be used for single value and data processing modes.
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version
 *
 * 2015-06-20:
 *     - APP version updated for changes in dac.c file <br>
 *
 * 2015-12-15:
 *     - ANALOG_IO APP Init function call added
 * 2016-07-08:
 *     - Fixed incorrect case for an included header.<br>
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#ifndef DAC_H_
#define DAC_H_

#include <xmc_dac.h>
#include <xmc_scu.h>
#include <DAVE_Common.h>
#include "dac_conf.h"
#if (DAC_ANALOG_IO_USED == 1U)
#include "../ANALOG_IO/analog_io.h"
#endif
#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "DAC requires XMC Peripheral Library v2.0.0 or higher"
#endif
/**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
/**
 * @ingroup DAC_constants
 * @{
 */
#define  DAC_OUT_MIN_MV            (300U)        /**< DAC Minimum output voltage in mV */
#define  DAC_OUT_MAX_MV            (2500U)       /**< DAC Maximum output voltage in mV*/
#define  DAC_OFFSET_SIGN_mV        (1400U)       /**< Output offset in Volt when signed values used*/
#define  DAC_PATTERN_AMPLITUDE     (62)          /**< Non scaled maximum output of Pattern Amplitude in uint*/
#define  DAC_VSS_MAX               (DAC_OUT_MAX_MV - DAC_OUT_MIN_MV)
#define  DAC_REGISTER_MAX_SIGN     (2048U)      /**< Maximum positive 12 Bit value in signed mode*/
#define  DAC_OFFSET_MAX_SIGN       (127)        /**< Maximum offset possible in Pattern Mode */
#define  DAC_OFFSET_MIN_SIGN       (-128)       /**< Minimum offset possible in Pattern Mode */
#define  DAC_DATA_VALUE_MAX_USIGN  (4095U)      /**< Maximum Configurable Data Value */
#define  DAC_DATA_VALUE_MAX_SIGN   (2047)       /**< Maximum Configurable Data Value in Signed Mode*/
#define  DAC_DATA_VALUE_MIN_SIGN   (-2048)      /**< Minimum Configurable Data Value in Signed Mode*/
#define  DAC_MAX_FREQUENCY         (2000000U)   /**< Maximum Configurable DAC Frequency */
#define  DAC_RAMP_MIN_STEPS        (3U)         /**< Minimum Configurable Ramp Steps */
#define  DAC_RAMP_MAX_STEPS        (4095U)      /**< Maximum Configurable Ramp Steps */
#define  DAC_MIN_CLK_DIV           (16U)        /**< Minimum Clock divider */
#define  DAC_MAX_CLK_DIV           (1048575U)   /**< Maximum Clock divider */
#define  DAC_MAX_SCALE_SHIFT       (7U)         /**< Maximum possible scaling up or down */
#define  DAC_VSS_34_MV             (34U)        /**< DAC 34 milli volts */


/**
 * @}
 */
/**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
  /**
   * @ingroup DAC_enumerations
   * @{
   */
/**
 * DAC Status
 */
typedef enum DAC_STATUS
{
  DAC_STATUS_SUCCESS = 0,          /**< DAC Initialization successful */
  DAC_STATUS_FAILURE,              /**< DAC Initialization failed */
  DAC_STATUS_API_FAIL              /**< DAC API Call returned ERROR */
} DAC_STATUS_t;

/**
 *  @brief Available DAC output ranges named in Milli Volt
 */
typedef enum DAC_VSS
{
   DAC_VSS_0001_mV = 0,            /**< DAC output 1 milli volts */
   DAC_VSS_0002_mV,                /**< DAC output 2 milli volts */
   DAC_VSS_0004_mV,                /**< DAC output 4 milli volts */
   DAC_VSS_0009_mV,                /**< DAC output 9 milli volts */
   DAC_VSS_0017_mV,                /**< DAC output 17 milli volts */
   DAC_VSS_0034_mV,                /**< DAC output 34 milli volts */
   DAC_VSS_0069_mV,                /**< DAC output 69 milli volts */
   DAC_VSS_0138_mV,                /**< DAC output 138 milli volts */
   DAC_VSS_0275_mV,                /**< DAC output 275 milli volts */
   DAC_VSS_0550_mV,                /**< DAC output 550 milli volts */
   DAC_VSS_1100_mV,                /**< DAC output 1100 milli volts */
   DAC_VSS_2200_mV,                /**< DAC output 2200 milli volts */
}  DAC_VSS_t;

  /**
   * @}
   */
/**********************************************************************************************************************
 * DATA STRUCTURES
 **********************************************************************************************************************/
  /**
   * @ingroup DAC_datastructures
   * @{
   */

  /**
   * This structure holds the DAC parameters of user configured
   * waveform generator.
   */
typedef struct DAC_t
{
  /* This structure contains the user configuration */
  XMC_DAC_t  * const                  dac_module_ptr;          /**< DAC Module Pointer */
  const XMC_DAC_CH_CONFIG_t *         dac_config_ptr;          /**< DAC Channel Configuration Data */
#if (DAC_ANALOG_IO_USED == 1U)
  const ANALOG_IO_t            *const analog_io_config_ptr;   /**< This hold the address of the ANALOG_IO configuration structure*/
#endif
  XMC_DAC_CH_MODE_t                   dac_mode;                /**< DAC Mode Configuration */
  XMC_DAC_CH_TRIGGER_t                dac_input_trigger;       /**< DAC Input Trigger */
  XMC_DAC_CH_PATTERN_SIGN_OUTPUT_t    dac_sign_output;         /**< DAC Sign Output */
  uint32_t                            dac_frequency;           /**< DAC Frequency */
  uint16_t                            dac_ramp_start;          /**< DAC Ramp Start */
  uint16_t                            dac_ramp_stop;           /**< DAC Ramp Stop */
  uint16_t                            dac_ramp_start_mv;       /**< DAC Ramp Start in milli volts */
  uint16_t                            dac_ramp_stop_mv;        /**< DAC Ramp Stop in milli volts */
  uint8_t                             dac_service_request;     /**< Service request Enabled/Disabled */
  uint8_t                             dac_coupled;             /**< DAC Coupled Mode Enabled/Disabled */
  uint8_t                             dac_ch;                  /**< DAC CH Number */
  const uint8_t  *const               dac_pat_table_ptr;       /**< Pointer to Pattern generation table */
  uint8_t                             dac_start_after_init;    /**< Waveform generation starts after initialization */

} DAC_t;
  /**
   * @}
   */
#ifdef __cplusplus
extern "C"
{
#endif
/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
  /**
   * @ingroup DAC_apidoc
   * @{
   */
/**
 * @brief Returns APP version information
 * @param None
 * @return DAVE_APP_VERSION_t Returns APP version number(major, minor and patch number).
 * <BR>
 *
 * \par<b>Description</b><br>
 * Each of the DAVE APP exports a version number(major, minor and patch number).
 * Applications may then audit such a version number to determine compatibility.
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
  DAVE_STATUS_t status;
  DAVE_APP_VERSION_t version;
  status = DAVE_Init();		//DAC_Init(&DAC_0) will be called internally
  version = DAC_GetAppVersion();
  if (version.major != 1U)
  {
    // Probably, not the right version.
  }
  while(1);
  return 0;
 }
 * @endcode
 */
DAVE_APP_VERSION_t DAC_GetAppVersion(void);

/**
 * @brief Initializes DAC peripheral as per GUI configurations.
 * @param HandlePtr DAC App instance Handler pointing to user configuration.
 * @return DAC_STATUS_t Returns failure if low level driver API call fails.
 * <BR>
 *
 * \par<b>Description</b><br>
 * Initializes DAC peripheral as per user configuration.
 * Configures DAC operating mode,waveform frequency and channel related configuration.
 *
 * \par<b>Note</b><br>
 * This API is called internally by DAVE_Init() function. Should not be called explicitly.
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
  DAVE_STATUS_t status;
  status = DAVE_Init();		// DAC_Init(&DAC_0) will be called internally
  while(1);
  return 0;
 }
 * @endcode
 */
DAC_STATUS_t DAC_Init(const DAC_t * const HandlePtr);

/**
 * @brief Enables DAC channel analog module.
 * @param HandlePtr DAC App instance Handler pointing to user configuration.
 * @return void
 * <BR>
 *
 * \par<b>Description</b><br>
 * Enables configured DAC channel analog part only.To start the waveform generation one has to start digital part also.
 * For example in pattern mode waveform starts whenever the digital part is turned ON after analog part is enabled.
 * DAC_Enable() API will start the digital part. So in pattern generation wave starts every time with first wave point.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_Enable()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   status = DAVE_Init();	    // DAC_Init(&DAC_0) will be called internally
   DAC_EnableCHOutput(&DAC_0); //Enable Channel output
   while(1);
   return 0;
 }
 * @endcode
 *
 */
__STATIC_INLINE void DAC_EnableCHOutput(const DAC_t * const HandlePtr)
{
    XMC_DAC_CH_EnableOutput(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
}

/**
 * @brief Disables channel output by disabling analog module.
 * @param HandlePtr DAC App instance Handler pointing to user configuration.
 * @return void
 * <BR>
 *
 * \par<b>Description</b><br>
 * Disables analog part of the selected DAC channel.Waveform generation will be stopped.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_EnableCHOutput()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   DAC_DisableCHOutput(&DAC_0);   //Disable Channel output
   while(1);
   return 0;
 }
 * @endcode
 */
__STATIC_INLINE void DAC_DisableCHOutput(const DAC_t * const HandlePtr)
{
    XMC_DAC_CH_DisableOutput(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
}

/**
 * @brief Enables DAC channel output.
 * @param HandlePtr DAC App instance Handler pointing to user configuration.
 * @return void
 * <BR>
 *
 * \par<b>Description</b><br>
 * Enables the DAC channel output. Switch mode from Idle to configured mode.Starts the digital part of
 * configured DAC channel.If start after initialization option is disabled then one has to call this API explicitly.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_Disable()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   DAC_Disable(&DAC_0);          // disable DAC output
   //do something..
   DAC_Enable(&DAC_0);           //Set the mode back to the former type.
   while(1);
   return 0;
 }
 * @endcode
 */
__STATIC_INLINE void DAC_Enable(const DAC_t * const HandlePtr)
{
    XMC_DAC_CH_SetMode(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, HandlePtr->dac_mode);
}

/**
 * @brief Disables DAC channel output.
 * @param HandlePtr DAC App instance Handler pointing to user configuration.
 * @return void
 * <BR>
 *
 * \par<b>Description</b><br>
 * Disables DAC channel output.Configures to Idle mode.It will disable the corresponding DAC channel digital part.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_Enable()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   DAC_Disable(&DAC_0);            //Change Mode to Idle Mode
   while(1);
   return 0;
 }
 * @endcode
 */
__STATIC_INLINE void DAC_Disable(const DAC_t * const HandlePtr)
{
    XMC_DAC_CH_SetMode(HandlePtr->dac_module_ptr, HandlePtr->dac_ch, XMC_DAC_CH_MODE_IDLE);
}

/**
 * @brief Configures amplitude in pattern mode.
 * @param HandlePtr DAC App instance Handler pointing to user configuration.
 * @param Amplitude Waveform amplitude of type of @ref DAC_VSS_t
 * @return void
 * <BR>
 *
 * \par<b>Description</b><br>
 * Configures the \a Amplitude for corresponding DAC channel in Pattern mode.
 *
 * \par<b>Note</b><br>
 * This API should be called only when DAC is configured for pattern generation mode.
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   DAC_Pattern_SetAmplitude(&DAC_0,DAC_VSS_1100_mV);   //Set Amplitude
   while(1);
   return 0;
 }
 * @endcode
 */
void DAC_Pattern_SetAmplitude(const DAC_t * const HandlePtr,DAC_VSS_t Amplitude);

/**
 * @brief Configures waveform frequency in pattern mode.
 * @param HandlePtr DAC App instance Handler pointing to user configuration.
 * @param Frequency Required frequency
 * @return DAC_STATUS_t Returns failure when frequency is not configurable.
 * <BR>
 *
 * \par<b>Description</b><br>
 * Configures the waveform frequency in pattern mode.
 *
 * \par<b>Note</b><br>
 * This API should be called only when DAC is configured for pattern generation mode.
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   DAC_STATUS_t dac_status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   dac_status = DAC_Pattern_SetFrequency(&DAC_0,2000);   //Set Pattern Frequency to 2000Hz
   while(1);
   return 0;
 }
 * @endcode
 */
__STATIC_INLINE DAC_STATUS_t DAC_Pattern_SetFrequency(const DAC_t * const HandlePtr, const uint32_t Frequency)
{
    return ((DAC_STATUS_t)XMC_DAC_CH_SetPatternFrequency(HandlePtr->dac_module_ptr,HandlePtr->dac_ch, Frequency));
}

/**
 * @brief Configures offset in pattern mode.
 * @param HandlePtr DAC App instance Handler pointing to user configuration.
 * @param Dc_offset_mv Required offset in milli volts
 * @return DAC_STATUS_t Returns failure when offset is not configurable.
 * <BR>
 *
 * \par<b>Description</b><br>
 * Configures Offset in Pattern mode.
 *
 * \par<b>Note</b><br>
 * This API should be called only when DAC is configured for pattern generation mode.
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   DAC_STATUS_t dac_status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   dac_status = DAC_Pattern_SetOffset(&DAC_0,1400);   //Set Pattern offset to 1.4V
   while(1);
   return 0;
 }
 * @endcode
 */
DAC_STATUS_t DAC_Pattern_SetOffset(const DAC_t * const HandlePtr,int16_t Dc_offset_mv);

/**
 * @brief Enables sign output in pattern mode.
 * @param HandlePtr DAC App instance Handler
 * @return void
 * <BR>
 *
 * \par<b>Description</b><br>
 * Enables Sign output in pattern mode.
 *
 * \par<b>Note</b><br>
 * This API should be called only when DAC is configured for pattern generation mode.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_Pattern_DisableSignOut()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   DAC_Pattern_EnableSignOut(&DAC_0);   //Enable Sign Output
   while(1);
   return 0;
 }
 * @endcode
 */
__STATIC_INLINE void DAC_Pattern_EnableSignOut(const DAC_t * const HandlePtr)
{
    XMC_DAC_CH_EnablePatternSignOutput(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
}

/**
 * @brief Disables sign output in pattern mode.
 * @param HandlePtr DAC App instance Handler
 * @return void
 * <BR>
 *
 * \par<b>Description</b><br>
 * Disables Sign output in pattern mode.
 *
 * \par<b>Note</b><br>
 * This API should be called only when DAC is configured for pattern generation mode.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_Pattern_EnableSignOut()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   DAC_Pattern_DisableSignOut(&DAC_0);   //Disable Sign Output
   while(1);
   return 0;
 }
 * @endcode
 */
__STATIC_INLINE void DAC_Pattern_DisableSignOut(const DAC_t * const HandlePtr)
{
    XMC_DAC_CH_DisablePatternSignOutput(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
}

/**
 * @brief Configures pattern data pointer in pattern mode.
 * @param HandlePtr DAC App instance Handler
 * @param PatternPtr Pointer to Pattern data
 * @return void
 * <BR>
 *
 * \par<b>Description</b><br>
 * Update the pattern for the waveform generation.
 *
 * \par<b>Note</b><br>
 * This API should be called only when DAC is configured for pattern generation mode.
 *
 * Example Usage:
 * @code
 #define XMC_DAC_PATTERN_CUSTOM {0U, 1U, 12U, 15U, 23U, 2U, 4U, 10U, 3U}
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   const uint8_t pattern[]=XMC_DAC_PATTERN_CUSTOM;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   DAC_Pattern_ChangePattern(&DAC_0,&pattern[0]);   //Update the Pattern
   while(1);
   return 0;
 }
 * @endcode
 */
__STATIC_INLINE void DAC_Pattern_ChangePattern(const DAC_t * const HandlePtr,const uint8_t *const PatternPtr)
{
    XMC_DAC_CH_SetPattern(HandlePtr->dac_module_ptr,HandlePtr->dac_ch,PatternPtr);
}

/**
 * @brief Configures unsigned data in single value mode.
 * @param HandlePtr DAC App instance Handler
 * @param Data DAC CH Data
 * @return DAC_STATUS_t Returns failure when \a Data is greater than 4095.
 * <BR>
 *
 * \par<b>Description</b><br>
 * Writes unsigned data on DAC1/DAC0 register depends upon configured channel.
 *
 * \par<b>Note</b><br>
 * API should be called only when DAC is configured for single value in non coupled mode.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_SingleValue_SetValue_u16_Coupled(),DAC_SingleValue_SetValue_s16(),DAC_SingleValue_SetValue_s16_Coupled()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   DAC_STATUS_t dac_status;
   uint16_t Data = 700;

   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   dac_status = DAC_SingleValue_SetValue_u16(&DAC_0,Data);
   while(1);
   return 0;
 }
 * @endcode
 */
DAC_STATUS_t DAC_SingleValue_SetValue_u16(const DAC_t * const HandlePtr,uint16_t Data);

/**
 * @brief Configures unsigned data in simultaneous data mode.
 * @param HandlePtr DAC App instance Handler
 * @param Data0 DAC CH0 Data in Coupled Mode
 * @param Data1 DAC CH1 Data in Coupled Mode
 * @return DAC_STATUS_t Returns failure when \a Data0 or \a Data1 is greater than 4095.
 * <BR>
 *
 * \par<b>Description</b><br>
 * Writes unsigned data on DAC01 data register.
 *
 * \par<b>Note</b><br>
 * This API should be called only when DAC is configured for single value in coupled mode.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_SingleValue_SetValue_u16(),DAC_SingleValue_SetValue_s16(),DAC_SingleValue_SetValue_s16_Coupled()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   DAC_STATUS_t dac_status;
   uint16_t Data0 = 700;
   uint16_t Data1 = 900;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   dac_status = DAC_SingleValue_SetValue_u16_Coupled(&DAC_0,Data0,Data1);
   while(1);
   return 0;
 }
 * @endcode
 */
DAC_STATUS_t DAC_SingleValue_SetValue_u16_Coupled(const DAC_t * const HandlePtr,uint16_t Data0, uint16_t Data1);

/**
 * @brief Configures signed data in single value mode.
 * @param HandlePtr DAC App instance Handler
 * @param Data DAC CH Data
 * @return DAC_STATUS_t Returns failure when \a Data is out of range. [-2048..2047]
 * <BR>
 *
 * \par<b>Description</b><br>
 * Writes signed data on DAC1/DAC0 data register depends upon CH selected.
 *
 * \par<b>Note</b><br>
 * This API should be called only when DAC is configured for single value in non coupled mode.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_SingleValue_SetValue_u16_Coupled(),DAC_SingleValue_SetValue_u16(),DAC_SingleValue_SetValue_s16_Coupled()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   int16_t Data = -980;
   DAC_STATUS_t dac_status;
   DAVE_STATUS_t status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   dac_status = DAC_SingleValue_SetValue_s16(&DAC_0,Data);
   while(1);
   return 0;
 }
 * @endcode
 */
DAC_STATUS_t DAC_SingleValue_SetValue_s16(const DAC_t * const HandlePtr,int16_t Data);

/**
 * @brief Configures signed data in simultaneous data mode.
 * @param HandlePtr DAC App instance Handler
 * @param Data0 DAC CH0 Data
 * @param Data1 DAC CH1 Data
 * @return DAC_STATUS_t Returns failure when \a Data0 \a Data1 is out of range. [-2048..2047]
 * <BR>
 *
 * \par<b>Description</b><br>
 * Writes signed data for both the channel on DAC01 data register.
 *
 * \par<b>Note</b><br>
 * This API should be called only when DAC is configured for single value in coupled mode.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_SingleValue_SetValue_u16_Coupled(),DAC_SingleValue_SetValue_s16(),DAC_SingleValue_SetValue_u16()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   int16_t Data0 = -980;
   int16_t Data1 = 400;
   DAC_STATUS_t dac_status;
   DAVE_STATUS_t status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   dac_status = DAC_SingleValue_SetValue_s16_Coupled(&DAC_0,Data0,Data1);
   while(1);
   return 0;
 }
 * @endcode
 */
DAC_STATUS_t DAC_SingleValue_SetValue_s16_Coupled(const DAC_t * const HandlePtr,int16_t Data0, int16_t Data1);

/**
 * @brief Enables offset in Noise mode.
 * @param HandlePtr DAC App instance Handler
 * @return void
 * <BR>
 *
 * \par<b>Description</b><br>
 * Enables 1.4V offset in noise mode.
 *
 * \par<b>Note</b><br>
 * API should be called only when DAC is configured for Noise mode.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_Noise_DisableOffset()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   DAC_Noise_EnableOffset(&DAC_0);   //Enable offset in Noise Mode
   while(1);
   return 0;
 }
 * @endcode
 */
__STATIC_INLINE void DAC_Noise_EnableOffset(const DAC_t * const HandlePtr)
{
    XMC_DAC_CH_SetSignedDataType(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
}

/**
 * @brief Disables offset in Noise mode.
 * @param HandlePtr DAC App instance Handler
 * @return void
 * <BR>
 *
 * \par<b>Description</b><br>
 * Disables 1.4V offset in noise mode.
 *
 * \par<b>Note</b><br>
 * API should be called only when DAC is configured for Noise mode.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_Noise_EnableOffset()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   DAC_Noise_DisableOffset(&DAC_0);   //Disable offset in Noise Mode
   while(1);
   return 0;
 }
 * @endcode
 */
__STATIC_INLINE void DAC_Noise_DisableOffset(const DAC_t * const HandlePtr)
{
    XMC_DAC_CH_SetUnsignedDataType(HandlePtr->dac_module_ptr,HandlePtr->dac_ch);
}

/**
 * @brief Configures an amplitude in Noise Mode.
 * @param HandlePtr DAC App instance Handler
 * @param Amplitude of type DAC_VSS_t
 * @return DAC_STATUS_t Returns failure if amplitude is out of range.
 * <BR>
 *
 * \par<b>Description</b><br>
 * Configures an \a Amplitude in Noise Mode.
 *
 * \par<b>Note</b><br>
 * API should be called only when DAC is configured for Noise mode.
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   DAC_STATUS_t dac_status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   dac_status = DAC_Noise_SetAmplitude(&DAC_0,DAC_VSS_1100_mV);   //Set Amplitude to 1.1V
   while(1);
   return 0;
 }
 * @endcode
 */
DAC_STATUS_t DAC_Noise_SetAmplitude(const DAC_t * const HandlePtr,DAC_VSS_t Amplitude);

/**
 * @brief Configures ramp start voltage in Ramp mode.
 * @param HandlePtr DAC App instance Handler
 * @param Ramp_start_mv Ramp start in milli volts
 * @return DAC_STATUS_t Returns success when \a Ramp_start_mv is in range [300...2500]mV
 * <BR>
 *
 * \par<b>Description</b><br>
 * Configures ramp start voltage in Ramp mode.When ramp reached to ramp stop then waveform will restart from ramp start.
 *
 * \par<b>Note</b><br>
 * API should be called only when DAC is configured for Ramp mode.After configuring ramp start it is necessary to
 * call DAC_Ramp_SetFrequency()to generate required frequency.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_Ramp_SetStop(),DAC_Ramp_SetFrequency()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   DAC_STATUS_t dac_status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   dac_status = DAC_Ramp_SetStart(&DAC_0,400);   //Set ramp start to 0.4V
   while(1);
   return 0;
 }
 * @endcode
 */
DAC_STATUS_t DAC_Ramp_SetStart(DAC_t * const HandlePtr,uint16_t Ramp_start_mv);

/**
 * @brief Configures ramp stop voltage in Ramp mode.
 * @param HandlePtr DAC App instance Handler
 * @param Ramp_stop_mv Ramp stop in milli volts
 * @return DAC_STATUS_t Returns success when \a Ramp_stop_mv is in range [300...2500]mV
 * <BR>
 *
 * \par<b>Description</b><br>
 * Configures ramp stop voltage in Ramp mode.When ramp reached to ramp stop then waveform will restart from ramp start.
 * After configuring ramp start it is necessary to call DAC_Ramp_SetFrequency() to generate required frequency.
 *
 * \par<b>Note</b><br>
 * API should be called only when DAC is configured for Ramp mode.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_Ramp_SetStart(),DAC_Ramp_SetFrequency()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   DAC_STATUS_t dac_status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   dac_status = DAC_Ramp_SetStop(&DAC_0,1100);   //Set ramp stop to 1.1V
   while(1);
   return DAC_STATUS;
 }
 * @endcode
 */
DAC_STATUS_t DAC_Ramp_SetStop(DAC_t * const HandlePtr,uint16_t Ramp_stop_mv);

/**
 * @brief Configures ramp frequency in Ramp mode.
 * @param HandlePtr DAC App instance Handler
 * @param Frequency_Hz Required frequency
 * @return DAC_STATUS_t
 * <BR>
 *
 * \par<b>Description</b><br>
 * Configures ramp frequency in Ramp mode.Ramp frequency and ramp steps are tightly coupled.
 * If frequency directly can't be configured then it will try to scale up/down to adjust the number of steps
 * to generate required frequency.
 *
 * \par<b>Note</b><br>
 * API should be called only when DAC is configured for Ramp mode.
 *
 * \par<b>Related APIs:</b><BR>
 * DAC_Ramp_SetStart(),DAC_Ramp_SetStop()
 *
 * Example Usage:
 * @code
 #include <DAVE.h>
 int main (void)
 {
   DAVE_STATUS_t status;
   DAC_STATUS_t dac_status;
   status = DAVE_Init();		  // DAC_Init(&DAC_0) will be called internally
   dac_status = DAC_Ramp_SetFrequency(&DAC_0,2000);  //Set ramp frequency to 2000 Hz.
   while(1);
   return 0;
 }
 * @endcode
 */
DAC_STATUS_t DAC_Ramp_SetFrequency(const DAC_t * const HandlePtr,uint32_t Frequency_Hz);

/**
 * @}
 */

#include "dac_extern.h"


#ifdef __cplusplus
}
#endif

#endif /* DAC_H_ */
