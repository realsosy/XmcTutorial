/**
 * @file spi_slave.h
 * @date 2015-12-17
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * SPI_SLAVE v4.0.8 - Configures a USIC channel to implement SPI slave functionality.
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-08-06:
 *     - Initial version for DAVEv4
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#ifndef SPI_SLAVE_H_
#define SPI_SLAVE_H_

#include <xmc_scu.h>
#include <xmc_gpio.h>
#include <xmc_spi.h>

#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "SPI_SLAVE requires XMC Peripheral Library v2.0.0 or higher"
#endif

#include <DAVE_common.h>
#include "spi_slave_conf.h"
#if ((defined SPI_SLAVE_TX_DMA_USED) || (defined SPI_SLAVE_RX_DMA_USED))
#include "../GLOBAL_DMA/global_dma.h"
#endif

/**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
/*
 * @brief Represents the maximum data size for DMA transaction*/
#define SPI_SLAVE_DMA_MAXCOUNT (4095U)

/**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
/**
 * @ingroup SPI_SLAVE_enumerations
 * @{
 */

/**
 * @brief Enum to describe the possible status values, returned
 *  by SPI_SLAVE APIs.
 */
typedef enum SPI_SLAVE_STATUS
{
  SPI_SLAVE_STATUS_SUCCESS,        /**< Indicates APP initialization state successful */

  SPI_SLAVE_STATUS_FAILURE,        /**< Unknown error */

  SPI_SLAVE_STATUS_BUSY,           /**< SPI_SLAVE Busy */

  SPI_SLAVE_STATUS_BUFFER_INVALID, /**< Buffer provided or the buffer size is invalid*/

  SPI_SLAVE_STATUS_MODE_MISMATCH   /**< API invoked by a handle configured with different mode.
									   e.g, If SPI_SLAVE_StartTransmitDMA is invoked for an instance
									   which has transmit mode configured as "Interrupt", will
									   return this status.*/

} SPI_SLAVE_STATUS_t;


/**
 * @brief Enum used to identify the transfer type used for either transmit or receive function.
 */
typedef enum SPI_SLAVE_TRANSFER_MODE
{
  SPI_SLAVE_TRANSFER_MODE_INTERRUPT,  /**< Implement data transmit or receive using interrupts */
  SPI_SLAVE_TRANSFER_MODE_DMA,        /**< Implement data transmit or receive using DMA */
  SPI_SLAVE_TRANSFER_MODE_DIRECT      /**< This configuration exposes signals for external APP connection */
}SPI_SLAVE_TRANSFER_MODE_t;

/**
 * @brief Enum used to identify the size of each word. This only identifies the adressing size but not the actual
 * word length of the channel. Useful for processing user buffer.
 */
typedef enum SPI_SLAVE_DATA_SIZE
{
  SPI_SLAVE_DATA_SIZE_8BITS = 1U,  /**< User buffer will be accessed one byte as one word*/
  SPI_SLAVE_DATA_SIZE_16BITS = 2U   /**< One word will be considered as 16bits, hence 2bytes(16bits) will be considered from
                                        user buffer for each transaction(transmit/receive).*/
}SPI_SLAVE_DATA_SIZE_t;
/**
 * @brief Enum to represent USIC input stage(DXn) multiplexer(DXnCR_DSEL) value.
 */
typedef enum SPI_SLAVE_INPUT
{
  SPI_SLAVE_INPUT_A = 0U, /**< Input-A (DXnA) */
  SPI_SLAVE_INPUT_B,      /**< Input-B (DXnB)*/
  SPI_SLAVE_INPUT_C,      /**< Input-C (DXnC)*/
  SPI_SLAVE_INPUT_D,      /**< Input-D (DXnD)*/
  SPI_SLAVE_INPUT_E,      /**< Input-E (DXnE)*/
  SPI_SLAVE_INPUT_F,      /**< Input-F (DXnF)*/
  SPI_SLAVE_INPUT_G,      /**< Input-G (DXnG)*/
  SPI_SLAVE_INPUT_INVALID /**< Indicates that the input multiplexer value is invalid. Used while switching operation mode. */
} SPI_SLAVE_INPUT_t;

/**
 * @}
 */

/**
 * @brief Function pointer used for callback function
 */
typedef void (*SPI_SLAVE_cbhandler)(void);
/**
 * @brief Function pointer used for USIC channel initialization function
 */
typedef SPI_SLAVE_STATUS_t (*SPI_SLAVE_init_handler)(void);

/**
 * @ingroup SPI_SLAVE_datastructures
 * @{
 */

/**
 * @brief Structure for transmit pin configuration.
 */
typedef struct SPI_SLAVE_PIN_CONFIG
{
  XMC_GPIO_PORT_t *const port;            /**< Pointer to the GPIO port base address */
  const XMC_GPIO_CONFIG_t *const config;  /**< Pin configuration structure */
  const XMC_GPIO_HWCTRL_t hw_control;     /**< Hardware control characteristics of the pin */
  const uint8_t pin;                      /**< Pin number in the port*/
} SPI_SLAVE_PIN_CONFIG_t;

#if (defined(SPI_SLAVE_TX_DMA_USED) || defined(SPI_SLAVE_RX_DMA_USED))
/**
 * @brief Structure for DMA configuration.
 */
typedef struct SPI_SLAVE_DMA_CONFIG
{
  const XMC_DMA_CH_CONFIG_t * dma_ch_config;   /**< Pointer to the DMA channel configuration.*/
  uint8_t dma_channel;                         /**< DMA channel number */
}SPI_SLAVE_DMA_CONFIG_t;
#endif

/**
 * @brief Structure for holding the configuration parameters of SPI_SLAVE channel.
 */
typedef struct SPI_SLAVE_CONFIG
{
  const XMC_SPI_CH_CONFIG_t * const channel_config;   		/**< SPI channel configuration with GUI configured values for baud, data bits,
                                                            	 frame length and parity */
#if (defined SPI_SLAVE_TX_DMA_USED) || (defined SPI_SLAVE_RX_DMA_USED)
  GLOBAL_DMA_t * global_dma;                           		/**< Global DMA handle */
#endif
#ifdef SPI_SLAVE_TX_DMA_USED
  const SPI_SLAVE_DMA_CONFIG_t * const transmit_dma_config; /**< Pointer to the DMA channel configuration used for data transmission.*/
#endif
#ifdef SPI_SLAVE_RX_DMA_USED
  const SPI_SLAVE_DMA_CONFIG_t * const receive_dma_config;  /**< Pointer to the DMA channel configuration used for data reception.*/
#endif
  const SPI_SLAVE_PIN_CONFIG_t * mosi1_pin_config;          /**< Pin configuration of MISO/MOSI_1 pin, to be used during initialization
                                                                and while changing operation mode. */
  const SPI_SLAVE_PIN_CONFIG_t * mosi0_pin_config;         /**< Pin configuration of MOSI pin, to be used during initialization
                                                                and while changing operation mode. */
  SPI_SLAVE_init_handler fptr_spi_slave_config;             /**< Function pointer to configure the MUX values */
#if (defined SPI_SLAVE_TX_INTERRUPT_USED || defined SPI_SLAVE_TX_DMA_USED)
  SPI_SLAVE_cbhandler tx_cbhandler;                         /**< Function pointer to hold the callback function pointer,
                                                               called when the transmission is complete */
#endif
#if (defined SPI_SLAVE_RX_INTERRUPT_USED || defined SPI_SLAVE_RX_DMA_USED)
  SPI_SLAVE_cbhandler rx_cbhandler;                         /**< Function pointer to hold the callback function pointer,
                                                                 called when the reception is complete */
#endif
  SPI_SLAVE_cbhandler parity_error_cbhandler;               /**< Function pointer to hold the callback function pointer,
                                                            	 called when parity error is detected.*/
  SPI_SLAVE_cbhandler slave_select_cbhandler;          		/**< Function pointer to hold the callback function pointer,
                                                               called when slave select event is detected*/
  SPI_SLAVE_TRANSFER_MODE_t transmit_mode;                /**< Mode used for transmitting data. Data can be transmitted using
                                                               interrupt, DMA or direct(using polling or external APP connection.)*/
  SPI_SLAVE_TRANSFER_MODE_t receive_mode;              		/**< Mode used for receiving data. Data can be received using
                                                            	 interrupt, DMA or direct(using polling or external APP connection.)*/
  XMC_USIC_CH_FIFO_SIZE_t tx_fifo_size;                		/**< Transmit FIFO size configuration */
  XMC_USIC_CH_FIFO_SIZE_t rx_fifo_size;                		/**< Receive FIFO size configuration */
  XMC_SPI_CH_MODE_t spi_configured_mode;                  /**< SPI mode configured in the APP UI.*/
  uint8_t tx_sr;                                       		/**< Service request number assigned to transmit interrupt */
  SPI_SLAVE_INPUT_t dx0_source;                             /**< Data input multiplexer selection. DX0 DSEL value for input channel selection.
                                                               Used while switching between quad mode, half duplex and full duplex modes.*/
  uint8_t tx_dlr_line;                                      /**< DMA line router chosen line for data transmission*/
} SPI_SLAVE_CONFIG_t;

/**
 * @brief Structure to hold the dynamic variables for the SPI_SLAVE communication.
 */
typedef struct SPI_SLAVE_RUNTIME
{
  uint8_t * tx_data;            /**< Pointer to the transmit data buffer*/
  uint8_t * rx_data;            /**< Pointer to the receive data buffer*/
  uint32_t tx_data_count;       /**< Number of bytes of data to be transmitted*/
  uint32_t tx_data_index;       /**< Index to the byte to be transmitted next in the tx_data buffer*/
  uint32_t rx_data_count;       /**< Number of bytes of data to be received*/
  uint32_t rx_data_index;       /**< Indicates the number of bytes currently available in the rx_data buffer*/
  XMC_SPI_CH_MODE_t spi_current_mode;  /**< Defines the SPI transmit mode being used */
  SPI_SLAVE_DATA_SIZE_t data_size;     /**< Indicates the number of bytes to be used to represent one word of data. For values of word length
                                       less than or equal to 8, the size will indicate 1 byte. For rest of the values of word length, the size
                                       will be 2 bytes. This means that if word length is 10bits, each buffer access for transmission or reception
                                       will be done using 16bit access.*/
  volatile bool tx_busy;        /**< Status flag to indicate busy if transmission is in progress*/
  volatile bool rx_busy;        /**< Status flag to indicate busy if reception is in progress*/
} SPI_SLAVE_RUNTIME_t;

/**
 * @brief Handler structure with pointers to dynamic and static parameters.
 */
typedef struct SPI_SLAVE
{
  XMC_USIC_CH_t * const channel;              /**< USIC channel*/
  const SPI_SLAVE_CONFIG_t * const config;    /**< SPI_SLAVE configuration structure pointer*/
  SPI_SLAVE_RUNTIME_t * const runtime;        /**< Pointer to the structure holding all variables,
                                                   that can change at runtime*/
} SPI_SLAVE_t;

/**
 * @}
 */

/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif
/**
 * @ingroup SPI_SLAVE_apidoc
 * @{
 */
/**
 * @brief Get the SPI_SLAVE APP version.
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 * //Example below, transmits data to master only if the version of the SPI_SLAVE APP is v4.0.x
 * //Value of x can be anything.
 * int main(void)
 * {
 *   SPI_SLAVE_STATUS_t init_status;
 *   DAVE_APP_VERSION_t spi_slave_version;
 *   uint8_t valid_data[] = {0x55, 0xaa, 0x5a, 0xa5};
 *
 *   init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *   if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *   {
 *     spi_slave_version = SPI_SLAVE_GetAppVersion();
 *
 *     //Check the APP version
 *     if((spi_slave_version.major == 4) &&
 *       (spi_slave_version.minor == 0))
 *     {
 *       //Transmit data
 *       SPI_SLAVE_Transmit(&SPI_SLAVE_0, valid_data, sizeof(valid_data));
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *   return 1U;
 * }
 *
 *  @endcode
 */
DAVE_APP_VERSION_t SPI_SLAVE_GetAppVersion(void);

/**
 * @brief Initializes the USIC channel as SPI slave.
 * @param handle Pointer to static and dynamic attributes of APP configuration.
 * @return SPI_SLAVE_STATUS_t: Status of SPI_SLAVE driver initialization.\n
 *                    @ref SPI_SLAVE_STATUS_SUCCESS - on successful initialization.\n
 *                    @ref SPI_SLAVE_STATUS_FAILURE - if initialization fails.\n
 *                    @ref SPI_SLAVE_STATUS_BUSY - if SPI_SLAVE channel is busy.\n
 *
 * \par<b>Description:</b><br>
 * Initializes IO pins used for the SPI_SLAVE communication, configures
 * USIC registers based on the GUI modifications.
 * It also configures selected interrupts, DMA channels and peripheral register bitfields.
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *         while(1U)
 *         {
 *         }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *  @endcode
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_Init(const SPI_SLAVE_t *const handle);

/**
 * @brief Registers a request for transmitting data over SPI channel as a slave device.
 *
 * @param  handle  SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param  data_ptr Pointer to data of type uint8_t.
 * @param  count Total no of words to be transmitted.\n
 * \b Range: minimum= 1, maximum= maximum supported by uint32_t.<br>
 * In DMA mode, a maximum of 4095 words can be transmitted in one attempt.
 *
 * @return  SPI_SLAVE_STATUS_t: Status of transmit request.\n
 *                        @ref SPI_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref SPI_SLAVE_STATUS_BUSY if a transmission is in progress.\n
 *                        @ref SPI_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0.\n
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 * \par<b>Description:</b><br>
 * Transmits data using the SPI channel as a slave device. Transmission is accomplished using the transmit mode
 * as configured in the UI.<br>
 * <b>Interrupt:</b><br>
 * The data transmission is accomplished using transmit interrupt. User can configure
 * a callback function in the APP UI. When the data is fully transmitted, the callback
 * function will be executed. If transmit FIFO is enabled, the trigger limit is set to 1.
 * So the transmit interrupt will be generated when all the data in FIFO is moved out of FIFO.
 * The APP handle's runtime structure is used to store the data pointer, count, data index
 * and status of transmission. This function only registers a data transmission request if
 * there is no active transmission in progress. Actual data transmission happens in the transmit
 * interrupt service routine. A trigger is generated for the transmit interrupt to start loading
 * the data to the transmit buffer. If transmit FIFO is configured, the data is filled into the FIFO.
 * Transmit interrupt will be generated subsequently when the transmit FIFO is empty. At this
 * point of time, if there is some more data to be transmitted, it is loaded to the FIFO again.
 * When FIFO is not enabled, data is transmitted one byte at a time. On transmission of each byte
 * an interrupt is generated and the next byte is transmitted in the interrupt service routine.
 * Callback function is executed when all the data bytes are transmitted.
 * If a callback function is not configured, user has to poll for the value of \a tx_busy flag of
 * the APP handle structure( \a handle->runtime->tx_busy ) to check for
 * the completion of data transmission.<br>
 * <b>DMA:</b><br>
 * A DMA channel is configured to provide data to the SPI channel transmit buffer. This removes the load
 * off the CPU. This API will only configure and enable the DMA channel by specifying the data buffer
 * and count of bytes to transmit. Rest is taken care without the CPU's intervention. User can configure
 * a callback function in the APP UI. When the transmission is complete, the callback function will be executed.
 * FIFO will not be used in DMA mode. Receive start interrupt is configured for triggering the
 * DMA channel. So each byte is transmitted in the background through the DMA channel.
 * If the callback function is not configured, \a handle->runtime->tx_busy flag can be checked to
 * verify if the transmission is complete.
 * <b>Direct:</b><br>
 * Data will be transmitted using polling method. Status flags are used to check if data can be transmitted.
 * <i><b> Note:</b> In Direct mode, the API blocks the CPU until the count of bytes requested is transmitted.
 * If this behavior is not desired, use other APIs like @ref SPI_SLAVE_TransmitWord, @ref SPI_SLAVE_GetProtocolStatus etc.</i>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode should be configured as "Direct".
 *   //Description:
 *   //Transmits 9 bytes to the master.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {1,2,3,4,5,6,7,8,9};
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *       SPI_SLAVE_Transmit(&SPI_SLAVE_0, Send_Data, sizeof(Send_Data));
 *       while(SPI_SLAVE_0.runtime->tx_busy)
 *       {
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_Transmit(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count);

/**
 * @brief Registers a request for receiving data over SPI_SLAVE channel.
 *
 *
 * @param  handle  Pointer to SPI_SLAVE_t handle structure
 * @param data_ptr  Pointer to data of type uint8_t.
 * @param  count  Total no of bytes to be received.\n
 *                \b Range: minimum= 1, maximum= maximum value supported by type uint32_t.<br>
 *                In DMA mode, a maximum of 4095 words can be received in one attempt.
 *
 * @return  SPI_SLAVE_STATUS_t: Status for receive request.\n
 *                        @ref SPI_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref SPI_SLAVE_STATUS_BUSY if a reception is in progress.\n
 *                        @ref SPI_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0. \n
 *
 *
 * \par<b>Description:</b><br>
 * Data will be received from the SPI master synchronously. After the requested number of data bytes are received,
 * optionally, the user configured callback function will be executed.
 * Data reception is accomplished using the receive mode selected in the UI.
 * <b>Interrupt:</b><br>
 * Based on the UI configuration, either standard receive buffer(RBUF) or receive FIFO(OUT) is used
 * for data reception. An interrupt is configured for reading received data from the bus. This function
 * only registers a request to receive a number of data bytes from a USIC channel. If FIFO is
 * configured for reception, the FIFO limit is dynamically configured to optimally utilize the
 * CPU load. Before starting data reception, the receive buffers are flushed. So only those data, received
 * after calling the API, will be placed in the user buffer.
 * When all the requested number of data bytes are received, the configured callback
 * function will be executed.
 * If a callback function is not configured, the user has to poll for the value of the
 * variable, \a handle->runtime->rx_busy to be false. The value is updated to \a false when all the
 * requested number of data bytes are received.
 * <br>
 * <b>DMA:</b><br>
 * DMA mode is available only in XMC4x family of microcontrollers. In this mode, a DMA channel is
 * configured for receiving data from standard receive buffer(RBUF) to the user buffer. By calling
 * this API, the DMA channel destination address is configured to the user buffer and the channel is
 * enabled. Receive FIFO will not be used when the receive mode is DMA.
 * Before starting data reception, the receive buffers are flushed. So only those data, received
 * after calling the API, will be placed in the user buffer.
 * When all the requested number of data bytes are received, the configured callback
 * function will be executed.
 * If a callback function is not configured, the user has to poll for the value of the
 * variable, \a handle->runtime->rx_busy to be false. The value is updated to \a false when all the
 * requested number of data bytes are received.
 * <br>
 * <b>Direct</b><br>
 * In Direct receive mode, neither interrupt nor DMA is used. The API polls
 * the receive flag to read the received data and waits for all the requested number of bytes to
 * be received. Based on FIFO configuration, either RBUF or OUT register is used for reading received
 * data. Before starting data reception, the receive buffers are flushed. So only those data, received
 * after calling the API, will be placed in the user buffer.
 * <i><b> Note:</b> In Direct mode, the API blocks the CPU until the count of bytes requested is received.
 * If this behaviour is not desired, use other APIs like @ref SPI_SLAVE_GetReceivedWord, @ref SPI_SLAVE_GetProtocolStatus etc.</i>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Receive mode should be configured as "Direct".
 *   //Description:
 *   //Receives 10 bytes from master.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t ReadData[10];
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *       if(SPI_SLAVE_Receive(&SPI_SLAVE_0, ReadData, 10) == SPI_SLAVE_STATUS_SUCCESS)
 *       {
 *         SPI_SLAVE_Transmit(&SPI_SLAVE_0, ReadData, 10);
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *  @endcode
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_Receive(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count);

#ifdef SPI_SLAVE_TX_INTERRUPT_USED
/**
 * @brief Registers a request for transmitting data over SPI channel as a slave device.
 *
 * @param  handle  SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param  data_ptr Pointer to data of type uint8_t.
 * @param  count Total no of words to be transmitted.\n
 * \b Range: minimum= 1, maximum= maximum supported by uint32_t.
 *
 * @return  SPI_SLAVE_STATUS_t: Status of transmit request.\n
 *                        @ref SPI_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref SPI_SLAVE_STATUS_BUSY if a transmission is in progress.\n
 *                        @ref SPI_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0.\n
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 * \par<b>Description:</b><br>
 * The data transmission is accomplished using transmit interrupt. User can configure
 * a callback function in the APP UI. When the data is fully transmitted, the callback
 * function will be executed. If transmit FIFO is enabled, the trigger limit is set to 1.
 * So the transmit interrupt will be generated when all the data in FIFO is moved from FIFO.
 * The function uses APP handle's runtime structure to store the data pointer, count, data index
 * and status of transmission. This function only registers a data transmission request if
 * there is no active transmission in progress. Actual data transmission happens in the transmit
 * interrupt service routine. A trigger is generated for the transmit interrupt to start loading
 * the data. If transmit FIFO is configured, the data is filled into the FIFO.
 * Transmit interrupt will be generated next time when the transmit FIFO is empty. At this
 * point of time, if there is some more data to be transmitted, it will be loaded to the FIFO again.
 * When FIFO is not enabled, data will be transmitted one byte at a time. On transmission of each byte
 * an interrupt will be generated and the next byte is transmitted in the interrupt service routine.
 * Callback function will be executed when all the data words are transmitted.
 * If a callback function is not configured, user has to poll for the value of \a tx_busy flag of
 * the APP handle structure( \a handle->runtime->tx_busy ) to check for
 * the completion of data transmission.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode should be configured as "Interrupt".
 *   //Description:
 *   //Transmits test data to master.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {0x55, 0xaa, 0x5a, 0xa5};
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *       if(SPI_SLAVE_StartTransmitIRQ(&SPI_SLAVE_0, Send_Data, sizeof(Send_Data)) == SPI_SLAVE_STATUS_SUCCESS)
 *       {
 *         while(SPI_SLAVE_0.runtime->tx_busy)
 *         {
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_StartTransmitIRQ(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count);
#endif

#ifdef SPI_SLAVE_RX_INTERRUPT_USED
/**
 * @brief Registers a request for receiving data over SPI channel as a slave device.
 *
 *
 * @param  handle  Pointer to SPI_SLAVE_t handle structure
 * @param data_ptr  Pointer to data of type uint8_t.
 * @param  count  Total no of words to be received.\n
 *                \b Range: minimum= 1, maximum= maximum value supported by type uint32_t.<br>
 *                In DMA mode, a maximum of 4095 words can be received in one attempt.
 *
 * @return  SPI_SLAVE_STATUS_t: Status for receive request.\n
 *                        @ref SPI_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref SPI_SLAVE_STATUS_BUSY if a reception is in progress.\n
 *                        @ref SPI_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0. \n
 *
 *
 * \par<b>Description:</b><br>
 * Data will be received from a master device synchronously. When the requested number of data words are received,
 * optionally, the user configured callback function will be executed.
 * Based on the GUI configuration, either standard receive buffer or receive FIFO is used
 * for data reception. An interrupt will be configured for reading received data from the register. This function
 * only registers a request to receive a number of data words from a USIC channel. If FIFO is
 * configured for data reception, the FIFO limit is dynamically configured to optimally utilize the
 * CPU load.  When all the requested count of data words are received, the configured callback
 * function will be executed.
 * If a callback function is not configured, the user has to poll for the value of the
 * variable, \a handle->runtime->rx_busy to be false. The value is updated to \a false when all the
 * requested number of data bytes are received.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode and receive mode should be configured as "Interrupt".
 *   //Description:
 *   //Receives 10 bytes from master and retransmits the same.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t ReadData[10];
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *       if(SPI_SLAVE_Receive(&SPI_SLAVE_0, ReadData, 10) == SPI_SLAVE_STATUS_SUCCESS)
 *       {
 *         while(SPI_SLAVE_0.runtime->rx_busy)
 *         {
 *         }
 *         SPI_SLAVE_Transmit(&SPI_SLAVE_0, ReadData, 10);
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *  @endcode
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_StartReceiveIRQ(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count);
#endif

#if (defined SPI_SLAVE_TX_INTERRUPT_USED || defined SPI_SLAVE_TX_DMA_USED)
/**
 * @brief Aborts the ongoing data transmission.
 * @param handle  SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @return SPI_SLAVE_STATUS_t: Result of transmit abort request.\n
 *                       @ref SPI_SLAVE_STATUS_SUCCESS if the SPI_SLAVE channel transmission is stopped
 *                       successfully.\n
 *                       @ref SPI_SLAVE_STATUS_MODE_MISMATCH if transmit mode is Direct.\n
 *
 * \par<b>Description:</b><br>
 * If there is a transmission in progress, it will be stopped. If transmit FIFO is used,
 * the existing data will be flushed. After the transmission is stopped, user can start
 * a new transmission without delay. Abort request for transmit mode direct cannot be serviced since
 * the direct mode transmit API is a blocking call.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode should be configured as "Interrupt".
 *   //Description:
 *   //Transmits test data from buffer Send_Data and aborts it immediately.
 *   //Retransmits data from NewData.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {0x55, 0xaa, 0x5a, 0xa5, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99};
 *     uint8_t NewData[] = {0,1,2,3,4,5,6,7,8,9};
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *       SPI_SLAVE_Transmit(&SPI_SLAVE_0, Send_Data, sizeof(Send_Data));
 *
 *       if(SPI_SLAVE_0.runtime->tx_busy)
 *       {
 *         if(SPI_SLAVE_AbortTransmit(&SPI_SLAVE_0) == SPI_SLAVE_STATUS_SUCCESS)
 *         {
 *           SPI_SLAVE_Transmit(&SPI_SLAVE_0, NewData, sizeof(NewData));
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_AbortTransmit(const SPI_SLAVE_t *const handle);
#endif

#if (defined SPI_SLAVE_RX_INTERRUPT_USED || defined SPI_SLAVE_RX_DMA_USED)
/**
 * @brief Stops the active data reception sequence.
 * @param handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @return SPI_SLAVE_STATUS_t: Result of reception abort request.\n
 *                       @ref SPI_SLAVE_STATUS_SUCCESS if the SPI_SLAVE channel reception has
 *                       been stopped.\n
 *                       @ref SPI_SLAVE_STATUS_MODE_MISMATCH if receive mode is Direct.\n
 *
 * \par<b>Description:</b><br>
 * If a reception is in progress, it will be stopped. When a reception request
 * is active, user will not be able to place a new receive request till the active
 * reception is complete. This API can stop the progressing reception to make
 * a new receive request. Abort request for receive mode direct cannot be serviced since
 * the direct mode receive API is a blocking call.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode and receive mode should be configured as "Interrupt".
 *   //Description:
 *   //Transmits the string "Infineon DAVE application" to the master.
 *   //Starts to receive data from master, checks if the first byte is 0x55.
 *   //If so, aborts the reception and retransmits 0x55 to master.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = "Infineon DAVE application.";
 *     uint8_t Rec_Data[64];
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *       SPI_SLAVE_Transmit(&SPI_SLAVE_0, Send_Data, sizeof(Send_Data));
 *       while(SPI_SLAVE_0.runtime->tx_busy);
 *
 *       SPI_SLAVE_Receive(&SPI_SLAVE_0, Rec_Data, 15);
 *
 *       while(SPI_SLAVE_0.runtime->rx_data_index == 0);
 *       if(SPI_SLAVE_0.runtime->rx_data[0] == 0x55)
 *       {
 *         if(SPI_SLAVE_AbortReceive(&SPI_SLAVE_0) == SPI_SLAVE_STATUS_SUCCESS)
 *         {
 *           SPI_SLAVE_Transmit(&SPI_SLAVE_0, Rec_Data, 1);
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_AbortReceive(const SPI_SLAVE_t *const handle);
#endif

#ifdef SPI_SLAVE_TX_DMA_USED
/**
 * @brief Registers a request for transmitting data over SPI channel as a slave device using DMA.
 *
 * @param  handle  SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param  data_ptr Pointer to data of type uint8_t.
 * @param  count Total number of words to be transmitted.\n
 * \b Range: minimum= 1, maximum= 4095.
 *
 * @return  SPI_SLAVE_STATUS_t: Status of transmit request.\n
 *                        @ref SPI_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref SPI_SLAVE_STATUS_BUSY if a transmission is in progress.\n
 *                        @ref SPI_SLAVE_STATUS_MODE_MISMATCH if the handle is not configured for
 *                        DMA transmit mode. \n
 *                        @ref SPI_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0. \n
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 * \par<b>Description:</b><br>
 * The data transmission is accomplished using DMA. User can configure
 * a callback function in the APP UI. When the data is fully transmitted, the callback
 * function will be executed.
 * The function uses APP handle's runtime structure to store the status of transmission.
 * This function only registers a data transmission request, if
 * there is no active transmission in progress. Actual data transmission happens through DMA channel.
 * A maximum of 4095 bytes can be transmitted in one API call. This limit is because of the DMA single block size.
 * Callback function is executed when all the data bytes are transmitted.
 * If a callback function is not configured, user has to poll for the value of \a tx_busy flag of
 * the APP handle structure( \a handle->runtime->tx_busy ) to check for
 * the completion of data transmission.
 * If data more than the block size of 4095 have to be transmitted, user will have to transmit them using multiple calls to this API.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode should be configured as "DMA".
 *   //Description: Transmits 4 bytes of data to the master
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {0x55, 0xaa, 0x5a, 0xa5};
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *       if(SPI_SLAVE_StartTransmitDMA(&SPI_SLAVE_0, Send_Data, sizeof(Send_Data)) == SPI_SLAVE_STATUS_SUCCESS)
 *       {
 *         while(SPI_SLAVE_0.runtime->tx_busy)
 *         {
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_StartTransmitDMA(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count);
#endif

#ifdef SPI_SLAVE_RX_DMA_USED
/**
 * @brief Registers a request for receiving data over SPI channel as a slave device using DMA.
 *
 *
 * @param  handle  Pointer to SPI_SLAVE_t handle structure
 * @param data_ptr  Pointer to data of type uint8_t.
 * @param  count  Total no of of words to be received.\n
 *                \b Range: minimum= 1, maximum= 4095.
 *
 * @return  SPI_SLAVE_STATUS_t: Status for receive request.\n
 *                        @ref SPI_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref SPI_SLAVE_STATUS_BUSY if a reception is in progress.\n
 *                        @ref SPI_SLAVE_STATUS_MODE_MISMATCH if the handle is not configured for
 *                        DMA receive mode. \n
 *                        @ref SPI_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0. \n
 *
 *
 * \par<b>Description:</b><br>
 * Data will be received from a master device synchronously. When the requested count of data words are received,
 * optionally, the user configured callback function will be executed.
 * This function only registers a request to receive a number of data bytes from a USIC channel.
 * When all the requested number of data bytes are received, the configured callback
 * function will be executed.
 * If a callback function is not configured, the user has to poll for the value of the
 * variable, \a handle->runtime->rx_busy to be false. The value is updated to \a false when all the
 * requested number of data bytes are received.
 * A maximum of 4095 bytes can be received in one API call. This limit is because of the DMA single block size.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre condition:
 *   //Transmit mode and receive mode should be configured to "DMA"
 *   //Description: Receive 10 bytes from master and transmit the same in subsequent clock cycles
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t ReadData[10];
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *       if(SPI_SLAVE_StartReceiveDMA(&SPI_SLAVE_0, ReadData, 10) == SPI_SLAVE_STATUS_SUCCESS)
 *       {
 *         while(SPI_SLAVE_0.runtime->rx_busy)
 *         {
 *         }
 *         SPI_SLAVE_StartTransmitDMA(&SPI_SLAVE_0, ReadData, 10);
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *  @endcode
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_StartReceiveDMA(const SPI_SLAVE_t *const handle, uint8_t* data_ptr, uint32_t count);
#endif

/**
 * @brief Registers a request for transmitting and receiving data simultaneously over SPI channel as a slave device.
 *
 * @param  handle  SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param  tx_dataptr Pointer to data of type uint8_t.
 * @param  rx_dataptr Pointer to data of type uint8_t.
 * @param  count Total no of words to be transmitted and received.\n
 * \b Range: minimum= 1, maximum= maximum supported by uint32_t.<br>
 * In DMA mode, a maximum of 4095 words can be transferred in one attempt.
 *
 * @return  SPI_SLAVE_STATUS_t: Status of transmit request.\n
 *                        @ref SPI_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref SPI_SLAVE_STATUS_BUSY if a transmission is in progress.\n
 *                        @ref SPI_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0.\n
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 * \par<b>Description:</b><br>
 * Transmits and receives data simultaneously using the SPI channel as a slave device. API is applicable only in <i>Full duplex</> operation mode.
 * Data transfer happens based on the individual modes configured for transmission and reception.<br>
 * Two data pins MOSI and MISO will be used for receiving and transmitting data respectively. A callback function can be configured to execute
 * after completing the transfer when 'Interrupt' or 'DMA' mode is used. The callback function should be configured for <i>End of receive/transfer callback</i>
 * in the 'Interrupt Settings' tab. The callback function will be executed when the last word of data is received.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 * //Precondition: Operation mode should be 'Full Duplex"
 * //Description: Transmit and receive 9 bytes of data from master in parallel.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {1,2,3,4,5,6,7,8,9};
 *     uint8_t Rec_Data[10];
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *       SPI_SLAVE_Transfer(&SPI_SLAVE_0, Send_Data, Rec_Data, sizeof(Send_Data));
 *       while(SPI_SLAVE_0.runtime->rx_busy)
 *       {
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_Transfer(const SPI_SLAVE_t *const handle, uint8_t* tx_dataptr, uint8_t* rx_dataptr, uint32_t count);

/**
 * @brief Changes the operation mode of the SPI slave channel.
 *
 * @param  handle  SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param  mode  Operation mode to be configured.\n
 * \b Range: XMC_SPI_CH_MODE_STANDARD - Full duplex \n
 *           XMC_SPI_CH_MODE_STANDARD_HALFDUPLEX - Half duplex \n
 *           XMC_SPI_CH_MODE_DUAL - Dual SPI \n
 *           XMC_SPI_CH_MODE_QUAD - Quad SPI \n
 *
 * @return  SPI_SLAVE_STATUS_t: Status of transmit request.\n
 *                        @ref SPI_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref SPI_SLAVE_STATUS_BUSY if a transmission or reception is in progress.\n
 *                        @ref SPI_SLAVE_STATUS_FAILURE if the mode change is not possible.\n
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the operation mode is changed.
 *
 * \par<b>Description:</b><br>
 * Tries to change the operation mode of the SPI channel. Mode change is possible when the operation mode configured in the GUI uses
 * higher number of pins than the new mode requested. Mode change is not possible when the GUI configured operation mode is 'Full Duplex' or
 * 'Half Duplex'. This is due to the connection between MOSI and MISO pins. In 'Full Duplex' mode, MOSI pin of the SPI slave device will be
 * configured as input. But in 'Half Duplex' mode, the same pin has to be configured as output pin with the alternate function of USIC channel DOUT0.
 * Information about the output alternate function will not be available with the APP at runtime. So change of operation mode from 'Full Duplex' to
 * 'Half Duplex' is not possible. Mode change is possible from 'Quad SPI' to 'Dual SPI' or to 'Half Duplex' or to 'Full Duplex'. Mode change is also possible
 * from 'Dual SPI' to 'Half Duplex' or 'Full Duplex'. But mode change from 'Dual SPI' to 'Quad SPI' is not possible. When the mode change is not possible,
 * the API will return the status @ref SPI_SLAVE_STATUS_FAILURE.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *   //Precondition:
 *   //Configure the SPI_SLAVE APP operation mode as 'Quad SPI'.
 *   //Description:
 *   //The following code expects a command from SPI master device (0x08, 0x01) to change the operation mode to 'Half Duplex'
 *   //After receiving the code, slave device changes opeation mode and starts waiting for 4 words of data.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[10];
 *     uint8_t Rec_Data[10];
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *
 *       SPI_SLAVE_Receive(&SPI_SLAVE_0, Rec_Data, 2);
 *       while(SPI_SLAVE_0.runtime->rx_busy)
 *       {
 *       }
 *
 *       if((Rec_Data[0] == 0x08) && (Rec_Data[1] == 0x01))
 *       {
 *         if(SPI_SLAVE_SetMode(&SPI_SLAVE_0, XMC_SPI_CH_MODE_STANDARD_HALFDUPLEX) == SPI_SLAVE_STATUS_FAILURE)
 *         {
 *           while(1);
 *         }
 *         else
 *         {
 *           SPI_SLAVE_Receive(&SPI_SLAVE_0, Rec_Data, 4);
 *           while(SPI_SLAVE_0.runtime->rx_busy)
 *           {
 *           }
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
SPI_SLAVE_STATUS_t SPI_SLAVE_SetMode(const SPI_SLAVE_t * const handle, XMC_SPI_CH_MODE_t mode);

/**
 * @brief Provides the status of protocol events.
 *
 * @param handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param protocol_status Event whose status is to be read.\n
 *             \b Range: Use type @ref XMC_SPI_CH_STATUS_FLAG_t for input. Multiple events can
 *             be combined using \a OR operation.
 *
 * @return uint32_t: Status of selected protocol events read from PSR_SSCMode register.\n
 * \b Range: Use type @ref XMC_SPI_CH_STATUS_FLAG_t for comparing the return value
 * with event bitmasks. Status of multiple events can be checked by combining enum
 * values using \a OR operation while comparing.
 *
 * \par<b>Description:</b><br>
 * Reads the protocol status bits from the register PSR_SSCMode and compares the values with
 * the input value of selected events. Returns the masked value of selected events with the status register value.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 * //Configure SPI_SLAVE word length = 16, frame length = 64.
 * //Description:
 * //The example below, waits for slave select signal to be asserted.
 * //It receives 10 words from the SPI master.
 * //Transmits the received data in the subsequent clock cycles.
 * //For the communication to start, master should transmit 10 words and
 * //receive 10 words.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint16_t ReceiveData[10];
 *
 *   init_status = DAVE_Init();
 *
 *   if(init_status == DAVE_STATUS_SUCCESS)
 *   {
 *
 *     while(1U)
 *     {
 *       //Wait for slave select signal to be asserted
 *       if(SPI_SLAVE_GetFlagStatus(&SPI_SLAVE_0, XMC_SPI_CH_STATUS_FLAG_DX2S))
 *       {
 *         if(SPI_SLAVE_Receive(&SPI_SLAVE_0, ReceiveData, 10) == SPI_SLAVE_STATUS_SUCCESS)
 *         {
 *           //Wait for reception of 10 words
 *           while(SPI_SLAVE_IsRxBusy(&SPI_SLAVE_0))
 *           {
 *           }
 *           SPI_SLAVE_Transmit(&SPI_SLAVE_0, ReceiveData, 10);
 *           //Wait for transmission of 10 words
 *           while(SPI_SLAVE_IsTxBusy(&SPI_SLAVE_0))
 *           {
 *           }
 *         }
 *       }
 *     }
 *   }
 *   else
 *   {
 *
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *
 *   return 1U;
 * }
 *
 * @endcode
 *
 */
__STATIC_INLINE uint32_t SPI_SLAVE_GetFlagStatus(SPI_SLAVE_t * handle, const uint32_t flag)
{
  XMC_ASSERT("SPI_SLAVE_GetFlagStatus:handle NULL" , (handle != NULL));
  return (XMC_SPI_CH_GetStatusFlag(handle->channel) & flag);
}

/**
 * @brief Clears the event status in the register(PSR_SSCMode).
 *
 * @param handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param protocol_status Event whose status is to be cleared.\n
 *             \b Range: Use type @ref XMC_SPI_CH_STATUS_FLAG_t for input. Multiple events can
 *             be combined using \a OR operation.
 * @return None
 *
 * \par<b>Description:</b><br>
 * Clears a given protocol event flag bit using the PSCR register.
 * This function is an inline wrapper for the API provided by xmc_spi.h file.
 * The user should mask the input value based on the events to be cleared.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 * //Description:
 * //Receives a data word and retransmits it to the master as the next word.
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint16_t ReceiveData = 0;
 *
 *   init_status = DAVE_Init();
 *
 *   if(init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     while(1U)
 *     {
 *        //Check if any data received
 *        if(SPI_SLAVE_GetFlagStatus(&SPI_SLAVE_0, (XMC_SPI_CH_STATUS_FLAG_RECEIVE_INDICATION |
 *         XMC_SPI_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION)))
 *        {
 *           //Read the received data
 *           ReceiveData = XMC_SPI_CH_GetReceivedData(SPI_SLAVE_0.channel);
 *           //Transmit the received data
 *           SPI_SLAVE_TransmitWord(&SPI_SLAVE_0,ReceiveData);
 *           //Clear the receive flags
 *           SPI_SLAVE_ClearFlag(&SPI_SLAVE_0,(XMC_SPI_CH_STATUS_FLAG_RECEIVE_INDICATION |
 *                    XMC_SPI_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION));
 *        }
 *     }
 *   }
 *   else
 *   {
 *
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 * @endcode
 *
 */
__STATIC_INLINE void SPI_SLAVE_ClearFlag(const SPI_SLAVE_t* handle, const uint32_t flag_mask)
{
    XMC_ASSERT("SPI_SLAVE_ClearFlag:handle NULL" , (handle != NULL));
    XMC_SPI_CH_ClearStatusFlag(handle->channel, flag_mask);
}

/**
 * @brief Provides data received in the receive buffer.
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @return uint16_t: Data read from RBUF or FIFO.\n
 *
 * \par<b>Description:</b><br>
 * This can be used in receive mode "Direct" to read the received data.
 * If receive FIFO is not configured, function reads the value of RBUF register.
 * Otherwise the data is read from OUTR register.
 * User can poll for receive event or configure an interrupt by connecting
 * external INTERRUPT APP with receive event signals. This API can be used inside the ISR to read the received data.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Precondition:
 *   //Configure transmit mode and receive mode as "Direct".
 *   //Description:
 *   //The example below receives 10 words from the master. Transmits the received 10 words in the
 *   //subsequent clock cycles.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint16_t Rec_Data[10];
 *     uint32_t data_index = 0;
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *        //Configure the receive FIFO to generate event when the FIFO is filled with 10 words.
 *        SPI_SLAVE_SetRXFIFOTriggerLimit(&SPI_SLAVE_0, 9);
 *        //Receive 10 words input
 *        data_index = 0;
 *        //Wait for receive FIFO to be filled
 *        while(!(SPI_SLAVE_GetRXFIFOStatus(&SPI_SLAVE_0) &
 *             (XMC_USIC_CH_RXFIFO_EVENT_STANDARD | XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE)))
 *        {
 *        }
 *          while(1)
 *          {
 *            Rec_Data[data_index] = SPI_SLAVE_GetReceivedWord(&SPI_SLAVE_0);
 *            data_index++;
 *            //Break out of while(1) if 10 words are received.
 *            if(data_index == 10)
 *            {
 *              break;
 *            }
 *            else
 *            {
 *              //Wait if FIFO is empty
 *              while(SPI_SLAVE_IsRXFIFOEmpty(&SPI_SLAVE_0));
 *            }
 *          }
 *
 *
 *
 *        //Transmit the received data
 *        SPI_SLAVE_Transmit(&SPI_SLAVE_0,Rec_Data, 10);
 *        while(SPI_SLAVE_0.runtime->tx_busy);
 *
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
__STATIC_INLINE uint16_t SPI_SLAVE_GetReceivedWord(const SPI_SLAVE_t* const handle)
{
  XMC_ASSERT("SPI_SLAVE_GetReceivedWord:handle invalid", (handle != NULL))
  return XMC_SPI_CH_GetReceivedData(handle->channel);
}

/**
 * @brief Transmits a word of data.
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t \n
 * @param data Data to be transmitted.\n
 * @return None\n
 *
 * \par<b>Description:</b><br>
 * Transmits a word of data through the SPI channel as a slave device.
 * If transmit FIFO is configured, the data is placed in the IN[0] register of the USIC channel.
 * If transmit FIFO is not configured, API waits for the TBUF to be free and then places the data in the TBUF register.
 * User can poll for receive event or configure interrupt by connecting an
 * external INTERRUPT APP. This API can be used inside the ISR to read the received data.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Precondition:
 *   //Configure transmit mode and receive mode as "Direct", word length = 16
 *   //Description:
 *   //Transmits 10 words to the master.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint16_t Send_Data[] = {0,1,2,3,4,5,6,7,8,9};
 *     uint16_t Rec_Data[10];
 *     uint32_t data_index = 0;
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *        while(data_index < sizeof(Send_Data))
 *        {
 *           SPI_SLAVE_TransmitWord(&SPI_SLAVE_0,Send_Data[data_index]);
 *           data_index++;
 *
 *           //Wait for transmit buffer interrupt to fill it again with remaining data
 *           while((SPI_SLAVE_GetTXFIFOStatus(&SPI_SLAVE_0) & XMC_USIC_CH_TXFIFO_EVENT_STANDARD) == 0);
 *           SPI_SLAVE_ClearTXFIFOStatus(&SPI_SLAVE_0, XMC_USIC_CH_TXFIFO_EVENT_STANDARD);
 *        }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
__STATIC_INLINE void SPI_SLAVE_TransmitWord(const SPI_SLAVE_t* const handle, uint16_t data)
{
  XMC_ASSERT("SPI_SLAVE_TransmitWord:handle invalid", (handle != NULL))
  XMC_SPI_CH_Transmit(handle->channel, data, handle->runtime->spi_current_mode);
}

/**
 * @brief Enables the selected protocol events for interrupt generation.
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param  events Protocol events to be enabled for interrupt generation. \n
 *         \b Range: Use type \a XMC_SPI_CH_EVENT_t to select the event. Multiple events can be
 *         combined using the bitwise OR operation.\n
 * @return None \n
 *
 * \par<b>Description:</b><br>
 * Enables the events by configuring CCR or PCR register based on the event.
 * When the event is enabled, an interrupt can be generated on occurrence of the event.
 * The API can be used for protocol events(PCR_SSC events) only when the callback functions are not registered under
 * 'Error and Protocol Handling' group.
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *  // Precondition:
 *  // Add INTERRUPT APP and connect the SPI_SLAVE APP protocol interrupt signal to the INTERRUPT APP
 *  // irq signal. Provide the callback function name in INTERRUPT APP as "ProtocolInterrupt".
 *  //
 *  // Description: The example configures protocol interrupt for data loss detection.
 *  // When the data loss interrupt occurs, the receive FIFO is cleared. After the receive FIFO
 *  // is cleared, the channel can receive few bytes till the FIFO gets filled.
 *
 *  int main(void)
 *  {
 *    DAVE_STATUS_t status;
 *    //Initializes USIC for SPI slave functionality
 *    status = DAVE_Init();
 *
 *    if(status == DAVE_STATUS_FAILURE)
 *    {
 *      XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *      while(1U)
 *      {
 *
 *      }
 *    }
 *    //Enable the data lost event to generate interrupt
 *    SPI_SLAVE_EnableEvent(&SPI_SLAVE_0, XMC_SPI_CH_EVENT_DATA_LOST);
 *    while(1U)
 *    {
 *    }
 *  }
 *
 *  //Protocol interrupt handler
 *  void ProtocolInterrupt()
 *  {
 *    SPI_SLAVE_DisableEvent(&SPI_SLAVE_0, XMC_SPI_CH_EVENT_DATA_LOST);
 *    //Clear receive FIFO so that data will be received.
 *    XMC_USIC_CH_RXFIFO_Flush(SPI_SLAVE_0.channel);
 *
 *    //Enable the event to generate interrupt again.
 *    SPI_SLAVE_EnableEvent(&SPI_SLAVE_0, XMC_SPI_CH_EVENT_DATA_LOST);
 *  }
 * @endcode
 */
__STATIC_INLINE void SPI_SLAVE_EnableEvent(const SPI_SLAVE_t* const handle, uint32_t events)
{
  XMC_ASSERT("SPI_SLAVE_EnableEvent:handle invalid", (handle != NULL))
  XMC_SPI_CH_EnableEvent(handle->channel, events);
}

/**
 * @brief Disables selected events from generating interrupt.
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param  events Events to be disabled from generating interrupt. \n
 *         \b Range: Use type \a XMC_SPI_CH_EVENT_t to select the event. Multiple events can be
 *         combined using the bitwise OR operation. \n
 * @return None
 *
 * \par<b>Description:</b><br>
 * Events are disabled by clearing their respective bits in either CCR or PCR register.
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *  // Precondition:
 *  // Add INTERRUPT APP and connect the SPI_SLAVE APP protocol interrupt signal to the INTERRUPT APP
 *  // irq signal. Provide the callback function name in INTERRUPT APP as "ProtocolInterrupt".
 *  //
 *  // Description: The example configures protocol interrupt for data loss detection.
 *  // When the data loss interrupt occurs, the receive FIFO is cleared. After the receive FIFO
 *  // is cleared, the channel can receive few bytes till the FIFO gets filled.
 *
 *  int main(void)
 *  {
 *    DAVE_STATUS_t status;
 *
 *    status = DAVE_Init();
 *
 *    if(status == DAVE_STATUS_FAILURE)
 *    {
 *      XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *      while(1U)
 *      {
 *
 *      }
 *    }
 *    SPI_SLAVE_EnableEvent(&SPI_SLAVE_0, XMC_SPI_CH_EVENT_DATA_LOST);
 *    while(1U)
 *    {
 *    }
 *  }
 *  void ProtocolInterrupt()
 *  {
 *    SPI_SLAVE_DisableEvent(&SPI_SLAVE_0, XMC_SPI_CH_EVENT_DATA_LOST);
 *    //Clear receive FIFO so that data will be received.
 *    XMC_USIC_CH_RXFIFO_Flush(SPI_SLAVE_0.channel);
 *    SPI_SLAVE_EnableEvent(&SPI_SLAVE_0, XMC_SPI_CH_EVENT_DATA_LOST);
 *  }
 *
 * @endcode
 *
 */
__STATIC_INLINE void SPI_SLAVE_DisableEvent(const SPI_SLAVE_t* const handle, uint32_t events)
{
  XMC_ASSERT("SPI_SLAVE_DisableEvent:handle invalid", (handle != NULL))
  XMC_SPI_CH_DisableEvent(handle->channel, events);
}

/**
 * @brief Checks if the transmit FIFO is full.
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 *
 * @return bool Status of transmit FIFO filling level.<br>
 *              \b Range: \a true - if transmit FIFO is full.<br>
 *                       \a false - if transmit FIFO is not full.<br>
 * \par<b>Description:</b><br>
 * Checks the status using the register TRBSR. Can be used while filling
 * data to the transmit FIFO.
 *
 * Example Usage:
 * @code
 *  #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *  // Precondition:
 *  // Transmit mode should be "Direct"
 *  // Description:
 *  // Transmits 10 words using FIFO.
 *
 * uint16_t send_data[] = {0,1,2,3,4,5,6,7,8,9};
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint32_t loc_index;
 *
 *   status = DAVE_Init();           // Initialization of DAVE APPs
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *   for(loc_index = 0; loc_index < sizeof(send_data)/2U; loc_index++)
 *   {
 *     //Wait when Tx FIFO is full
 *     while(SPI_SLAVE_IsTXFIFOFull(&SPI_SLAVE_0))
 *     {
 *     }
 *     SPI_SLAVE_TransmitWord(&SPI_SLAVE_0, send_data[loc_index]);
 *   }
 *   while(1U)
 *   {
 *   }
 * }
 * @endcode
 */
__STATIC_INLINE bool SPI_SLAVE_IsTXFIFOFull(const SPI_SLAVE_t* const handle)
{
  XMC_ASSERT("SPI_SLAVE_IsTXFIFOFull:handle invalid", (handle != NULL))
  return XMC_USIC_CH_TXFIFO_IsFull(handle->channel);
}

/**
 * @brief Checks if the receive FIFO is empty.
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 *
 * @return bool Status of receive FIFO filling level.<br>
 *              \b Range: \a true - if receive FIFO is empty.<br>
 *                        \a false - if receive FIFO still has data.<br>
 * \par<b>Description:</b><br>
 * Checks the status using the register TRBSR. Can be used while reading
 * data from the receive FIFO.
 *
 * Example Usage:
 * @code
 *  #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *  // Precondition:
 *  // Receive mode should be "Direct", word length = 16
 *  //
 *  // Description:
 *  // Receives 10 words and transmits the received 10 words.
 *
 * uint16_t rec_data[10U];
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint32_t loc_index;
 *
 *   status = DAVE_Init();           // Initialization of DAVE APPs
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *   //sizeof() returns the number of bytes
 *   for(loc_index = 0; loc_index < (sizeof(rec_data)/2U); loc_index++)
 *   {
 *     //Wait when Rx FIFO is empty
 *     while(SPI_SLAVE_IsRXFIFOEmpty(&SPI_SLAVE_0))
 *     {
 *     }
 *     rec_data[loc_index] = SPI_SLAVE_GetReceivedWord(&SPI_SLAVE_0);
 *   }
 *   //Transmit the received data
 *   SPI_SLAVE_Transmit(&SPI_SLAVE_0, rec_data, sizeof(rec_data)/2U);
 *   while(1U)
 *   {
 *   }
 * }
 * @endcode
 */
__STATIC_INLINE bool SPI_SLAVE_IsRXFIFOEmpty(const SPI_SLAVE_t* const handle)
{
  XMC_ASSERT("SPI_SLAVE_IsRXFIFOEmpty:handle invalid", (handle != NULL))
  return XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel);
}

/**
 * @brief Configures trigger limit for the transmit FIFO.
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param  limit Value of transmit FIFO filling level, transition below which the interrupt should be generated.\n
 *               \bRange: 0 to transmit FIFO size.\n
 *               e.g, If transmit FIFO size is 16, and limit is configured as 8, FIFO standard transmit buffer interrupt
 *               will be generated when the FIFO filling level drops from 8 to 7.\n
 *
 * @return None\n
 *
 * \par<b>Description:</b><br>
 * Transmit FIFO trigger limit is configured by setting its value in the TBCTR register.
 * Transmit FIFO is configured to generate interrupt when the FIFO filling level drops
 * below the trigger limit.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *   //Precondition: Configure transmit mode as 'Direct', set transmit FIFO size as 8.
 *  // Description:
 *   //Example below transmits 10 bytes of data to the master.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
 *     uint8_t data_index = 0;
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *        //Configure the transmit FIFO to generate event when FIFO level drops from 5 to 4.
 *        SPI_SLAVE_SetTXFIFOTriggerLimit(&SPI_SLAVE_0, 5);
 *        while(data_index < sizeof(Send_Data))
 *        {
 *           //Put data into the FIFO till it gets full
 *           if(SPI_SLAVE_IsTXFIFOFull(&SPI_SLAVE_0) == false)
 *           {
 *             SPI_SLAVE_TransmitWord(&SPI_SLAVE_0,(uint16_t)Send_Data[data_index]);
 *             data_index++;
 *           }
 *           else
 *           {
 *
 *             //Wait for FIFO transmit standard buffer interrupt to fill it again with remaining data
 *             while((SPI_SLAVE_GetTXFIFOStatus(&SPI_SLAVE_0) & XMC_USIC_CH_TXFIFO_EVENT_STANDARD) == 0);
 *             SPI_SLAVE_ClearTXFIFOStatus(&SPI_SLAVE_0, XMC_USIC_CH_TXFIFO_EVENT_STANDARD);
 *           }
 *        }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 */
__STATIC_INLINE void SPI_SLAVE_SetTXFIFOTriggerLimit(const SPI_SLAVE_t* const handle, uint32_t limit)
{
  XMC_ASSERT("SPI_SLAVE_SetTXFIFOTriggerLimit:handle invalid", (handle != NULL))
  XMC_USIC_CH_TXFIFO_SetSizeTriggerLimit(handle->channel, handle->config->tx_fifo_size, limit);
}

/**
 * @brief Configures trigger limit for the receive FIFO.
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param  limit Value of receive FIFO filling level, transition above which the interrupt should be generated.\n
 *               \bRange: 0 to receive FIFO size.\n
 *               e.g, If receive FIFO size is 16, and limit is configured as 8, FIFO receive buffer interrupt
 *               will be generated when the FIFO filling level rises from 8 to 9.\n
 *
 * @return None\n
 *
 * \par<b>Description:</b><br>
 * Receive FIFO trigger limit is configured by setting its value in the RBCTR register.
 * Receive FIFO is configured to generate interrupt when the FIFO filling level rises
 * above the trigger limit.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Precondition:
 *   //Configure receive mode as "Direct"
 *   //Add an instance of the INTERRUPT APP and connect the SPI_SLAVE event_fifo_receive_buffer_interrupt
 *   //signal to the INTERRUPT sr_irq signal.
 *   //Provide the callback function name in INTERRUPT APP as "rx_cb"
 *  // Description:
 *  // Receives 10 words from the master. Callback function will be executed when 10 words are received.
 *
 *   uint16_t Rec_Data[10];
 *   uint32_t data_index = 0;
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *       //Configure receive interrupt generation when 10 bytes are received
 *       SPI_SLAVE_SetRXFIFOTriggerLimit(&SPI_SLAVE_0, 9);
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *
 *  //INTERRUPT APP callback function
 *  void rx_cb()
 *  {
 *    while((data_index < 10) && (!XMC_USIC_CH_RXFIFO_IsEmpty(SPI_SLAVE_0.channel)))
 *    {
 *      Rec_Data[data_index] = SPI_SLAVE_GetReceivedWord(&SPI_SLAVE_0);
 *      data_index++;
 *    }
 *  }
 * @endcode
 */
__STATIC_INLINE void SPI_SLAVE_SetRXFIFOTriggerLimit(const SPI_SLAVE_t* const handle, uint32_t limit)
{
  XMC_ASSERT("SPI_SLAVE_SetRXFIFOTriggerLimit:handle invalid", (handle != NULL))
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel, handle->config->rx_fifo_size, limit);
}

/**
 * @brief Gets the status of event flags related to receive FIFO.
 *
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 *
 * @return uint32_t: Status of standard receive buffer event, alternative receive buffer
 * event and receive buffer error event in their bit positions in TRBSR register.\n
 * \b Range: Use type @ref XMC_USIC_CH_RXFIFO_EVENT_t for event bitmasks. Multiple events' status
 * can be combined for comparison using \a OR operation.
 *
 * \par<b>Description:</b><br>
 * It provides the status of standard receive buffer event, alternative receive buffer
 * event and receive buffer error event.
 * Function masks the TRBSR register with the bitmask of SRBI,
 * ARBI and RBERI flags. User has to mask the bits of interest before checking
 * the status.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Precondition:
 *   //Configure transmit mode and receive mode as "Direct".
 *  // Description:
 *   //The example below receives 10 words from the master. Transmits the received 10 words in the
 *   //subsequent clock cycles.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint16_t Rec_Data[10];
 *     uint32_t data_index = 0;
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *        //Configure the receive FIFO to generate event when the FIFO is filled with 10 words.
 *        SPI_SLAVE_SetRXFIFOTriggerLimit(&SPI_SLAVE_0, 9);
 *        //Receive 10 words input
 *        data_index = 0;
 *        //Wait for receive FIFO to be filled
 *        while(!(SPI_SLAVE_GetRXFIFOStatus(&SPI_SLAVE_0) &
 *             (XMC_USIC_CH_RXFIFO_EVENT_STANDARD | XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE)))
 *        {
 *        }
 *        SPI_SLAVE_ClearRXFIFOStatus(&SPI_SLAVE_0, (XMC_USIC_CH_RXFIFO_EVENT_STANDARD | XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE));
 *          while(1)
 *          {
 *            Rec_Data[data_index] = SPI_SLAVE_GetReceivedWord(&SPI_SLAVE_0);
 *            data_index++;
 *            //Break out of while(1) if 10 words are received.
 *            if(data_index == 10)
 *            {
 *              break;
 *            }
 *            else
 *            {
 *              //Wait if FIFO is empty
 *              while(SPI_SLAVE_IsRXFIFOEmpty(&SPI_SLAVE_0));
 *            }
 *          }
 *
 *
 *
 *        //Transmit the received data
 *        SPI_SLAVE_Transmit(&SPI_SLAVE_0,Rec_Data, 10);
 *        while(SPI_SLAVE_0.runtime->tx_busy);
 *
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
__STATIC_INLINE uint32_t SPI_SLAVE_GetRXFIFOStatus(const SPI_SLAVE_t* const handle)
{
  XMC_ASSERT("SPI_SLAVE_GetRXFIFOStatus:handle invalid", (handle != NULL))
  return XMC_USIC_CH_RXFIFO_GetEvent(handle->channel);
}

/**
 * @brief Gets the status of transmit FIFO event flags.
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 *
 * @return uint32_t: Status of the STBI and TBERI bits in TRBSR register in
 *                      their bit positions.\n
 *                      \b Range: Use type @ref XMC_USIC_CH_TXFIFO_EVENT_t for the bitmask of events.
 *
 * \par<b>Description:</b><br>
 * Function reads the value of TRBSR register. It masks the standard transmit buffer
 * interrupt flag and transmit buffer error flag before providing the value.
 * User has to mask the bits of interest before checking the status.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *   //Precondition: Configure transmit mode as 'Direct', set transmit FIFO size as 8.
 *  // Description:
 *   //Example below transmits 10 bytes of data to the master.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
 *     uint8_t data_index = 0;
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *        //Configure the transmit FIFO to generate event when FIFO level drops from 5 to 4.
 *        SPI_SLAVE_SetTXFIFOTriggerLimit(&SPI_SLAVE_0, 5);
 *        while(data_index < sizeof(Send_Data))
 *        {
 *           //Put data into the FIFO till it gets full
 *           if(SPI_SLAVE_IsTXFIFOFull(&SPI_SLAVE_0) == false)
 *           {
 *             SPI_SLAVE_TransmitWord(&SPI_SLAVE_0,(uint16_t)Send_Data[data_index]);
 *             data_index++;
 *           }
 *           else
 *           {
 *
 *             //Wait for FIFO transmit standard buffer interrupt to fill it again with remaining data
 *             while((SPI_SLAVE_GetTXFIFOStatus(&SPI_SLAVE_0) & XMC_USIC_CH_TXFIFO_EVENT_STANDARD) == 0);
 *             SPI_SLAVE_ClearTXFIFOStatus(&SPI_SLAVE_0, XMC_USIC_CH_TXFIFO_EVENT_STANDARD);
 *           }
 *        }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
__STATIC_INLINE uint32_t SPI_SLAVE_GetTXFIFOStatus(const SPI_SLAVE_t* const handle)
{
  XMC_ASSERT("SPI_SLAVE_GetTXFIFOStatus:handle invalid", (handle != NULL))
  return XMC_USIC_CH_TXFIFO_GetEvent(handle->channel);
}

/**
 * @brief Function clears the specified FIFO event flag related to
 * transmit FIFO.
 *
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param  flag Value with event bits at their bit positions in TRBSR register
 *             to be cleared.\n
 *             \b Range: Use type @ref XMC_USIC_CH_TXFIFO_EVENT_t. Multiple events can be
 *             combined using \a OR operation.
 *
 * @return    None
 *
 * \par<b>Description:</b><br>
 * Function clears a status bit in TRBSR register using the TRBSCR register.
 * But the function does not mask the input value with the bit positions restricted
 * to transmit FIFO status bits. User should ensure that the input value is appropriately
 * masked.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *   //Precondition: Configure transmit mode as 'Direct', set transmit FIFO size as 8.
 *  // Description:
 *   //Example below transmits 10 bytes of data to the master.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
 *     uint8_t data_index = 0;
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *        //Configure the transmit FIFO to generate event when FIFO level drops from 5 to 4.
 *        SPI_SLAVE_SetTXFIFOTriggerLimit(&SPI_SLAVE_0, 5);
 *        while(data_index < sizeof(Send_Data))
 *        {
 *           //Put data into the FIFO till it gets full
 *           if(SPI_SLAVE_IsTXFIFOFull(&SPI_SLAVE_0) == false)
 *           {
 *             SPI_SLAVE_TransmitWord(&SPI_SLAVE_0,(uint16_t)Send_Data[data_index]);
 *             data_index++;
 *           }
 *           else
 *           {
 *
 *             //Wait for FIFO transmit standard buffer interrupt to fill it again with remaining data
 *             while((SPI_SLAVE_GetTXFIFOStatus(&SPI_SLAVE_0) & XMC_USIC_CH_TXFIFO_EVENT_STANDARD) == 0);
 *             SPI_SLAVE_ClearTXFIFOStatus(&SPI_SLAVE_0, XMC_USIC_CH_TXFIFO_EVENT_STANDARD);
 *           }
 *        }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
__STATIC_INLINE void SPI_SLAVE_ClearTXFIFOStatus(const SPI_SLAVE_t* const handle, const uint32_t flag)
{
  XMC_ASSERT("SPI_SLAVE_ClearTXFIFOStatus:handle invalid", (handle != NULL))
  XMC_USIC_CH_TXFIFO_ClearEvent(handle->channel, flag);
}

/**
 * @brief Function clears the specified FIFO event flag related to
 * receive FIFO. It should be used to clear the status of standard
 * receive buffer interrupt, alternative receive buffer interupt and
 * receive buffer error interrupt flags.
 *
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 * @param  flag Value with event bits at the bit positions in TRBSR register
 *             to be cleared.\n
 *             \b Range: Use type @ref XMC_USIC_CH_RXFIFO_EVENT_t for providing events.
 *             Multiple events can be input by using \a OR operation.
 *
 * @return    None
 *
 * \par<b>Description:</b><br>
 * Function clears a status bit in TRBSR using the TRBSCR register.
 * The function does not mask the input value to clear only receive buffer
 * events. So user should appropriately mask the input value before calling
 * the function.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Precondition:
 *   //Configure transmit mode and receive mode as "Direct".
 *  // Description:
 *   //The example below receives 10 words from the master. Transmits the received 10 words in the
 *   //subsequent clock cycles.
 *
 *   int main(void)
 *   {
 *     SPI_SLAVE_STATUS_t init_status;
 *     uint16_t Rec_Data[10];
 *     uint32_t data_index = 0;
 *
 *     init_status = (SPI_SLAVE_STATUS_t)SPI_SLAVE_Init(&SPI_SLAVE_0);
 *     if(init_status == SPI_SLAVE_STATUS_SUCCESS)
 *     {
 *        //Configure the receive FIFO to generate event when the FIFO is filled with 10 words.
 *        SPI_SLAVE_SetRXFIFOTriggerLimit(&SPI_SLAVE_0, 9);
 *        //Receive 10 words input
 *        data_index = 0;
 *        //Wait for receive FIFO to be filled
 *        while(!(SPI_SLAVE_GetRXFIFOStatus(&SPI_SLAVE_0) &
 *             (XMC_USIC_CH_RXFIFO_EVENT_STANDARD | XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE)))
 *        {
 *        }
 *        SPI_SLAVE_ClearRXFIFOStatus(&SPI_SLAVE_0, (XMC_USIC_CH_RXFIFO_EVENT_STANDARD | XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE));
 *          while(1)
 *          {
 *            Rec_Data[data_index] = SPI_SLAVE_GetReceivedWord(&SPI_SLAVE_0);
 *            data_index++;
 *            //Break out of while(1) if 10 words are received.
 *            if(data_index == 10)
 *            {
 *              break;
 *            }
 *            else
 *            {
 *              //Wait if FIFO is empty
 *              while(SPI_SLAVE_IsRXFIFOEmpty(&SPI_SLAVE_0));
 *            }
 *          }
 *
 *
 *
 *        //Transmit the received data
 *        SPI_SLAVE_Transmit(&SPI_SLAVE_0,Rec_Data, 10);
 *        while(SPI_SLAVE_0.runtime->tx_busy);
 *
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
__STATIC_INLINE void SPI_SLAVE_ClearRXFIFOStatus(const SPI_SLAVE_t* const handle, const uint32_t flag)
{
  XMC_ASSERT("SPI_SLAVE_ClearRXFIFOStatus:handle invalid", (handle != NULL))
  XMC_USIC_CH_RXFIFO_ClearEvent(handle->channel, flag);
}

/**
 * @brief Function provides the status of data transmission.
 *
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 *
 * @return bool Status of data transmission.<br>
 *  \b Range: \b true - Data transmission is in progress.<br>
 *            \b false - No transmission in progress.<br>
 *
 * \par<b>Description:</b><br>
 * Function provides the status of APP handle member SPI_SLAVE.runtime->tx_busy. This flag will be true
 * if a transmission is in progress and it will change to false when the transmission has finished.<br>
 * <i>Note: Even after the state changes from true to false, one word might still be present in the shift register.<br>
 * It is recommended to provide some wait time before stopping the channel after transmission.</i>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 * //Description:
 * //The example below, waits for slave select signal to be asserted.
 * //Transmits 10 bytes to the SPI master.
 * //For the communication to start, master should receive 10 bytes.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint8_t SendData[10] = {0,1,2,3,4,5,6,7,8,9};
 *
 *   init_status = DAVE_Init();
 *
 *   if(init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     //Wait for slave select signal to be asserted
 *     while(!(SPI_SLAVE_GetFlagStatus(&SPI_SLAVE_0, XMC_SPI_CH_STATUS_FLAG_DX2S)))
 *     {
 *       SPI_SLAVE_Transmit(&SPI_SLAVE_0, SendData, 10);
 *       //Wait for transmission of 10 words
 *       while(SPI_SLAVE_IsTxBusy(&SPI_SLAVE_0))
 *       {
 *       }
 *     }
 *     while(1)
 *     {
 *
 *     }
 *   }
 *   else
 *   {
 *
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *
 *   return 1U;
 * }
 *
 * @endcode
 *
 */
__STATIC_INLINE bool SPI_SLAVE_IsTxBusy(const SPI_SLAVE_t* const handle)
{
  XMC_ASSERT("SPI_SLAVE_IsTxBusy:handle invalid", (handle != NULL))
  return handle->runtime->tx_busy;
}

/**
 * @brief Function provides the status of data reception.
 *
 *
 * @param  handle SPI_SLAVE APP handle pointer of type @ref SPI_SLAVE_t
 *
 * @return bool Status of data reception.<br>
 *  \b Range: \b true - Data reception is in progress.<br>
 *            \b false - No reception in progress.<br>
 *
 * \par<b>Description:</b><br>
 * Function provides the status of APP handle member SPI_SLAVE.runtime->rx_busy. This flag will be true
 * if a reception is in progress and it will change to false when the reception of given count is finished.<br>
 * The API can be used after executing \a SPI_SLAVE_Receive(), \a SPI_SLAVE_Transfer() APIs to check if the
 * reception or transfer is finished.<br>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 * //Description:
 * //The example below, waits for slave select signal to be asserted.
 * //Receive 10 bytes from the SPI master.
 * //For the communication to start, master should transmit 10 bytes.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint8_t ReceiveData[10];
 *
 *   init_status = DAVE_Init();
 *
 *   if(init_status == DAVE_STATUS_SUCCESS)
 *   {
 *
 *     //Wait for slave select signal to be asserted
 *     while(!(SPI_SLAVE_GetFlagStatus(&SPI_SLAVE_0, XMC_SPI_CH_STATUS_FLAG_DX2S)))
 *     {
 *       SPI_SLAVE_Receive(&SPI_SLAVE_0, ReceiveData, 10);
 *       //Wait for transmission of 10 words
 *       while(SPI_SLAVE_IsRxBusy(&SPI_SLAVE_0))
 *       {
 *       }
 *     }
 *     while(1)
 *     {
 *     }
 *   }
 *   else
 *   {
 *
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *
 *   return 1U;
 * }
 *
 * @endcode
 *
 */
__STATIC_INLINE bool SPI_SLAVE_IsRxBusy(const SPI_SLAVE_t* const handle)
{
  XMC_ASSERT("SPI_SLAVE_IsRxBusy:handle invalid", (handle != NULL))
  return handle->runtime->rx_busy;
}

/**
 * @}
 */

#ifdef __cplusplus
}
#endif


#include "spi_slave_extern.h"
#endif

