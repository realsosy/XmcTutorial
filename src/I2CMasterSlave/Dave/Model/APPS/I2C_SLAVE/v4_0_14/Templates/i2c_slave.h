/**
 * @file i2c_slave.h
 * @date 2016-07-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * I2C_SLAVE v4.0.14 - Configures a USIC channel to implement I2C slave functionality.
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
 *   disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-08-27:
 *     - Initial version for DAVEv4
 *
 * 2016-07-08:
 *     - Fixed incorrect case for an included header.<br>
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#ifndef I2C_SLAVE_H_
#define I2C_SLAVE_H_

#include <xmc_scu.h>
#include <xmc_gpio.h>
#include <xmc_i2c.h>

#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 2U)))
#error "I2C_SLAVE requires XMC Peripheral Library v2.0.2 or higher"
#endif

#include <DAVE_Common.h>
#include "i2c_slave_conf.h"
#if ((defined I2C_SLAVE_TX_DMA_USED) || (defined I2C_SLAVE_RX_DMA_USED))
#include "../GLOBAL_DMA/global_dma.h"
#endif

/**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#if ((defined I2C_SLAVE_TX_DMA_USED) || (defined I2C_SLAVE_RX_DMA_USED))
/*
 * @brief Represents the maximum data size for DMA transaction*/
#define I2C_SLAVE_DMA_MAXCOUNT (4095U)
#endif

/**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
/**
 * @ingroup I2C_SLAVE_enumerations
 * @{
 */

/**
 * @brief Enum to describe the possible status values, returned
 *  by I2C_SLAVE APIs.
 */
typedef enum I2C_SLAVE_STATUS
{
  I2C_SLAVE_STATUS_SUCCESS,        /**< Indicates APP initialization state successful */

  I2C_SLAVE_STATUS_FAILURE,        /**< Unknown error */

  I2C_SLAVE_STATUS_BUSY,           /**< I2C_SLAVE Busy */

  I2C_SLAVE_STATUS_BUFFER_INVALID, /**< Buffer provided or the buffer size is invalid*/

  I2C_SLAVE_STATUS_MODE_MISMATCH   /**< API invoked by a handle configured with different mode.
                     e.g, If I2C_SLAVE_StartTransmitDMA is invoked for an instance
                     which has transmit mode configured as "Interrupt", will
                     return this status.*/

} I2C_SLAVE_STATUS_t;

/**
 * @brief Enum to represent the direction of data transfer
 */
typedef enum I2C_SLAVE_DIRECTION
{
  I2C_SLAVE_DIRECTION_TRANSMIT = 0U,   /**< Direction indicates transmit */
  I2C_SLAVE_DIRECTION_RECEIVE = 1U     /**< Direction indicates receive */
} I2C_SLAVE_DIRECTION_t;

/**
 * @brief Enum used to identify the transfer type used for either transmit or receive function.
 */
typedef enum I2C_SLAVE_TRANSFER_MODE
{
  I2C_SLAVE_TRANSFER_MODE_INTERRUPT,  /**< Implement data transmit or receive using interrupts */
  I2C_SLAVE_TRANSFER_MODE_DMA,        /**< Implement data transmit or receive using DMA */
  I2C_SLAVE_TRANSFER_MODE_DIRECT      /**< This configuration exposes signals for external APP connection */
}I2C_SLAVE_TRANSFER_MODE_t;

/**
 * @brief Function pointer used for callback function
 */
typedef void (*I2C_SLAVE_cbhandler)(void);
/**
 * @brief Function pointer used for initialization function
 */
typedef I2C_SLAVE_STATUS_t (*I2C_SLAVE_init_handler)(void);

/**
 * @}
 */

/**
 * @ingroup I2C_SLAVE_datastructures
 * @{
 */

/**
 * @brief Structure for pin configuration.
 */
typedef struct I2C_SLAVE_PIN_CONFIG
{
  XMC_GPIO_PORT_t *const port;            /**< Pointer to the GPIO port base address */
  const XMC_GPIO_CONFIG_t *const config;  /**< Pin configuration structure */
  const uint8_t pin;                      /**< Pin number in the port*/
} I2C_SLAVE_PIN_CONFIG_t;

#if (defined(I2C_SLAVE_TX_DMA_USED) || defined(I2C_SLAVE_RX_DMA_USED))
/**
 * @brief Structure for DMA configuration.
 */
typedef struct I2C_SLAVE_DMA_CONFIG
{
  const XMC_DMA_CH_CONFIG_t * dma_ch_config;   /**< Pointer to the DMA channel configuration.*/
  uint8_t dma_channel;                         /**< DMA channel number */
}I2C_SLAVE_DMA_CONFIG_t;
#endif

/**
 * @brief Structure for holding the configuration parameters of I2C channel.
 */
typedef struct I2C_SLAVE_CONFIG
{
   const XMC_I2C_CH_CONFIG_t *channel_config;             /**< Basic I2C configuration from the GUI with baud*/
#if (defined I2C_SLAVE_TX_DMA_USED) || (defined I2C_SLAVE_RX_DMA_USED)
  GLOBAL_DMA_t * global_dma;                              /**< Global DMA handle */
#endif
#ifdef I2C_SLAVE_TX_DMA_USED
  const I2C_SLAVE_DMA_CONFIG_t * const transmit_dma_config; /**< Pointer to the DMA channel configuration used for data transmission.*/
#endif
#ifdef I2C_SLAVE_RX_DMA_USED
  const I2C_SLAVE_DMA_CONFIG_t * const receive_dma_config;  /**< Pointer to the DMA channel configuration used for data reception.*/
#endif
  I2C_SLAVE_init_handler fptr_i2c_slave_config;         /**< Function pointer to configure the MUX values*/
  I2C_SLAVE_cbhandler tx_cbhandler;            /**< Function pointer to hold the callback function pointer,
                                                           called when the transmission is complete*/
  I2C_SLAVE_cbhandler rx_cbhandler;            /**< Function pointer to hold the callback function pointer,
                                                           called when the reception is complete*/
  I2C_SLAVE_cbhandler read_request_cbhandler;  /**< Function pointer to hold the callback function pointer,
                                                             called when read request is detected.*/
  I2C_SLAVE_cbhandler error_cbhandler;         /**< Function pointer to hold the callback function pointer,
                                                           called when error is detected.*/
  I2C_SLAVE_TRANSFER_MODE_t transmit_mode;          /**< Mode used for transmitting data. Data can be transmitted using
                                                           interrupt, DMA or direct(using polling or external APP connection.)*/
  I2C_SLAVE_TRANSFER_MODE_t receive_mode;           /**< Mode used for receiving data. Data can be received using
                                                           interrupt, DMA or direct(using polling or external APP connection.)*/

  XMC_USIC_CH_FIFO_SIZE_t txFIFO_size;               /**< TxFIFO size configuration*/
  XMC_USIC_CH_FIFO_SIZE_t rxFIFO_size;               /**< RxFIFO size configuration*/
  uint8_t tx_sr;                               /**< Service request number assigned to transmit interrupt*/

} I2C_SLAVE_CONFIG_t;

/**
 * @brief Structure to hold the dynamic variables for the I2C_SLAVE communication.
 */
typedef struct I2C_SLAVE_RUNTIME
{
  uint8_t * tx_data;                     /**< Pointer to the transmit data buffer*/
  uint8_t * rx_data;                     /**< Pointer to the receive data buffer*/
  uint32_t tx_data_count;                /**< Number of bytes of data to be transmitted*/
  volatile uint32_t tx_data_index;       /**< Index to the byte to be transmitted next in the tx_data buffer*/
  uint32_t rx_data_count;                /**< Number of bytes of data to be received*/
  volatile uint32_t rx_data_index;       /**< Indicates the number of bytes currently available in the rx_data buffer*/
  volatile bool tx_busy;                 /**< Status flag to indicate busy when a transmission is assigned*/
  volatile bool rx_busy;                 /**< Status flag to indicate busy when a reception is assigned*/
} I2C_SLAVE_RUNTIME_t;


/**
 * @brief Handler structure with pointers to dynamic and static parameters.
 */
typedef struct I2C_SLAVE
{
  XMC_USIC_CH_t *channel;                    /**< USIC channel*/
  const I2C_SLAVE_CONFIG_t * const config;  /**< I2C configuration structure pointer*/
  I2C_SLAVE_RUNTIME_t * const runtime;      /**< Pointer to the structure holding all variables,
                                                   that can change at runtime*/
} I2C_SLAVE_t;

/**
 * @}
 */

/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif
/**
 * @ingroup I2C_SLAVE_apidoc
 * @{
 */
/**
 * @brief Get the I2C_SLAVE APP version.
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>
 *   //Description:
 *   //Checks if the I2C_SLAVE APP version is 4.0.x and if true, transmits 4 bytes of data to master.
 *   //For the data to be sent on bus, I2C master device should initiate data reception for this slave.
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     DAVE_APP_VERSION_t i2c_slave_version;
 *     uint8_t valid_data[] = {0x55, 0xaa, 0x5a, 0xa5};
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       i2c_slave_version = I2C_SLAVE_GetAppVersion();
 *       //Check if the version is 4.0.x, where x can be any value.
 *       if((i2c_slave_version.major == 4) &&
 *          (i2c_slave_version.minor == 0))
 *       {
 *         //Transmit if version is 4.0.x
 *         I2C_SLAVE_Transmit(&I2C_SLAVE_0, valid_data, sizeof(valid_data));
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *  @endcode
 */
DAVE_APP_VERSION_t I2C_SLAVE_GetAppVersion(void);

/**
 * @brief Initializes the USIC channel as I2C slave, based on the configuration made
 * in UI.
 * @param handle Pointer to static and dynamic attributes of APP configuration.
 * @return I2C_SLAVE_STATUS_t: Status of I2C_SLAVE driver initialization.\n
 *                    @ref I2C_SLAVE_STATUS_SUCCESS - on successful initialization.\n
 *                    @ref I2C_SLAVE_STATUS_FAILURE - if initialization fails.\n
 *                    @ref I2C_SLAVE_STATUS_BUSY - if I2C_SLAVE channel is busy.\n
 *
 * \par<b>Description:</b><br>
 * Initializes IO pins used for the I2C_SLAVE communication, configures
 * USIC registers based on the settings provided in the GUI.
 * It also configures selected interrupts, DMA channels and peripheral register bitfields.
 * <BR>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *         while(1U)
 *         {
 *         }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *  @endcode
 */
I2C_SLAVE_STATUS_t I2C_SLAVE_Init(const I2C_SLAVE_t *const handle);

/**
 * @brief Registers a request for transmitting data over I2C channel as a slave device.
 *
 * @param  handle  I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @param  data_ptr Pointer to data of type uint8_t.
 * @param  count Total no of words to be transmitted.\n
 * \b Range: minimum= 1, maximum= maximum supported by uint32_t.<br>
 * In DMA mode, a maximum of 4095 words can be transmitted in one attempt.
 *
 * @return  I2C_SLAVE_STATUS_t: Status of transmit request.\n
 *                        @ref I2C_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref I2C_SLAVE_STATUS_BUSY if a transmission is in progress.\n
 *                        @ref I2C_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0.\n
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 * \par<b>Description:</b><br>
 * Transmits data using the I2C channel as a slave device. Transmission is accomplished using the transmit mode
 * as configured in the UI. Data will be placed on the bus only when master provides clock.<br>
 * <b>Interrupt:</b><br>
 * The data transmission is accomplished using transmit interrupt. User can configure
 * a callback function in the APP UI. When the data is fully transmitted, the callback
 * function will be executed. If transmit FIFO is enabled, the trigger limit is set to 1.
 * So the transmit interrupt will be generated when all the data in FIFO is moved out of FIFO.
 * The APP handle's runtime structure is used to store the data pointer, count, data index
 * and status of transmission. This function only registers a data transmission request if
 * there is no active transmission in progress. Actual data transmission happens in the transmit
 * interrupt service routine. A trigger is generated for the transmit interrupt to start loading
 * the data to the transmit buffer. If transmit FIFO is configured, the data is filled into the FIFO.
 * Transmit interrupt will be generated subsequently when the transmit FIFO is empty. At this
 * point of time, if there is some more data to be transmitted, it is loaded to the FIFO again.
 * When FIFO is not enabled, data is transmitted one byte at a time. On transmission of each byte
 * an interrupt is generated and the next byte is transmitted in the interrupt service routine.
 * Callback function is executed when all the data bytes are transmitted.
 * If a callback function is not configured, user has to poll for the value of \a tx_busy flag of
 * the APP handle structure( \a handle->runtime->tx_busy ) to check for
 * the completion of data transmission.<br>
 * <b>DMA:</b><br>
 * A DMA channel is configured to provide data to the I2C channel transmit buffer. This removes the load
 * off the CPU. This API will only configure and enable the DMA channel by specifying the data buffer
 * and count of bytes to transmit. Rest is taken care without the CPU's intervention. User can configure
 * a callback function in the APP UI. When the transmission is complete, the callback function will be executed.
 * FIFO will not be used in DMA mode. Receive start interrupt is configured for triggering the
 * DMA channel. So each byte is transmitted in the background through the DMA channel.
 * If the callback function is not configured, \a handle->runtime->tx_busy flag can be checked to
 * verify if the transmission is complete.<br>
 * <b>Direct:</b><br>
 * Data will be transmitted using polling method. Status flags are used to check if data can be transmitted.<br>
 * <i><b> Note:</b> In Direct mode, the API blocks the CPU until the count of bytes requested is transmitted.
 * If this behavior is not desired, use other APIs like @ref I2C_SLAVE_TransmitByte, @ref I2C_SLAVE_GetProtocolStatus etc.</i>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Configure transmit mode as "Interrupt".
 *   //Description:
 *   //Transmits 10 bytes to I2C master device. Data will be transmitted on the bus only when
 *   //the master receives data from this slave.
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {0,1,2,3,4,5,6,7,8,9};
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       I2C_SLAVE_Transmit(&I2C_SLAVE_0, Send_Data, sizeof(Send_Data));
 *       //Wait for the transmission to finish
 *       while(I2C_SLAVE_0.runtime->tx_busy)
 *       {
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
I2C_SLAVE_STATUS_t I2C_SLAVE_Transmit(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size);

/**
 * @brief Registers a request for receiving data over I2C_SLAVE channel.
 *
 *
 * @param  handle  Pointer to I2C_SLAVE_t handle structure
 * @param data_ptr  Pointer to data of type uint8_t.
 * @param  count  Total no of bytes to be received.\n
 *                \b Range: minimum= 1, maximum= maximum value supported by type uint32_t.<br>
 *                In DMA mode, a maximum of 4095 words can be received in one attempt.
 *
 * @return  I2C_SLAVE_STATUS_t: Status for receive request.\n
 *                        @ref I2C_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref I2C_SLAVE_STATUS_BUSY if a reception is in progress.\n
 *                        @ref I2C_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0. \n
 *
 *
 * \par<b>Description:</b><br>
 * Data will be received from the I2C master synchronously. After the requested number of data bytes are received,
 * optionally, the user configured callback function will be executed.
 * Data reception is accomplished using the receive mode selected in the UI.<br>
 * <b>Interrupt:</b><br>
 * Based on the UI configuration, either standard receive buffer(RBUF) or receive FIFO(OUT) is used
 * for data reception. An interrupt is configured for reading received data from the bus. This function
 * only registers a request to receive a number of data bytes from a USIC channel. If FIFO is
 * configured for reception, the FIFO limit is dynamically configured to optimally utilize the
 * CPU load. Before starting data reception, the receive buffers are flushed. So only those data, received
 * after calling the API, will be placed in the user buffer.
 * When all the requested number of data bytes are received, the configured callback
 * function will be executed.
 * If a callback function is not configured, the user has to poll for the value of the
 * variable, \a handle->runtime->rx_busy, till its value changes to false. The value is updated to \a false when all the
 * requested number of data bytes are received.
 * <br>
 * <b>DMA:</b><br>
 * DMA mode is available only in XMC4x family of microcontrollers. In this mode, a DMA channel is
 * configured for receiving data from standard receive buffer(RBUF) to the user buffer. By calling
 * this API, the DMA channel destination address is configured to the user buffer and the channel is
 * enabled. Receive FIFO will not be used when the receive mode is DMA.
 * Before starting data reception, the receive buffers are flushed. So only those data, received
 * after calling the API, will be placed in the user buffer.
 * When all the requested number of data bytes are received, the configured callback
 * function will be executed.
 * If a callback function is not configured, the user has to poll for the value of the
 * variable, \a handle->runtime->rx_busy to be false. The value is updated to \a false when all the
 * requested number of data bytes are received.
 * <br>
 * <b>Direct:</b><br>
 * In Direct receive mode, neither interrupt nor DMA is used. The API polls
 * the receive flag to read the received data and waits for all the requested number of bytes to
 * be received. Based on FIFO configuration, either RBUF or OUT register is used for reading received
 * data. Before starting data reception, the receive buffers are flushed. So only those data, received
 * after calling the API, will be placed in the user buffer.<br>
 * <i><b> Note:</b> In Direct mode, the API blocks the CPU until the count of bytes requested is received.
 * If this behaviour is not desired, use other APIs like @ref I2C_SLAVE_GetReceivedByte, @ref I2C_SLAVE_GetProtocolStatus etc.</i>
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Configure receive mode and transmit mode as "Direct".
 *   //Description:
 *   //Receives 10 bytes from the I2C master and transmits the same to the master.
 *   //Data will be transmitted or received only when master provides the clock, read request and write request.
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint8_t ReadData[10];
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       //Start data reception and wait till 10 bytes are received.
 *       if(I2C_SLAVE_Receive(&I2C_SLAVE_0, ReadData, 10) == I2C_SLAVE_STATUS_SUCCESS)
 *       {
 *         //Transmit the received data to master.
 *         I2C_SLAVE_Transmit(&I2C_SLAVE_0, ReadData, 10);
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *  @endcode
 *
 */
I2C_SLAVE_STATUS_t I2C_SLAVE_Receive(const I2C_SLAVE_t * const handle, uint8_t * data, uint32_t count);
#ifdef I2C_SLAVE_TX_IRQ_USED
/**
 * @brief Registers a request for transmitting data over I2C channel as a slave device.
 *
 * @param  handle  I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @param  data_ptr Pointer to data of type uint8_t.
 * @param  count Total no of words to be transmitted.\n
 * \b Range: minimum= 1, maximum= maximum supported by uint32_t.
 *
 * @return  I2C_SLAVE_STATUS_t: Status of transmit request.\n
 *                        @ref I2C_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref I2C_SLAVE_STATUS_BUSY if a transmission is in progress.\n
 *                        @ref I2C_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0.\n
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 * \par<b>Description:</b><br>
 * The data transmission is accomplished using transmit interrupt. User can configure
 * a callback function in the APP UI. When the data is fully transmitted, the callback
 * function will be executed. If transmit FIFO is enabled, the trigger limit is set to 1.
 * So the transmit interrupt will be generated when all the data in FIFO is moved from FIFO.
 * The function uses APP handle's runtime structure to store the data pointer, count, data index
 * and status of transmission. This function only registers a data transmission request if
 * there is no active transmission in progress. Actual data transmission happens in the transmit
 * interrupt service routine. A trigger is generated for the transmit interrupt to start loading
 * the data. If transmit FIFO is configured, the data is filled into the FIFO.
 * Transmit interrupt will be generated next time when the transmit FIFO is empty. At this
 * point of time, if there is some more data to be transmitted, it will be loaded to the FIFO again.
 * When FIFO is not enabled, data will be transmitted one byte at a time. On transmission of each byte
 * an interrupt will be generated and the next byte is transmitted in the interrupt service routine.
 * Callback function will be executed when all the data words are transmitted.
 * If a callback function is not configured, user has to poll for the value of \a tx_busy flag of
 * the APP handle structure( \a handle->runtime->tx_busy ) to check for
 * the completion of data transmission.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode should be configured as "Interrupt".
 *   //Description:
 *   //Transmits 4 bytes data to the I2C master.
 *   //Data will be transmitted only when the I2C master receives data.
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {0x55, 0xaa, 0x5a, 0xa5};
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       //Initiate transmission of data
 *       if(I2C_SLAVE_StartTransmitIRQ(&I2C_SLAVE_0, Send_Data, sizeof(Send_Data)) == I2C_SLAVE_STATUS_SUCCESS)
 *       {
 *         //Wait till the data is transmitted.
 *         while(I2C_SLAVE_0.runtime->tx_busy)
 *         {
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
I2C_SLAVE_STATUS_t I2C_SLAVE_StartTransmitIRQ(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size);
#endif
#ifdef I2C_SLAVE_RX_IRQ_USED
/**
 * @brief Registers a request for receiving data over I2C channel as a slave device.
 *
 *
 * @param  handle  Pointer to I2C_SLAVE_t handle structure
 * @param data_ptr  Pointer to data of type uint8_t.
 * @param  count  Total no of words to be received.\n
 *                \b Range: minimum= 1, maximum= maximum value supported by type uint32_t.<br>
 *                In DMA mode, a maximum of 4095 words can be received in one attempt.
 *
 * @return  I2C_SLAVE_STATUS_t: Status for receive request.\n
 *                        @ref I2C_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref I2C_SLAVE_STATUS_BUSY if a reception is in progress.\n
 *                        @ref I2C_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0. \n
 *
 *
 * \par<b>Description:</b><br>
 * Data will be received from a master device synchronously. When the requested number of data words are received,
 * optionally, the user configured callback function will be executed.
 * Based on the GUI configuration, either standard receive buffer or receive FIFO is used
 * for data reception. An interrupt will be configured for reading received data from the register. This function
 * only registers a request to receive a number of data words from a USIC channel. If FIFO is
 * configured for data reception, the FIFO limit is dynamically configured to optimally utilize the
 * CPU load.  When all the requested count of data words are received, the configured callback
 * function will be executed.
 * If a callback function is not configured, the user has to poll for the value of the
 * variable, \a handle->runtime->rx_busy to be false. The value is updated to \a false when all the
 * requested number of data bytes are received.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode and receive mode should be configured as "Interrupt".
 *   //Description:
 *   //Receives 10 bytes of data from the I2C master and transmits the same.
 *   //Data will be transmitted or received only when master provides the clock, read request and write request.
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint8_t ReadData[10];
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       //Start reception of 10 bytes
 *       if(I2C_SLAVE_Receive(&I2C_SLAVE_0, ReadData, 10) == I2C_SLAVE_STATUS_SUCCESS)
 *       {
 *         //Wait till all bytes are received
 *         while(I2C_SLAVE_0.runtime->rx_busy)
 *         {
 *         }
 *         //Start transmission of 10 bytes
 *         I2C_SLAVE_Transmit(&I2C_SLAVE_0, ReadData, 10);
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *  @endcode
 *
 */
I2C_SLAVE_STATUS_t I2C_SLAVE_StartReceiveIRQ(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size);
#endif
#ifdef I2C_SLAVE_TX_DMA_USED
/**
 * @brief Registers a request for transmitting data over I2C channel as a slave device using DMA.
 *
 * @param  handle  I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @param  data_ptr Pointer to data of type uint8_t.
 * @param  count Total number of words to be transmitted.\n
 * \b Range: minimum= 1, maximum= 4095.
 *
 * @return  I2C_SLAVE_STATUS_t: Status of transmit request.\n
 *                        @ref I2C_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref I2C_SLAVE_STATUS_BUSY if a transmission is in progress.\n
 *                        @ref I2C_SLAVE_STATUS_MODE_MISMATCH if the handle is not configured for
 *                        DMA transmit mode. \n
 *                        @ref I2C_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0. \n
 *
 * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 * request is registered.
 *
 * \par<b>Description:</b><br>
 * The data transmission is accomplished using DMA. User can configure
 * a callback function in the APP UI. When the data is fully transmitted, the callback
 * function will be executed.
 * The function uses APP handle's runtime structure to store the status of transmission.
 * This function only registers a data transmission request, if
 * there is no active transmission in progress. Actual data transmission happens through DMA channel.
 * A maximum of 4095 bytes can be transmitted in one API call. This limit is because of the DMA single block size.
 * Callback function is executed when all the data bytes are transmitted.
 * If a callback function is not configured, user has to poll for the value of \a tx_busy flag of
 * the APP handle structure( \a handle->runtime->tx_busy ) to check for
 * the completion of data transmission.
 * If data more than the block size of 4095 have to be transmitted, user will have to transmit them using multiple calls to this API.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode should be configured as "DMA".
 *   //Description:
 *   //Transmits 4 bytes of data to the I2C master.
 *   //Data will be transmitted only when master provides the clock, read request.
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {0x55, 0xaa, 0x5a, 0xa5};
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       if(I2C_SLAVE_StartTransmitDMA(&I2C_SLAVE_0, Send_Data, sizeof(Send_Data)) == I2C_SLAVE_STATUS_SUCCESS)
 *       {
 *         while(I2C_SLAVE_0.runtime->tx_busy)
 *         {
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
I2C_SLAVE_STATUS_t I2C_SLAVE_StartTransmitDMA(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size);
#endif
#ifdef I2C_SLAVE_RX_DMA_USED
/**
 * @brief Registers a request for receiving data over I2C channel as a slave device using DMA.
 *
 *
 * @param  handle  Pointer to I2C_SLAVE_t handle structure
 * @param data_ptr  Pointer to data of type uint8_t.
 * @param  count  Total no of of words to be received.\n
 *                \b Range: minimum= 1, maximum= 4095.
 *
 * @return  I2C_SLAVE_STATUS_t: Status for receive request.\n
 *                        @ref I2C_SLAVE_STATUS_SUCCESS if the request is accepted.\n
 *                        @ref I2C_SLAVE_STATUS_BUSY if a reception is in progress.\n
 *                        @ref I2C_SLAVE_STATUS_MODE_MISMATCH if the handle is not configured for
 *                        DMA receive mode. \n
 *                        @ref I2C_SLAVE_STATUS_BUFFER_INVALID if the data_ptr is NULL or count is 0. \n
 *
 *
 * \par<b>Description:</b><br>
 * Data will be received from a master device synchronously. When the requested count of data words are received,
 * optionally, the user configured callback function will be executed.
 * This function only registers a request to receive a number of data bytes from a USIC channel.
 * When all the requested number of data bytes are received, the configured callback
 * function will be executed.
 * If a callback function is not configured, the user has to poll for the value of the
 * variable, \a handle->runtime->rx_busy to be false. The value is updated to \a false when all the
 * requested number of data bytes are received.
 * A maximum of 4095 bytes can be received in one API call. This limit is because of the DMA single block size.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre condition:
 *   //Transmit mode and receive mode should be configured to "DMA"
 *   //Description:
 *   //Receives 10 bytes of data from the I2C master and transmits the same.
 *   //Data will be transmitted or received only when master provides the clock, read request and write request.
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint8_t ReadData[10];
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       if(I2C_SLAVE_StartReceiveDMA(&I2C_SLAVE_0, ReadData, 10) == I2C_SLAVE_STATUS_SUCCESS)
 *       {
 *         while(I2C_SLAVE_0.runtime->rx_busy)
 *         {
 *         }
 *         I2C_SLAVE_StartTransmitDMA(&I2C_SLAVE_0, ReadData, 10);
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *  @endcode
 *
 */
I2C_SLAVE_STATUS_t I2C_SLAVE_StartReceiveDMA(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size);
#endif

#if (defined I2C_SLAVE_TX_IRQ_USED || defined I2C_SLAVE_TX_DMA_USED)
/**
 * @brief Aborts the ongoing data transmission.
 * @param handle  I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @return I2C_SLAVE_STATUS_t: Result of transmit abort request.\n
 *                       @ref I2C_SLAVE_STATUS_SUCCESS if the I2C_SLAVE channel transmission is stopped
 *                       successfully.\n
 *                       @ref I2C_SLAVE_STATUS_MODE_MISMATCH if transmit mode is Direct.\n
 *
 * \par<b>Description:</b><br>
 * If there is a transmission in progress, it will be stopped. If transmit FIFO is used,
 * the existing data will be flushed. After the transmission is stopped, user can start
 * a new transmission without delay. Abort request for transmit mode direct cannot be serviced since
 * the direct mode transmit API is a blocking call.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode should be configured as "Interrupt".
 *   //Description:
 *   //Initiates transmission of 13 bytes of data, aborts it immediately and transmits new data of 10 bytes.
 *   //I2C master should be able to receive 10 bytes of new data when the read request is sent.
 *   //Master should send the request after slave is started.
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {0x55, 0xaa, 0x5a, 0xa5, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99};
 *     uint8_t NewData[] = {0,1,2,3,4,5,6,7,8,9};
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       //Initiate transmission of 13 bytes
 *       I2C_SLAVE_Transmit(&I2C_SLAVE_0, Send_Data, sizeof(Send_Data));
 *
 *       if(I2C_SLAVE_0.runtime->tx_busy)
 *       {
 *         //Abort transmission
 *         if(I2C_SLAVE_AbortTransmit(&I2C_SLAVE_0) == I2C_SLAVE_STATUS_SUCCESS)
 *         {
 *           //Initiate transmission of new data of 10 bytes
 *           I2C_SLAVE_Transmit(&I2C_SLAVE_0, NewData, sizeof(NewData));
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
I2C_SLAVE_STATUS_t I2C_SLAVE_AbortTransmit(const I2C_SLAVE_t * const handle);
#endif

#if (defined I2C_SLAVE_RX_IRQ_USED || defined I2C_SLAVE_RX_DMA_USED)
/**
 * @brief Stops the active data reception sequence.
 * @param handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @return I2C_SLAVE_STATUS_t: Result of reception abort request.\n
 *                       @ref I2C_SLAVE_STATUS_SUCCESS if the I2C_SLAVE channel reception has
 *                       been stopped.\n
 *                       @ref I2C_SLAVE_STATUS_MODE_MISMATCH if receive mode is Direct.\n
 *
 * \par<b>Description:</b><br>
 * If a reception is in progress, it will be stopped. When a reception request
 * is active, user will not be able to place a new receive request till the active
 * reception is complete. This API can stop the progressing reception to make
 * a new receive request. Abort request for receive mode direct cannot be serviced since
 * the direct mode receive API is a blocking call.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Pre-condition:
 *   //Transmit mode and receive mode should be configured as "Interrupt".
 *   //Description:
 *   //Transmits a string of 27 bytes to I2C master.
 *   //Starts reception of 15 bytes.
 *   //Waits for receiving 1 byte from master, and checks if the received data is 0x55.
 *   //If the data is 0x55, aborts data reception and transmits the same data of 1 byte to master.
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = "Infineon DAVE application.";
 *     uint8_t Rec_Data[64];
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       //Transmit string of 27 bytes.
 *       I2C_SLAVE_Transmit(&I2C_SLAVE_0, Send_Data, sizeof(Send_Data));
 *       while(I2C_SLAVE_0.runtime->tx_busy);
 *
 *       //Start reception of 15 bytes
 *       I2C_SLAVE_Receive(&I2C_SLAVE_0, Rec_Data, 15);
 *
 *       //Wait till atleast 1 byte is received
 *       while(I2C_SLAVE_0.runtime->rx_data_index == 0);
 *       //Check if the received data is 0x55
 *       if(I2C_SLAVE_0.runtime->rx_data[0] == 0x55)
 *       {
 *         //Abort reception of data
 *         if(I2C_SLAVE_AbortReceive(&I2C_SLAVE_0) == I2C_SLAVE_STATUS_SUCCESS)
 *         {
 *           //Transmit the received byte.
 *           I2C_SLAVE_Transmit(&I2C_SLAVE_0, Rec_Data, 1);
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
I2C_SLAVE_STATUS_t I2C_SLAVE_AbortReceive(const I2C_SLAVE_t * const handle);
#endif

/**
 * @brief Provides the status of protocol events.
 *
 * @param handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @param protocol_status Event whose status is to be read.\n
 *             \b Range: Use type @ref XMC_I2C_SLAVE_CH_STATUS_FLAG_t for input. Multiple events can
 *             be combined using \a OR operation.
 *
 * @return uint32_t: Status of selected protocol events read from PSR_SSCMode register.\n
 * \b Range: Use type @ref XMC_I2C_SLAVE_CH_STATUS_FLAG_t for comparing the return value
 * with event bitmasks. Status of multiple events can be checked by combining enum
 * values using \a OR operation while comparing.
 *
 * \par<b>Description:</b><br>
 * Reads the protocol status bits from the register PSR_SSCMode and compares the values with
 * the input value of selected events. Returns the masked value of selected events with the status register value.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *  //Pre-condition:
 *  //Configure transmit mode "Direct"
 *  //Description:
 *  //Waits for read request from master and transmits 10 bytes of data.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint8_t Send_Data[] = {0,1,2,3,4,5,6,7,8,9};
 *
 *   init_status = DAVE_Init();
 *
 *   if(init_status == DAVE_STATUS_SUCCESS)
 *   {
 *
 *     while(1U)
 *     {
 *        //Wait for read request from I2C master
 *        if(I2C_SLAVE_GetFlagStatus(&I2C_SLAVE_0, XMC_I2C_CH_STATUS_FLAG_SLAVE_READ_REQUESTED))
 *        {
 *           I2C_SLAVE_ClearFlag(&I2C_SLAVE_0, XMC_I2C_CH_STATUS_FLAG_SLAVE_READ_REQUESTED);
 *           //Start transmission of 10 bytes to master
 *           if(I2C_SLAVE_Transmit(&I2C_SLAVE_0, Send_Data, 10) == I2C_SLAVE_STATUS_SUCCESS)
 *           {
 *             //Wait for transmission of 10 bytes
 *             while(I2C_SLAVE_0.runtime->tx_busy)
 *             {
 *             }
 *           }
 *        }
 *     }
 *   }
 *   else
 *   {
 *
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 * @endcode
 *
 */
__STATIC_INLINE uint32_t I2C_SLAVE_GetFlagStatus(const I2C_SLAVE_t * const handle, uint32_t flag)
{
  XMC_ASSERT("I2C_SLAVE_GetFlagStatus: invalid handle", (handle != NULL))
  return (XMC_I2C_CH_GetStatusFlag(handle->channel) & flag);
}

/**
 * @brief Clears the event status in the register(PSR_SSCMode).
 *
 * @param handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @param protocol_status Event whose status is to be cleared.\n
 *             \b Range: Use type @ref XMC_I2C_SLAVE_CH_STATUS_FLAG_t for input. Multiple events can
 *             be combined using \a OR operation.
 * @return None
 *
 * \par<b>Description:</b><br>
 * Clears a given protocol event flag bit using the PSCR register.
 * This function is an inline wrapper for the API provided by xmc_uart.h file.
 * The user should mask the input value based on the events to be cleared.
 * <BR>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *  //Pre-condition:
 *  //Configure transmit mode "Direct"
 *  //Description:
 *  //Waits for read request from master and transmits 10 bytes of data.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint8_t Send_Data[] = {0,1,2,3,4,5,6,7,8,9};
 *
 *   init_status = DAVE_Init();
 *
 *   if(init_status == DAVE_STATUS_SUCCESS)
 *   {
 *
 *     while(1U)
 *     {
 *        //Wait for read request from I2C master
 *        if(I2C_SLAVE_GetFlagStatus(&I2C_SLAVE_0, XMC_I2C_CH_STATUS_FLAG_SLAVE_READ_REQUESTED))
 *        {
 *           I2C_SLAVE_ClearFlag(&I2C_SLAVE_0, XMC_I2C_CH_STATUS_FLAG_SLAVE_READ_REQUESTED);
 *           //Start transmission of 10 bytes to master
 *           if(I2C_SLAVE_Transmit(&I2C_SLAVE_0, Send_Data, 10) == I2C_SLAVE_STATUS_SUCCESS)
 *           {
 *             //Wait for transmission of 10 bytes
 *             while(I2C_SLAVE_0.runtime->tx_busy)
 *             {
 *             }
 *           }
 *        }
 *     }
 *   }
 *   else
 *   {
 *
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 * @endcode
 *
 */
__STATIC_INLINE void I2C_SLAVE_ClearFlag(const I2C_SLAVE_t * const handle, uint32_t flag)
{
  XMC_ASSERT("I2C_SLAVE_ClearFlag: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, flag);
}

/**
 * @brief Provides the received data from receive buffer.
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @return uint16_t: Data read from RBUF.\n
 *
 * \par<b>Description:</b><br>
 * This can be used in receive mode "Direct" to read the received data.
 * If receive FIFO is not configured, function reads the value of RBUF register.
 * Otherwise it reads the data from OUTR register.
 * User can poll for receive event or configure an interrupt by connecting the
 * external INTERRUPT APP to receive event signals. This API can be used inside the ISR to read the received data.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Precondition:
 *   //Configure transmit mode and receive mode as "Direct"
 *   //Description:
 *   //Receives 10 bytes from the I2C master and retransmits the same data to master.
 *   //Data will be transmitted or received only when master provides the clock, read request and write request.
 *
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint16_t Rec_Data[10];
 *     uint32_t data_index = 0;
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *        //Configure receive FIFO to generate event when FIFO is filled with 10 bytes
 *        I2C_SLAVE_SetRXFIFOTriggerLimit(&I2C_SLAVE_0, 9);
 *
 *        //Wait for the FIFO to receive 10 bytes
 *        data_index = 0;
 *        while(!(I2C_SLAVE_GetRXFIFOStatus(&I2C_SLAVE_0) &
 *             (XMC_USIC_CH_RXFIFO_EVENT_STANDARD | XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE)))
 *        {
 *        }
 *
 *        while(I2C_SLAVE_IsRXFIFOEmpty(&I2C_SLAVE_0) == false)
 *        {
 *          Rec_Data[data_index] = I2C_SLAVE_GetReceivedByte(&I2C_SLAVE_0);
 *          data_index++;
 *          if(data_index == 10)
 *          {
 *            break;
 *          }
 *
 *        }
 *
 *        //Transmit the received data
 *        data_index = 0;
 *        while(data_index < 10)
 *        {
 *           I2C_SLAVE_TransmitByte(&I2C_SLAVE_0,Rec_Data[data_index]);
 *           data_index++;
 *
 *           //Wait for transmit buffer interrupt to fill it again with remaining data
 *           while((I2C_SLAVE_GetTXFIFOStatus(&I2C_SLAVE_0) & XMC_USIC_CH_TXFIFO_EVENT_STANDARD) == 0);
 *           I2C_SLAVE_ClearTXFIFOStatus(&I2C_SLAVE_0, XMC_USIC_CH_TXFIFO_EVENT_STANDARD);
 *        }
 *
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
__STATIC_INLINE uint8_t I2C_SLAVE_GetReceivedByte(const I2C_SLAVE_t * const handle)
{
  XMC_ASSERT("I2C_SLAVE_GetReceivedByte: invalid handle", (handle != NULL))
  return (XMC_I2C_CH_GetReceivedData(handle->channel));
}

/**
 * @brief Transmits a word of data.
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t \n
 * @param data Data to be transmitted.\n
 * @return None\n
 *
 * \par<b>Description:</b><br>
 * Transmits a word of data through the I2C channel as a slave device.
 * If transmit FIFO is configured, the data is placed in the IN[0] register of the USIC channel.
 * If transmit FIFO is not configured, API waits for the TBUF to be free and then places the data in the TBUF register.
 * User can poll for receive event or configure interrupt by connecting an
 * external INTERRUPT APP. This API can be used inside the ISR to read the received data.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Precondition:
 *   //Configure transmit mode and receive mode as "Direct"
 *   //Description:
 *   //Receives 10 bytes from the I2C master and retransmits the same data to master.
 *   //Data will be transmitted or received only when master provides the clock, read request and write request.
 *
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint16_t Rec_Data[10];
 *     uint32_t data_index = 0;
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *        //Configure receive FIFO to generate event when FIFO is filled with 10 bytes
 *        I2C_SLAVE_SetRXFIFOTriggerLimit(&I2C_SLAVE_0, 9);
 *
 *        //Wait for the FIFO to receive 10 bytes
 *        data_index = 0;
 *        while(!(I2C_SLAVE_GetRXFIFOStatus(&I2C_SLAVE_0) &
 *             (XMC_USIC_CH_RXFIFO_EVENT_STANDARD | XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE)))
 *        {
 *        }
 *
 *        while(I2C_SLAVE_IsRXFIFOEmpty(&I2C_SLAVE_0) == false)
 *        {
 *          Rec_Data[data_index] = I2C_SLAVE_GetReceivedByte(&I2C_SLAVE_0);
 *          data_index++;
 *          if(data_index == 10)
 *          {
 *            break;
 *          }
 *
 *        }
 *
 *        //Transmit the received data
 *        data_index = 0;
 *        while(data_index < 10)
 *        {
 *           I2C_SLAVE_TransmitByte(&I2C_SLAVE_0,Rec_Data[data_index]);
 *           data_index++;
 *
 *           //Wait for transmit buffer interrupt to fill it again with remaining data
 *           while((I2C_SLAVE_GetTXFIFOStatus(&I2C_SLAVE_0) & XMC_USIC_CH_TXFIFO_EVENT_STANDARD) == 0);
 *           I2C_SLAVE_ClearTXFIFOStatus(&I2C_SLAVE_0, XMC_USIC_CH_TXFIFO_EVENT_STANDARD);
 *        }
 *
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
__STATIC_INLINE void I2C_SLAVE_TransmitByte(const I2C_SLAVE_t * const handle, uint8_t data)
{
  XMC_ASSERT("I2C_SLAVE_TransmitByte: invalid handle", (handle != NULL))
  XMC_I2C_CH_SlaveTransmit(handle->channel, data);
}

/**
 * @brief Enables the selected protocol events for interrupt generation.
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @param  events Protocol events to be enabled for interrupt generation. \n
 *         \bRange: Use type \aXMC_I2C_SLAVE_CH_EVENT_t to select the event. Multiple events can be
 *         combined using the bitwise OR operation.\n
 * @return None\n
 *
 * \par<b>Description:</b><br>
 * Enables the events by configuring CCR or PCR register based on the event.
 * When the event is enabled, an interrupt can be generated on occurrence of the event.
 * The API can be used for protocol events when the callback functions are not registered.
 * The API will be useful in 'Direct' mode.
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 * // Precondition:
 * // Add INTERRUPT APP and connect the I2C_SLAVE APP protocol interrupt signal to the INTERRUPT APP
 * // irq signal. Provide the callback function name in INTERRUPT APP as "ProtocolInterrupt".
 * // Disable receive FIFO
 * // Description:
 *  //Generates the data lost interrupt when the master transmits more than 2 bytes of data to this slave.
 *  //When the data lost event occurs the interrupt handler "ProtocolInterrupt" will be executed.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *
 *   status = DAVE_Init();
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *   //Enable generation of interrupt when data lost event occurs
 *   I2C_SLAVE_EnableEvent(&I2C_SLAVE_0, XMC_I2C_CH_EVENT_DATA_LOST);
 *   while(1U)
 *   {
 *   }
 * }
 * //Interrupt handler
 * void ProtocolInterrupt()
 * {
 *   //Indicates that the data received from the master is lost since the receive buffer is unread.
 * }
 * @endcode
 */
__STATIC_INLINE void I2C_SLAVE_EnableEvent(const I2C_SLAVE_t * const handle, uint32_t events)
{
  XMC_ASSERT("I2C_SLAVE_EnableEvent: invalid handle", (handle != NULL))
  XMC_I2C_CH_EnableEvent(handle->channel, events);
}

/**
 * @brief Disables selected events from generating interrupt.
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @param  events Events to be disabled from generating interrupt. \n
 *         \bRange: Use type \aXMC_I2C_SLAVE_CH_EVENT_t to select the event. Multiple events can be
 *         combined using the bitwise OR operation.\n
 * @return None
 *
 * \par<b>Description:</b><br>
 * Events are disabled by clearing their respective bits in either CCR or PCR register.
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 * // Precondition:
 * // Add INTERRUPT APP and connect the I2C_SLAVE APP protocol interrupt signal to the INTERRUPT APP
 * // irq signal. Provide the callback function name in INTERRUPT APP as "ProtocolInterrupt".
 * //
 * // Description: The example configures protocol interrupt for data loss detection.
 * // When the data loss interrupt occurs, the receive FIFO is cleared. After the receive FIFO
 * // is cleared, the channel can receive few bytes till the FIFO gets filled.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *
 *   status = DAVE_Init();
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *   //Enable generation of interrupt when data lost event occurs
 *   I2C_SLAVE_EnableEvent(&I2C_SLAVE_0, XMC_I2C_CH_EVENT_DATA_LOST);
 *   while(1U)
 *   {
 *   }
 * }
 * void ProtocolInterrupt()
 * {
 *   I2C_SLAVE_DisableEvent(&I2C_SLAVE_0, XMC_I2C_CH_EVENT_DATA_LOST);
 *   //Clear receive FIFO so that data will be received.
 *   XMC_USIC_CH_RXFIFO_Flush(I2C_SLAVE_0.channel);
 *   I2C_SLAVE_EnableEvent(&I2C_SLAVE_0, XMC_I2C_CH_EVENT_DATA_LOST);
 * }
 * @endcode
 *
 */
__STATIC_INLINE void I2C_SLAVE_DisableEvent(const I2C_SLAVE_t * const handle, uint32_t events)
{
  XMC_ASSERT("I2C_SLAVE_DisableEvent: invalid handle", (handle != NULL))
  XMC_I2C_CH_DisableEvent(handle->channel, events);
}

/**
 * @brief Configures trigger limit for the transmit FIFO.
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @param  limit Value of transmit FIFO filling level, transition below which the interrupt should be generated.\n
 *               \bRange: 0 to transmit FIFO size.\n
 *               e.g, If transmit FIFO size is 16, and limit is configured as 8, FIFO standard transmit buffer interrupt
 *               will be generated when the FIFO filling level drops from 8 to 7.\n
 *
 * @return None\n
 *
 * \par<b>Description:</b><br>
 * Transmit FIFO trigger limit is configured by setting its value in the TBCTR register.
 * Transmit FIFO is configured to generate interrupt when the FIFO filling level drops
 * below the trigger limit.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Precondition:
 *   //Configure transmit mode as "Direct", enable transmit FIFO
 *   //Add an instance of the INTERRUPT APP and connect the I2C_SLAVE event_fifo_transmit_buffer_interrupt
 *   //signal to the INTERRUPT sr_irq signal.
 *   //Provide the callback function name in INTERRUPT APP as "tx_cb"
 *   //Description:
 *   //Executes the callback function "tx_cb" when every data byte moves from the transmit FIFO to TBUF.
 *   //Data will be transmitted only when I2C master sends read request.
 *
 *   uint8_t Send_Data[] = {0,1,2,3,4,5,6,7,8,9,0xa,0xb,0xc,0xd,0xe,0xf};
 *   uint16_t data_index = 0;
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint16_t Rec_Data[10];
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       //Configure transmit interrupt generation when the transmit FIFO is empty
 *       I2C_SLAVE_SetTXFIFOTriggerLimit(&I2C_SLAVE_0, 1);
 *       //Transmit first byte to FIFO
 *       I2C_SLAVE_TransmitByte(&I2C_SLAVE_0,Send_Data[data_index]);
 *       data_index++;
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *
 *  //INTERRUPT APP callback function
 *  void tx_cb()
 *  {
 *    if(data_index < sizeof(Send_Data))
 *    {
 *      //Transmit the subsequent byte
 *      I2C_SLAVE_TransmitByte(&I2C_SLAVE_0,Send_Data[data_index]);
 *      data_index++;
 *    }
 *  }
 * @endcode
 */
__STATIC_INLINE void I2C_SLAVE_SetTXFIFOTriggerLimit(const I2C_SLAVE_t * const handle, uint8_t limit)
{
  XMC_ASSERT("I2C_SLAVE_SetTXFIFOTriggerLimit: invalid handle", (handle != NULL))
  XMC_USIC_CH_TXFIFO_SetSizeTriggerLimit(handle->channel, handle->config->txFIFO_size, (uint32_t)limit);
}

/**
 * @brief Configures trigger limit for the receive FIFO.
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @param  limit Value of receive FIFO filling level, transition above which the interrupt should be generated.\n
 *               \bRange: 0 to receive FIFO size.\n
 *               e.g, If receive FIFO size is 16, and limit is configured as 8, FIFO receive buffer interrupt
 *               will be generated when the FIFO filling level rises from 8 to 9.\n
 *
 * @return None\n
 *
 * \par<b>Description:</b><br>
 * Receive FIFO trigger limit is configured by setting its value in the RBCTR register.
 * Receive FIFO is configured to generate interrupt when the FIFO filling level rises
 * above the trigger limit.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *   //Precondition:
 *   //Configure receive mode as "Direct", enable receive FIFO.
 *   //Add an instance of the INTERRUPT APP and connect the I2C_SLAVE event_fifo_receive_buffer_interrupt
 *   //signal to the INTERRUPT sr_irq signal.
 *   //Provide the callback function name in INTERRUPT APP as "rx_cb"
 *   //Description:
 *   //Executes the callback function "rx_cb" when 10 bytes are received from I2C master.
 *
 *
 *   uint16_t Rec_Data[10];
 *   uint32_t data_index = 0;
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       //Configure receive interrupt generation when 10 bytes are received
 *       I2C_SLAVE_SetRXFIFOTriggerLimit(&I2C_SLAVE_0, 9);
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 *
 *  //INTERRUPT APP callback function
 *  void rx_cb()
 *  {
 *    while((data_index < 10) && (!XMC_USIC_CH_RXFIFO_IsEmpty(I2C_SLAVE_0.channel)))
 *    {
 *      //Read data from the FIFO
 *      Rec_Data[data_index] = I2C_SLAVE_GetReceivedByte(&I2C_SLAVE_0);
 *      data_index++;
 *    }
 *  }
 * @endcode
 */
__STATIC_INLINE void I2C_SLAVE_SetRXFIFOTriggerLimit(const I2C_SLAVE_t * const handle, uint8_t limit)
{
  XMC_ASSERT("I2C_SLAVE_SetRXFIFOTriggerLimit: invalid handle", (handle != NULL))
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel, handle->config->rxFIFO_size, (uint32_t)limit);
}

/**
 * @brief Checks if the transmit FIFO is full.
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 *
 * @return bool Status of transmit FIFO filling level.
 *              \bRange: \atrue- if transmit FIFO is full.<br>
 *                       \afalse- if transmit FIFO is not full.<br>
 * \par<b>Description:</b><br>
 * Checks the status using the register TRBSR. Can be used while filling
 * data to the transmit FIFO.
 *
 * Example Usage:
 * @code
 *  #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *  // Precondition:
 *  // Transmit mode should be "Direct", enable transmit FIFO
 *  //Description:
 *  //Transmits 10 bytes to I2C master.
 *  //Data will be transmitted only when the I2C master sends read request to this slave.
 *
 * uint8_t send_data[] = {0,1,2,3,4,5,6,7,8,9};
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint32_t loc_index;
 *
 *   status = DAVE_Init();           // Initialization of DAVE APPs
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *   //Transmit 10 bytes
 *   for(loc_index = 0; loc_index < sizeof(send_data); loc_index++)
 *   {
 *     //Wait when Tx FIFO is full
 *     while(I2C_SLAVE_IsTXFIFOFull(&I2C_SLAVE_0))
 *     {
 *     }
 *     I2C_SLAVE_TransmitByte(&I2C_SLAVE_0, send_data[loc_index]);
 *   }
 *   while(1U)
 *   {
 *   }
 * }
 * @endcode
 */
__STATIC_INLINE bool I2C_SLAVE_IsTXFIFOFull(const I2C_SLAVE_t* const handle)
{
  XMC_ASSERT("I2C_SLAVE_IsTXFIFOFull:handle invalid", (handle != NULL))
  return XMC_USIC_CH_TXFIFO_IsFull(handle->channel);
}

/**
 * @brief Checks if the receive FIFO is empty.
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 *
 * @return bool Status of receive FIFO filling level.
 *              \bRange: \atrue- if receive FIFO is empty.<br>
 *                       \afalse- if receive FIFO still has data.<br>
 * \par<b>Description:</b><br>
 * Checks the status using the register TRBSR. Can be used while reading
 * data from the receive FIFO.
 *
 * Example Usage:
 * @code
 *  #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaration)
 *
 *  // Precondition:
 *  // Receive mode should be "Direct", enable receive FIFO
 *  //
 *  // Description:
 *  // Receives 10 bytes and transmits the received 10 bytes.
 *  //Data will be received only when I2C master transmits data to this slave.
 *
 * uint8_t rec_data[10];
 * int main(void)
 * {
 *   DAVE_STATUS_t status;
 *   uint32_t loc_index;
 *
 *   status = DAVE_Init();           // Initialization of DAVE APPs
 *
 *   if(status == DAVE_STATUS_FAILURE)
 *   {
 *     XMC_DEBUG("DAVE APPs initialization failed\n");
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *   for(loc_index = 0; loc_index < sizeof(rec_data); loc_index++)
 *   {
 *     //Wait when Rx FIFO is empty
 *     while(I2C_SLAVE_IsRXFIFOEmpty(&I2C_SLAVE_0))
 *     {
 *     }
 *     rec_data[loc_index] = I2C_SLAVE_GetReceivedByte(&I2C_SLAVE_0);
 *   }
 *   I2C_SLAVE_Transmit(&I2C_SLAVE_0, rec_data, sizeof(rec_data));
 *   while(1U)
 *   {
 *   }
 * }
 * @endcode
 */
__STATIC_INLINE bool I2C_SLAVE_IsRXFIFOEmpty(const I2C_SLAVE_t* const handle)
{
  XMC_ASSERT("I2C_SLAVE_IsRXFIFOEmpty:handle invalid", (handle != NULL))
  return XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel);
}

/**
 * @brief Gets the status of event flags related to transmit FIFO.
 *
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 *
 * @return uint32_t: Status of standard transmit buffer event, transmit buffer
 * error event in their bit positions in TRBSR register.\n
 * \b Range: Use type @ref XMC_USIC_CH_TXFIFO_EVENT_t for event bitmasks. Multiple events' status
 * can be combined for comparison using \a OR operation.
 *
 * \par<b>Description:</b><br>
 * It provides the status of standard transmit buffer event, transmit buffer
 * error event.
 * Function masks the TRBSR register with the bitmask of STBI,
 * and TBERI flags. User has to mask the bits of interest before checking
 * the status.
 *
 *
 */
__STATIC_INLINE uint32_t I2C_SLAVE_GetTXFIFOStatus(const I2C_SLAVE_t* const handle)
{
  XMC_ASSERT("I2C_SLAVE_GetTXFIFOStatus:handle invalid", (handle != NULL))
  return XMC_USIC_CH_TXFIFO_GetEvent(handle->channel);
}

/**
 * @brief Gets the status of event flags related to receive FIFO.
 *
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 *
 * @return uint32_t: Status of standard receive buffer event, alternative receive buffer
 * event and receive buffer error event in their bit positions in TRBSR register.\n
 * \b Range: Use type @ref XMC_USIC_CH_RXFIFO_EVENT_t for event bitmasks. Multiple events' status
 * can be combined for comparison using \a OR operation.
 *
 * \par<b>Description:</b><br>
 * It provides the status of standard receive buffer event, alternative receive buffer
 * event and receive buffer error event.
 * Function masks the TRBSR register with the bitmask of SRBI,
 * ARBI and RBERI flags. User has to mask the bits of interest before checking
 * the status.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *   //Pre-condition:
 *   //Configure receive mode "Direct", enable receive FIFO.
 *   //Description:
 *   //Receives 16 bytes from the I2C master and when the 16 bytes are received in the FIFO, receive FIFO standard event
 *   //will be generated. By default receive FIFO is configured to generate event when the FIFO is full.
 *   //Received data will be copied to the buffer ReadData.
 *   //Data will be received only when the I2C master transmits data to this slave.
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint16_t ReadData[16];
 *     uint32_t data_index = 0;
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       while(1U)
 *       {
 *         //Check if receive FIFO standard event is generated.
 *         if(I2C_SLAVE_GetRXFIFOStatus(&I2C_SLAVE_0) & XMC_USIC_CH_RXFIFO_EVENT_STANDARD)
 *         {
 *           //Clear the event
 *           I2C_SLAVE_ClearRXFIFOStatus(&I2C_SLAVE_0, XMC_USIC_CH_RXFIFO_EVENT_STANDARD);
 *           //Read data to local buffer till FIFO gets empty.
 *           while(!I2C_SLAVE_IsRXFIFOEmpty(&I2C_SLAVE_0))
 *           {
 *             ReadData[data_index] = I2C_SLAVE_GetReceivedByte(&I2C_SLAVE_0);
 *             data_index++;
 *             //Avoid local buffer overflow
 *             data_index = data_index % 16;
 *           }
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
__STATIC_INLINE uint32_t I2C_SLAVE_GetRXFIFOStatus(const I2C_SLAVE_t* const handle)
{
  XMC_ASSERT("I2C_SLAVE_GetRXFIFOStatus:handle invalid", (handle != NULL))
  return XMC_USIC_CH_RXFIFO_GetEvent(handle->channel);
}

/**
 * @brief Function clears the specified FIFO event flag related to
 * transmit FIFO.
 *
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @param  flag Value with event bits at their bit positions in TRBSR register
 *             to be cleared.\n
 *             \b Range: Use type @ref XMC_USIC_CH_TXFIFO_EVENT_t. Multiple events can be
 *             combined using \a OR operation.
 *
 * @return    None
 *
 * \par<b>Description:</b><br>
 * Function clears a status bit in TRBSR register using the TRBSCR register.
 * But the function does not mask the input value with the bit positions restricted
 * to transmit FIFO status bits. User should ensure that the input value is appropriately
 * masked.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *   //Pre-condition:
 *   //Configure transmit mode "Direct", enable transmit FIFO.
 *
 *   //Description:
 *   //Transmits 10 bytes of data to I2C master.
 *   //Data will be transmitted only when I2C master sends read request and clock.
 *
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint8_t Send_Data[] = {0,1,2,3,4,5,6,7,8,9};
 *     uint32_t data_index = 0;
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *        while(data_index < sizeof(Send_Data))
 *        {
 *           I2C_SLAVE_TransmitByte(&I2C_SLAVE_0,Send_Data[data_index]);
 *           data_index++;
 *
 *           //Wait for FIFO transmit standar buffer interrupt to fill it again with remaining data
 *           while((I2C_SLAVE_GetTXFIFOStatus(&I2C_SLAVE_0) & XMC_USIC_CH_TXFIFO_EVENT_STANDARD) == 0);
 *           I2C_SLAVE_ClearTXFIFOStatus(&I2C_SLAVE_0, XMC_USIC_CH_TXFIFO_EVENT_STANDARD);
 *        }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
__STATIC_INLINE void I2C_SLAVE_ClearTXFIFOStatus(const I2C_SLAVE_t* const handle, const uint32_t flag)
{
  XMC_ASSERT("I2C_SLAVE_ClearTXFIFOStatus:handle invalid", (handle != NULL))
  XMC_USIC_CH_TXFIFO_ClearEvent(handle->channel, flag);
}
/**
 * @brief Function clears the specified FIFO event flag related to
 * receive FIFO. It should be used to clear the status of standard
 * receive buffer interrupt, alternative receive buffer interupt and
 * receive buffer error interrupt flags.
 *
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 * @param  flag Value with event bits at the bit positions in TRBSR register
 *             to be cleared.\n
 *             \b Range: Use type @ref XMC_USIC_CH_RXFIFO_EVENT_t for providing events.
 *             Multiple events can be input by using \a OR operation.
 *
 * @return    None
 *
 * \par<b>Description:</b><br>
 * Function clears a status bit in TRBSR using the TRBSCR register.
 * The function does not mask the input value to clear only receive buffer
 * events. So user should appropriately mask the input value before calling
 * the function.
 *
 * Example Usage:
 * @code
 *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 *   //Pre-condition:
 *   //Configure receive mode "Direct", enable receive FIFO.
 *   //Description:
 *   //Receives 16 bytes from the I2C master and when the 16 bytes are received in the FIFO, receive FIFO standard event
 *   //will be generated. By default receive FIFO is configured to generate event when the FIFO is full.
 *   //Received data will be copied to the buffer ReadData.
 *   //Data will be received only when the I2C master transmits data to this slave.
 *   int main(void)
 *   {
 *     I2C_SLAVE_STATUS_t init_status;
 *     uint16_t ReadData[16];
 *     uint32_t data_index = 0;
 *
 *     init_status = (I2C_SLAVE_STATUS_t)I2C_SLAVE_Init(&I2C_SLAVE_0);
 *     if(init_status == I2C_SLAVE_STATUS_SUCCESS)
 *     {
 *       while(1U)
 *       {
 *         //Check if receive FIFO standard event is generated.
 *         if(I2C_SLAVE_GetRXFIFOStatus(&I2C_SLAVE_0) & XMC_USIC_CH_RXFIFO_EVENT_STANDARD)
 *         {
 *           //Clear the event
 *           I2C_SLAVE_ClearRXFIFOStatus(&I2C_SLAVE_0, XMC_USIC_CH_RXFIFO_EVENT_STANDARD);
 *           //Read data to local buffer till FIFO gets empty.
 *           while(!I2C_SLAVE_IsRXFIFOEmpty(&I2C_SLAVE_0))
 *           {
 *             ReadData[data_index] = I2C_SLAVE_GetReceivedByte(&I2C_SLAVE_0);
 *             data_index++;
 *             //Avoid local buffer overflow
 *             data_index = data_index % 16;
 *           }
 *         }
 *       }
 *     }
 *     else
 *     {
 *      XMC_DEBUG("main: Application initialization failed");
 *      while(1U)
 *      {
 *      }
 *     }
 *      return 1U;
 *  }
 * @endcode
 *
 */
__STATIC_INLINE void I2C_SLAVE_ClearRXFIFOStatus(const I2C_SLAVE_t* const handle, const uint32_t flag)
{
  XMC_ASSERT("I2C_SLAVE_ClearRXFIFOStatus:handle invalid", (handle != NULL))
  XMC_USIC_CH_RXFIFO_ClearEvent(handle->channel, flag);
}

/**
 * @brief Function provides the status of data transmission.
 *
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 *
 * @return bool Status of data transmission.<br>
 *  \b Range: \b true - Data transmission is in progress.<br>
 *            \b false - No transmission in progress.<br>
 *
 * \par<b>Description:</b><br>
 * Function provides the status of APP handle member I2C_SLAVE.runtime->tx_busy. This flag will be true
 * if a transmission is in progress and it will change to false when the transmission has finished.<br>
 * <i>Note: Even after the state changes from true to false, one word might still be present in the shift register.<br>
 * It is recommended to provide some wait time before stopping the channel after transmission.</i>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 * //Pre-condition:
 * //Configure transmit mode "Interrupt" or "DMA"
 * //Description:
 * //The example below, transmits data to the I2C master.
 * //Transmits 10 bytes to the I2C master.
 * //For the communication to start, master should receive 10 bytes.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint8_t SendData[10] = {0,1,2,3,4,5,6,7,8,9};
 *
 *   init_status = DAVE_Init();
 *
 *   if(init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     I2C_SLAVE_Transmit(&I2C_SLAVE_0, SendData, 10);
 *     //Wait for transmission of 10 words
 *     while(I2C_SLAVE_IsTxBusy(&I2C_SLAVE_0))
 *     {
 *     }
 *     while(1)
 *     {
 *     }
 *   }
 *   else
 *   {
 *
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *
 *   return 1U;
 * }
 *
 * @endcode
 *
 */
__STATIC_INLINE bool I2C_SLAVE_IsTxBusy(const I2C_SLAVE_t* const handle)
{
  XMC_ASSERT("I2C_SLAVE_IsTxBusy:handle invalid", (handle != NULL))
  return handle->runtime->tx_busy;
}

/**
 * @brief Function provides the status of data reception.
 *
 *
 * @param  handle I2C_SLAVE APP handle pointer of type @ref I2C_SLAVE_t
 *
 * @return bool Status of data reception.<br>
 *  \b Range: \b true - Data reception is in progress.<br>
 *            \b false - No reception in progress.<br>
 *
 * \par<b>Description:</b><br>
 * Function provides the status of APP handle member I2C_SLAVE.runtime->rx_busy. This flag will be true
 * if a reception is in progress and it will change to false when the reception of given count is finished.<br>
 * The API can be used after executing \a I2C_SLAVE_Receive() API to check if the
 * reception is finished.<br>
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 * //Pre-condition:
 * //Configure receive mode "Interrupt" or "DMA"
 * //Description:
 * //The example below, receives data from the master.
 * //Receive 10 bytes from the I2C master.
 * //For the communication to start, master should transmit 10 bytes.
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint8_t ReceiveData[10];
 *
 *   init_status = DAVE_Init();
 *
 *   if(init_status == DAVE_STATUS_SUCCESS)
 *   {
 *
 *     I2C_SLAVE_Receive(&I2C_SLAVE_0, ReceiveData, 10);
 *     //Wait for transmission of 10 words
 *     while(I2C_SLAVE_IsRxBusy(&I2C_SLAVE_0))
 *     {
 *     }
 *     while(1U)
 *     {
 *     }
 *   }
 *   else
 *   {
 *
 *    XMC_DEBUG("main: Application initialization failed");
 *    while(1U)
 *    {
 *    }
 *   }
 *
 *   return 1U;
 * }
 *
 * @endcode
 *
 */
__STATIC_INLINE bool I2C_SLAVE_IsRxBusy(const I2C_SLAVE_t* const handle)
{
  XMC_ASSERT("I2C_SLAVE_IsRxBusy:handle invalid", (handle != NULL))
  return handle->runtime->rx_busy;
}

#ifdef __cplusplus
}
#endif


#include "i2c_slave_extern.h"
#endif
