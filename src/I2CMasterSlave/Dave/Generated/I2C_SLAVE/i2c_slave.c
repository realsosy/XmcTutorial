/**
 * @file i2c_slave.c
 * @date 2016-07-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * I2C_SLAVE v4.0.14 - Configures a USIC channel to implement I2C slave functionality.
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-08-27:
 *     - Initial version for DAVEv4
 *
 * 2016-07-08:
 *     - Fixed incorrect case for an included header.<br>
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "i2c_slave.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
#ifdef I2C_SLAVE_TX_IRQ_USED
void I2C_SLAVE_lTransmitHandler(const I2C_SLAVE_t * const handle);
#endif
#ifdef I2C_SLAVE_RX_IRQ_USED
void I2C_SLAVE_lReceiveHandler(const I2C_SLAVE_t * const handle);
#endif
#ifdef I2C_SLAVE_ERR_IRQ_USED
void I2C_SLAVE_lProtocolHandler(const I2C_SLAVE_t * const handle);
#endif
#ifdef I2C_SLAVE_RX_IRQ_USED
static void I2C_SLAVE_lReconfigureRxFIFO(const I2C_SLAVE_t * const handle, uint32_t count);
#endif
#ifdef I2C_SLAVE_TX_DIRECT_USED
static I2C_SLAVE_STATUS_t I2C_SLAVE_lStartTransmitPolling(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size);
#endif
#ifdef I2C_SLAVE_RX_DIRECT_USED
static I2C_SLAVE_STATUS_t I2C_SLAVE_lStartReceivePolling(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size);
#endif
/**********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/

/*
 * @brief API to retrieve the version of the I2C_SLAVE APP.
 *
 * @return DAVE_APP_VERSION_t Structure containing major version, minor version
 *         and patch version.
 */
DAVE_APP_VERSION_t I2C_SLAVE_GetAppVersion()
{
  DAVE_APP_VERSION_t version;

  version.major = I2C_SLAVE_MAJOR_VERSION;
  version.minor = I2C_SLAVE_MINOR_VERSION;
  version.patch = I2C_SLAVE_PATCH_VERSION;

  return version;
}

/*
 * @brief Function to initialize the USIC Channel with GUI configured values.
 *
 * @param[in]  handle I2C_SLAVE APP handle pointer of type I2C_SLAVE_t*
 *
 * @return  I2C_SLAVE_STATUS_t
 *          I2C_SLAVE_SUCCESS: for successful I2C_SLAVE initialization.<BR>
 *          I2C_SLAVE_STATUS_FAILURE  : If I2C_SLAVE initialization fails.<BR>
 *
 */
I2C_SLAVE_STATUS_t I2C_SLAVE_Init(const I2C_SLAVE_t *const handle)
{
  I2C_SLAVE_STATUS_t status = I2C_SLAVE_STATUS_SUCCESS;
  XMC_ASSERT("I2C_SLAVE_Init : I2C_SLAVE APP handle invalid", (((handle != NULL)&&
      (handle->config != NULL)) &&((handle->config->fptr_i2c_slave_config != NULL)&&
      (handle->runtime != NULL))))
  /*Initialize the multiplexers required for I2C_SLAVE configuration*/
  if (status == I2C_SLAVE_STATUS_SUCCESS)
  {
    status = handle->config->fptr_i2c_slave_config();
  }

  return status;
}

/* Function to transmit the data as a slave device */
I2C_SLAVE_STATUS_t I2C_SLAVE_Transmit(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t count)
{
  I2C_SLAVE_STATUS_t status = I2C_SLAVE_STATUS_MODE_MISMATCH;

  switch(handle->config->transmit_mode)
  {
#ifdef I2C_SLAVE_TX_IRQ_USED
  case I2C_SLAVE_TRANSFER_MODE_INTERRUPT:
    status = I2C_SLAVE_StartTransmitIRQ(handle, data, count);
    break;
#endif
#ifdef I2C_SLAVE_TX_DMA_USED
  case I2C_SLAVE_TRANSFER_MODE_DMA:
    status = I2C_SLAVE_StartTransmitDMA(handle, data, count);
    break;
#endif
#ifdef I2C_SLAVE_TX_DIRECT_USED
  case I2C_SLAVE_TRANSFER_MODE_DIRECT:
    status = I2C_SLAVE_STATUS_BUFFER_INVALID;
    if((data != NULL)&&(count > 0U))
    {
      status = I2C_SLAVE_STATUS_BUSY;
      if(handle->runtime->tx_busy == false)
      {
        status = I2C_SLAVE_lStartTransmitPolling(handle, data, count);
      }
    }
    break;
#endif
  default:
    break;
  }

  return (status);
} /* end of function */


/*Function to receive data from a master device*/
I2C_SLAVE_STATUS_t I2C_SLAVE_Receive(const I2C_SLAVE_t * const handle, uint8_t * data, uint32_t count)
{
  I2C_SLAVE_STATUS_t status = I2C_SLAVE_STATUS_MODE_MISMATCH;

  switch(handle->config->receive_mode)
  {
#ifdef I2C_SLAVE_RX_IRQ_USED
  case I2C_SLAVE_TRANSFER_MODE_INTERRUPT:
    status = I2C_SLAVE_StartReceiveIRQ(handle, data, count);
    break;
#endif
#ifdef I2C_SLAVE_RX_DMA_USED
  case I2C_SLAVE_TRANSFER_MODE_DMA:
    status = I2C_SLAVE_StartReceiveDMA(handle, data, count);
    break;
#endif
#ifdef I2C_SLAVE_RX_DIRECT_USED
  case I2C_SLAVE_TRANSFER_MODE_DIRECT:
    status = I2C_SLAVE_STATUS_BUFFER_INVALID;
    if((data != NULL)&&(count > 0U))
    {
      status = I2C_SLAVE_STATUS_BUSY;
      if(handle->runtime->rx_busy == false)
      {
        status = I2C_SLAVE_lStartReceivePolling(handle, data, count);
      }
    }
    break;
#endif
  default:
    break;
  }

  return (status);
}

#ifdef I2C_SLAVE_TX_IRQ_USED
/*Interrupt based data transmit function*/
I2C_SLAVE_STATUS_t I2C_SLAVE_StartTransmitIRQ(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size)
{
  I2C_SLAVE_STATUS_t status = I2C_SLAVE_STATUS_MODE_MISMATCH;
  I2C_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const I2C_SLAVE_CONFIG_t * ptr_config = handle->config;

  XMC_ASSERT("I2C_SLAVE_StartTransmitIRQ : I2C_SLAVE APP handle invalid", (((handle != NULL)&&
      (ptr_config != NULL)) && (ptr_runtime != NULL)))

  if(ptr_config->transmit_mode == I2C_SLAVE_TRANSFER_MODE_INTERRUPT)
  {
    status = I2C_SLAVE_STATUS_BUFFER_INVALID;
    if((data != NULL) && (size > 0U))
    {
      status = I2C_SLAVE_STATUS_BUSY;
      if(ptr_runtime->tx_busy == false)
      {
        if(ptr_config->txFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
        {
          XMC_USIC_CH_TXFIFO_Flush(handle->channel);
          XMC_USIC_CH_TXFIFO_EnableEvent(handle->channel, (uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
        }
        else
        {
          XMC_I2C_CH_EnableEvent(handle->channel, (uint32_t)XMC_I2C_CH_EVENT_TRANSMIT_BUFFER);
        }
        ptr_runtime->tx_busy = true;
        ptr_runtime->tx_data = data;
        ptr_runtime->tx_data_count = size;
        ptr_runtime->tx_data_index = 0U;
        XMC_USIC_CH_TriggerServiceRequest(handle->channel, (uint32_t)ptr_config->tx_sr);
      }
    }
  }
  return status;
}
#endif

#ifdef I2C_SLAVE_RX_IRQ_USED
/*Interrupt based data reception function*/
I2C_SLAVE_STATUS_t I2C_SLAVE_StartReceiveIRQ(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size)
{
  I2C_SLAVE_STATUS_t status = I2C_SLAVE_STATUS_MODE_MISMATCH;
  I2C_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const I2C_SLAVE_CONFIG_t * ptr_config = handle->config;

  XMC_ASSERT("I2C_SLAVE_StartReceiveIRQ : I2C_SLAVE APP handle invalid", (((handle != NULL)&&
      (ptr_config != NULL)) && (ptr_runtime != NULL)))

  if(ptr_config->receive_mode == I2C_SLAVE_TRANSFER_MODE_INTERRUPT)
  {
    status = I2C_SLAVE_STATUS_BUFFER_INVALID;
    if((data != NULL) && (size > 0U))
    {
      status = I2C_SLAVE_STATUS_BUSY;
      if(ptr_runtime->rx_busy == false)
      {
        ptr_runtime->rx_busy = true;
        ptr_runtime->rx_data = data;
        ptr_runtime->rx_data_count = size;
        ptr_runtime->rx_data_index = 0U;

        /*Flush receive buffer*/
        (void)XMC_I2C_CH_GetReceivedData(handle->channel);
        (void)XMC_I2C_CH_GetReceivedData(handle->channel);

        if(ptr_config->rxFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
        {
          XMC_USIC_CH_RXFIFO_Flush(handle->channel);
          I2C_SLAVE_lReconfigureRxFIFO(handle, size);
          XMC_USIC_CH_RXFIFO_EnableEvent(handle->channel, ((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE | (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD));
        }
        else
        {
          XMC_I2C_CH_EnableEvent(handle->channel, ((uint32_t)XMC_I2C_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_I2C_CH_EVENT_ALTERNATIVE_RECEIVE));
        }
      }
    }
  }
  return status;
}

static void I2C_SLAVE_lReconfigureRxFIFO(const I2C_SLAVE_t * const handle, uint32_t count)
{
  uint32_t fifo_size;
  uint32_t ret_limit_val = 0U;

  /*Get FIFO size in bytes*/
  fifo_size = (uint32_t)(0x01UL << (uint8_t)(handle->config->rxFIFO_size));
  /*If data size is more than FIFO size, configure the limit to the FIFO size*/
  if (count < fifo_size)
  {
    ret_limit_val = (uint32_t)(count - 1U);
  }
  else
  {
    ret_limit_val = (uint32_t)(fifo_size - 1U);
  }
  /*Set the limit value*/
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel,
        handle->config->rxFIFO_size, ret_limit_val);
}
#endif

#ifdef I2C_SLAVE_TX_DMA_USED
I2C_SLAVE_STATUS_t I2C_SLAVE_StartTransmitDMA(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size)
{
  I2C_SLAVE_STATUS_t status = I2C_SLAVE_STATUS_MODE_MISMATCH;
  I2C_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const GLOBAL_DMA_t * ptr_dma_config = handle->config->global_dma;
  const I2C_SLAVE_DMA_CONFIG_t * ptr_tx_dma_config = handle->config->transmit_dma_config;

  XMC_ASSERT("I2C_SLAVE_StartTransmitDMA : I2C_SLAVE APP handle invalid", (((handle != NULL)&&
      (ptr_dma_config != NULL) && (ptr_tx_dma_config != NULL)) && (ptr_runtime != NULL)))

  if(handle->config->transmit_mode == I2C_SLAVE_TRANSFER_MODE_DMA)
  {
    status = I2C_SLAVE_STATUS_BUFFER_INVALID;
    if((data != NULL) && (size > 0U) && (size <= I2C_SLAVE_DMA_MAXCOUNT))
    {
      status = I2C_SLAVE_STATUS_BUSY;
      if(ptr_runtime->tx_busy == false)
      {
        XMC_USIC_CH_SetTransmitBufferStatus(handle->channel, XMC_USIC_CH_TBUF_STATUS_SET_IDLE);
        if(size > 1U)
        {
          ptr_runtime->tx_busy = true;
          /*Set the address of second byte*/
          XMC_DMA_CH_SetSourceAddress((XMC_DMA_t *)ptr_dma_config->dma, ptr_tx_dma_config->dma_channel, (uint32_t)(data + 1U));
          XMC_DMA_CH_SetDestinationAddress((XMC_DMA_t *)ptr_dma_config->dma, ptr_tx_dma_config->dma_channel, (uint32_t)(&handle->channel->TBUF[0U]));
          XMC_DMA_CH_SetBlockSize((XMC_DMA_t *)ptr_dma_config->dma, ptr_tx_dma_config->dma_channel, size - 1U);
          XMC_I2C_CH_EnableEvent(handle->channel, (uint32_t)XMC_I2C_CH_EVENT_TRANSMIT_BUFFER);
          XMC_DMA_CH_Enable((XMC_DMA_t *)ptr_dma_config->dma, ptr_tx_dma_config->dma_channel);
        }
        /*Transmit first byte separately and set the TDF code*/
        I2C_SLAVE_TransmitByte(handle, data[0U]);

        /*Excute callback function if size is 1*/
        if((size == 1U) && (handle->config->tx_cbhandler != NULL))
        {
          handle->config->tx_cbhandler();
        }
        status = I2C_SLAVE_STATUS_SUCCESS;
      }
    }
  }
  return status;
}
#endif

#ifdef I2C_SLAVE_RX_DMA_USED
I2C_SLAVE_STATUS_t I2C_SLAVE_StartReceiveDMA(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size)
{
  I2C_SLAVE_STATUS_t status = I2C_SLAVE_STATUS_MODE_MISMATCH;
  I2C_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const GLOBAL_DMA_t * ptr_dma_config = handle->config->global_dma;
  const I2C_SLAVE_DMA_CONFIG_t * ptr_rx_dma_config = handle->config->receive_dma_config;

  XMC_ASSERT("I2C_SLAVE_StartReceiveDMA : I2C_SLAVE APP handle invalid", (((handle != NULL)&&
      (ptr_dma_config != NULL) && (ptr_rx_dma_config != NULL)) && (ptr_runtime != NULL)))

  if(handle->config->receive_mode == I2C_SLAVE_TRANSFER_MODE_DMA)
  {
    status = I2C_SLAVE_STATUS_BUFFER_INVALID;
    if((data != NULL) && (size > 0U) && (size <= I2C_SLAVE_DMA_MAXCOUNT))
    {
      status = I2C_SLAVE_STATUS_BUSY;
      if(ptr_runtime->rx_busy == false)
      {
        XMC_DMA_CH_SetSourceAddress((XMC_DMA_t *)ptr_dma_config->dma, ptr_rx_dma_config->dma_channel, (uint32_t)(&handle->channel->RBUF));
        XMC_DMA_CH_SetDestinationAddress((XMC_DMA_t *)ptr_dma_config->dma, ptr_rx_dma_config->dma_channel, (uint32_t)data);
        XMC_DMA_CH_SetBlockSize((XMC_DMA_t *)ptr_dma_config->dma, ptr_rx_dma_config->dma_channel, size);
        ptr_runtime->rx_busy = true;
        XMC_I2C_CH_EnableEvent(handle->channel, ((uint32_t)XMC_I2C_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_I2C_CH_EVENT_ALTERNATIVE_RECEIVE));
        XMC_DMA_CH_Enable((XMC_DMA_t *)ptr_dma_config->dma, ptr_rx_dma_config->dma_channel);
        status = I2C_SLAVE_STATUS_SUCCESS;
      }
    }
  }
  return status;
}
#endif

/*API for aborting transmission*/
I2C_SLAVE_STATUS_t I2C_SLAVE_AbortTransmit(const I2C_SLAVE_t * const handle)
{
  I2C_SLAVE_STATUS_t status = I2C_SLAVE_STATUS_MODE_MISMATCH;
  I2C_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const I2C_SLAVE_CONFIG_t * ptr_config = handle->config;
  XMC_ASSERT("I2C_SLAVE_AbortTransmit : I2C_SLAVE APP handle invalid", (((handle != NULL)&&
      (ptr_config != NULL)) && (handle->runtime != NULL)))

  switch(ptr_config->transmit_mode)
  {
#ifdef I2C_SLAVE_TX_IRQ_USED
  case I2C_SLAVE_TRANSFER_MODE_INTERRUPT:
    if(ptr_config->txFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
    }
    else
    {
      XMC_I2C_CH_DisableEvent(handle->channel, (uint32_t)XMC_I2C_CH_EVENT_TRANSMIT_BUFFER);
    }
    break;
#endif
#ifdef I2C_SLAVE_TX_DMA_USED
  case I2C_SLAVE_TRANSFER_MODE_DMA:
    /*Disable DMA channel*/
    XMC_DMA_CH_Disable(ptr_config->global_dma->dma, ptr_config->transmit_dma_config->dma_channel);
    XMC_I2C_CH_DisableEvent(handle->channel, (uint32_t)XMC_I2C_CH_EVENT_TRANSMIT_BUFFER);
    break;
#endif
  default:
    break;
  }

  if(ptr_config->transmit_mode != I2C_SLAVE_TRANSFER_MODE_DIRECT)
  {
    ptr_runtime->tx_busy = false;
    ptr_runtime->tx_data = NULL;
    ptr_runtime->tx_data_count = 0U;
    ptr_runtime->tx_data_index = 0U;
    status = I2C_SLAVE_STATUS_SUCCESS;
  }
  return status;
}

/*API for aborting transmission*/
I2C_SLAVE_STATUS_t I2C_SLAVE_AbortReceive(const I2C_SLAVE_t * const handle)
{
  I2C_SLAVE_STATUS_t status = I2C_SLAVE_STATUS_MODE_MISMATCH;
  I2C_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const I2C_SLAVE_CONFIG_t * ptr_config = handle->config;
  XMC_ASSERT("I2C_SLAVE_AbortReceive : I2C_SLAVE APP handle invalid", (((handle != NULL)&&
      (ptr_config != NULL)) && (handle->runtime != NULL)))

  switch(ptr_config->receive_mode)
  {
#ifdef I2C_SLAVE_RX_IRQ_USED
  case I2C_SLAVE_TRANSFER_MODE_INTERRUPT:
    if(ptr_config->rxFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
        ((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD | (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
    }
    else
    {
      XMC_I2C_CH_DisableEvent(handle->channel,
              ((uint32_t)XMC_I2C_CH_EVENT_ALTERNATIVE_RECEIVE | (uint32_t)XMC_I2C_CH_EVENT_STANDARD_RECEIVE));
    }
    break;
#endif
#ifdef I2C_SLAVE_RX_DMA_USED
  case I2C_SLAVE_TRANSFER_MODE_DMA:
    /*Disable DMA channel*/
    XMC_DMA_CH_Disable(ptr_config->global_dma->dma, ptr_config->receive_dma_config->dma_channel);
    XMC_I2C_CH_DisableEvent(handle->channel,
            ((uint32_t)XMC_I2C_CH_EVENT_ALTERNATIVE_RECEIVE | (uint32_t)XMC_I2C_CH_EVENT_STANDARD_RECEIVE));
    break;
#endif
  default:
    break;
  }

  if(ptr_config->receive_mode != I2C_SLAVE_TRANSFER_MODE_DIRECT)
  {
    ptr_runtime->rx_busy = false;
    ptr_runtime->rx_data = NULL;
    ptr_runtime->rx_data_count = 0U;
    ptr_runtime->rx_data_index = 0U;
    status = I2C_SLAVE_STATUS_SUCCESS;
  }
  return status;
}

#ifdef I2C_SLAVE_TX_DIRECT_USED
static I2C_SLAVE_STATUS_t I2C_SLAVE_lStartTransmitPolling(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size)
{
  I2C_SLAVE_STATUS_t status = I2C_SLAVE_STATUS_BUFFER_INVALID;
  I2C_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const I2C_SLAVE_CONFIG_t * ptr_config = handle->config;

  /*Flush transmit buffer*/
  ptr_runtime->tx_data_index = 0U;
  ptr_runtime->tx_data_count = size;
  ptr_runtime->tx_data = data;

  XMC_USIC_CH_SetTransmitBufferStatus(handle->channel, XMC_USIC_CH_TBUF_STATUS_SET_IDLE);
  if(ptr_config->txFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    XMC_USIC_CH_TXFIFO_Flush(handle->channel);
  }

  XMC_I2C_CH_SlaveTransmit(handle->channel, ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
  ptr_runtime->tx_data_index++;
  while(ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
  {
    if(ptr_config->txFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      while(XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == true)
      {
      }
    }
    XMC_I2C_CH_SlaveTransmit(handle->channel, ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
    ptr_runtime->tx_data_index++;
  }
  if(ptr_config->txFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    while(XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel) == false)
    {
    }
  }
  while(XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
  {
  }
  status = I2C_SLAVE_STATUS_SUCCESS;
  return status;
}
#endif

#ifdef I2C_SLAVE_RX_DIRECT_USED
static I2C_SLAVE_STATUS_t I2C_SLAVE_lStartReceivePolling(const I2C_SLAVE_t * const handle, uint8_t *data, const uint32_t size)
{
  I2C_SLAVE_STATUS_t status = I2C_SLAVE_STATUS_BUFFER_INVALID;
  I2C_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const I2C_SLAVE_CONFIG_t * ptr_config = handle->config;

  ptr_runtime->rx_data_index = 0U;
  ptr_runtime->rx_data_count = size;
  ptr_runtime->rx_data = data;

  /*Flush receive buffer*/
  (void)XMC_I2C_CH_GetReceivedData(handle->channel);
  (void)XMC_I2C_CH_GetReceivedData(handle->channel);

  if(ptr_config->rxFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    XMC_USIC_CH_RXFIFO_Flush(handle->channel);
  }
  else
  {
    XMC_I2C_CH_ClearStatusFlag(handle->channel,
        ((uint32_t)XMC_I2C_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_I2C_CH_EVENT_ALTERNATIVE_RECEIVE));
  }

  while(ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
  {
    if(ptr_config->rxFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      while(XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == true)
      {
      }
    }
    else
    {
      while((XMC_I2C_CH_GetStatusFlag(handle->channel) &
          ((uint32_t)XMC_I2C_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_I2C_CH_EVENT_ALTERNATIVE_RECEIVE)) == 0U)
      {
      }
      XMC_I2C_CH_ClearStatusFlag(handle->channel,
          ((uint32_t)XMC_I2C_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_I2C_CH_EVENT_ALTERNATIVE_RECEIVE));
    }
    ptr_runtime->rx_data[ptr_runtime->rx_data_index] = XMC_I2C_CH_GetReceivedData(handle->channel);
    ptr_runtime->rx_data_index++;
  }
  status = I2C_SLAVE_STATUS_SUCCESS;
  return status;
}
#endif

#ifdef I2C_SLAVE_TX_IRQ_USED
void I2C_SLAVE_lTransmitHandler(const I2C_SLAVE_t * const handle)
{
  I2C_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const I2C_SLAVE_CONFIG_t * ptr_config = handle->config;
  if(ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
  {
    if(ptr_config->txFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      while(XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
      {
        if(ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
        {
          XMC_I2C_CH_SlaveTransmit(handle->channel, ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
          ptr_runtime->tx_data_index++;
        }
        else
        {
          break;
        }
      }
    }
    else
    {
      XMC_I2C_CH_SlaveTransmit(handle->channel, ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
      ptr_runtime->tx_data_index++;
    }
  }
  else
  {
    if(XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel))
    {
      while(XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
      {}
      if(ptr_config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
      {
        XMC_I2C_CH_DisableEvent(handle->channel, (uint32_t)XMC_I2C_CH_EVENT_TRANSMIT_BUFFER);
      }
      else
      {
        XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
      }
      if(ptr_config->tx_cbhandler != NULL)
      {
        ptr_config->tx_cbhandler();
      }
      ptr_runtime->tx_busy = false;
    }
  }
}
#endif

#ifdef I2C_SLAVE_RX_IRQ_USED
void I2C_SLAVE_lReceiveHandler(const I2C_SLAVE_t * const handle)
{
  I2C_SLAVE_RUNTIME_t * ptr_runtime = handle->runtime;
  const I2C_SLAVE_CONFIG_t * ptr_config = handle->config;

  if(ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
  {
    if(ptr_config->rxFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      while((XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false) &&
            (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count))
      {
        ptr_runtime->rx_data[ptr_runtime->rx_data_index] = XMC_I2C_CH_GetReceivedData(handle->channel);
        ptr_runtime->rx_data_index++;
      }
      if(ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
      {
        I2C_SLAVE_lReconfigureRxFIFO(handle, (ptr_runtime->rx_data_count - ptr_runtime->rx_data_index));
      }
    }
    else
    {
      ptr_runtime->rx_data[ptr_runtime->rx_data_index] = XMC_I2C_CH_GetReceivedData(handle->channel);
      ptr_runtime->rx_data_index++;
    }
  }
  if((ptr_runtime->rx_busy) && (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count))
  {
    if(ptr_config->rxFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
    {
      XMC_I2C_CH_DisableEvent(handle->channel,
          ((uint32_t)XMC_I2C_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_I2C_CH_EVENT_ALTERNATIVE_RECEIVE));
    }
    else
    {
      XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
          ((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD | (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
    }
    if(ptr_config->rx_cbhandler != NULL)
    {
      ptr_config->rx_cbhandler();
    }
    ptr_runtime->rx_busy = false;
  }
}
#endif

#ifdef I2C_SLAVE_ERR_IRQ_USED
void I2C_SLAVE_lProtocolHandler(const I2C_SLAVE_t * const handle)
{
  const I2C_SLAVE_CONFIG_t * ptr_config = handle->config;
  uint32_t flag_status = XMC_I2C_CH_GetStatusFlag(handle->channel);
  if(flag_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_SLAVE_READ_REQUESTED)
  {
    if(ptr_config->read_request_cbhandler != NULL)
    {
      ptr_config->read_request_cbhandler();
    }
  }
  else if(flag_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR)
  {
    if(ptr_config->error_cbhandler != NULL)
    {
      ptr_config->error_cbhandler();
    }
  }
  else
  {

  }
}
#endif
