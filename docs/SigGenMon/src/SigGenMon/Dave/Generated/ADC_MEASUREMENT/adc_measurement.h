/**
 * @file adc_measurement.h
 * @date 2016-08-18
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * ADC_MEASUREMENT v4.1.22 - Incorporates analog to digital conversion for the required measurements.
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version for DAVEv4.<BR>
 *
 * 2015-02-19:
 *     - Added GetResult APIs for XMC1100 devices.
 *
 * 2015-05-14:
 *     - Optimized the Manifest.<BR>
 *     - Modified the structure ADC_MEASUREMENT_channel_t to ADC_MEASUREMENT_CHANNEL_t.<BR>
 *
 * 2015-06-26:
 *     - Added input class resource consumption.<BR>
 *
  * 2015-07-09:
 *     - Documentation updated.<BR>
 *
 * 2015-07-31:
 *     - Updated the APP to support new devices.<BR>
 *
 * 2015-10-01:
 *     - Updated the APP to support the interrupt control in XMC14.<BR>
 *
 * 2015-10-08:
 *     - Added support for XMC4700/XMC4800 devices.<BR>
 *
 * 2015-10-20:
 *     - Documentation updated.<BR>
 *
 * 2015-12-03:
 *     - Added support for XMC4300 device.<BR>
 *
 * 2016-02-09:
 *     - Updated the APP for the minimum required ANALOG_IO APP version.<BR>
 *
 * 2016-03-18:
 *     - Maximum number of channels for XMC41/42 increased to 9.<BR>
 *     - Added Post calibration time for XMC1x series in Total conversion Time.<BR>
 *     - Fixed the ADC_MEASUREMENT_Init() for ANALOG_IO initialization.<BR>
 *     - For XMC1100 series only: Deprecated the API ADC_MEASUREMENT_GetResult() and
 *       ADC_MEASUREMENT_GetDetailedResult().<BR>
 *     - For XMC1100 series only: Added new API ADC_MEASUREMENT_GetGlobalResult() and
 *       ADC_MEASUREMENT_GetGlobalDetailedResult().<BR>
 *
 * 2016-08-18:
 *     - Minimum sample time at low frequencies changed to incorporate Errata ADC_AI.H006 and ADC_AI.H007.
 *
 * @endcond
 *
 */

/*CODE_BLOCK_BEGIN*/
#ifndef ADC_MEASUREMENT_H
#define ADC_MEASUREMENT_H


/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/

#include "GLOBAL_ADC/global_adc.h"
#include "adc_measurement_conf.h"

 /**********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "ADC_MEASUREMENT requires XMC Peripheral Library v2.0.0 or higher"
#endif

#if defined (__GNUC__) || defined (__CC_ARM)
#define ADC_MEASUREMENT_DEPRECATED   __attribute__((deprecated))
#else
#define ADC_MEASUREMENT_DEPRECATED
#endif

#define ADC_MEASUREMENT_MODULE_PTR ((XMC_VADC_GLOBAL_t *) (void *) VADC)

 /**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
/**
 * @ingroup ADC_MEASUREMENT_enumerations
 * @{
 */
/**@brief Return value of an API  */

typedef enum ADC_MEASUREMENT_STATUS
{
  ADC_MEASUREMENT_STATUS_SUCCESS = 0, /**< APP is Initialized */
  ADC_MEASUREMENT_STATUS_FAILURE, /**< APP Initialization failed*/
  ADC_MEASUREMENT_STATUS_UNINITIALIZED /**<  APP has not been Initialized */
} ADC_MEASUREMENT_STATUS_t;
/**
 * @}
 */

/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/**
 * @ingroup ADC_MEASUREMENT_datastructures
 * @{
 */

typedef void (*ADC_MEASUREMENT_MUX_CONFIG_t)(void); /**< Function pointer to the mux configuration*/

/**
 *  Structure to initialize  Request Source Interrupt's NVIC Node
 */
typedef struct ADC_MEASUREMENT_ISR
{
  uint32_t node_id; 		/**< This holds the Node ID of the NVIC.*/

  uint32_t priority; 		/**< This holds the NVIC priority.*/
#if(UC_FAMILY == XMC4)
  uint32_t sub_priority; 	/**< This holds the SubPriority of the NVIC. for Only XMC4x Devices*/
#endif
#ifdef ADC_MEASUREMENT_NON_DEFAULT_IRQ_SOURCE_SELECTED
  uint8_t irqctrl; 	     /**< This indicates the service request source selected for the consumed NVIC node.*/
#endif
} ADC_MEASUREMENT_ISR_t;

/**
 * Structure to initialize ADC channels.
 */
typedef struct ADC_MEASUREMENT_CHANNEL
{
#if( XMC_VADC_GROUP_AVAILABLE == 1U)
  XMC_VADC_CHANNEL_CONFIG_t *ch_handle; /**< This holds the VADC Channel LLD struct*/

  XMC_VADC_RESULT_CONFIG_t *res_handle; /**< This hold the VADC LLD Result handler*/
#endif

#if( XMC_VADC_GROUP_AVAILABLE == 1U)
  XMC_VADC_GROUP_t *group_handle; 		/**< This holds the group to which the channel belongs*/
#endif

#ifdef ADC_MEASUREMENT_ANALOG_IO_USED
  ANALOG_IO_t   *analog_io_config;    /**< This hold the address of the ANALOG_IO configuration structure*/
#endif

  uint8_t group_index; 					/**< This holds the group index*/

  uint8_t ch_num; 						/**< This Holds the Channel Number*/

} ADC_MEASUREMENT_CHANNEL_t;

/**
 * Structure to hold channels handles that are configured
 */
typedef struct ADC_MEASUREMENT_CHANNEL_ARRAY
{
  const ADC_MEASUREMENT_CHANNEL_t *const channel_array[ADC_MEASUREMENT_MAXCHANNELS]; /**< Array which consists
                                                                                        of APPs Channel Handles*/
#if( XMC_VADC_GROUP_AVAILABLE == 0U)
  XMC_VADC_RESULT_CONFIG_t *res_handle; /**< This hold the VADC LLD Result handler*/
#endif
} ADC_MEASUREMENT_CHANNEL_ARRAY_t;

/**
 * Structure to configure ADC_MEASUREMENT APP.
 */
typedef struct ADC_MEASUREMENT
{
  const ADC_MEASUREMENT_CHANNEL_ARRAY_t *const array; 		 /**< This holds ADC_MEASUREMENT_Channel_HandleArray*/

  const XMC_VADC_BACKGROUND_CONFIG_t *const backgnd_config_handle; /**< This holds the LLD Background Scan Init
                                                                        Structure*/

  const XMC_VADC_GLOBAL_CLASS_t *const iclass_config_handle;  /**< This holds the adc global ICLASS 0 configuration*/

  GLOBAL_ADC_t *const global_handle; 						 /**< This hold the ADC Global APP handle*/

#if (UC_SERIES != XMC11)
  const ADC_MEASUREMENT_ISR_t *const req_src_intr_handle; 	 /**< This has the NVIC configuration structure*/
#else
  const ADC_MEASUREMENT_ISR_t *const result_intr_handle; 	 /**< This has the NVIC configuration structure*/
#endif

  ADC_MEASUREMENT_MUX_CONFIG_t mux_config; /**< This hold the pointer to the function that does mux configuration.*/

  ADC_MEASUREMENT_STATUS_t init_state; 	  /**< Holds information regarding the APP initialization */

  const XMC_VADC_SR_t srv_req_node; 	  /**< Service Request Line selected*/

  const bool start_conversion; 			  /**< This indicates whether to start at initialization of the APP*/
} ADC_MEASUREMENT_t;

/**
 * @}
 */

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @ingroup ADC_MEASUREMENT_apidoc
 * @{
 */

/**
 * @brief Get ADC_MEASUREMENT APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * int main(void) {
 *   DAVE_STATUS_t init_status;
 *   DAVE_APP_VERSION_t version;
 *
 *   // Initialize ADC_MEASUREMENT APP:
 *   // ADC_MEASUREMENT_Init() is called from within DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   version = ADC_MEASUREMENT_GetAppVersion();
 *   if (version.major != 1U) {
 *     // Probably, not the right version.
 *   }
 *
 *   // More code here
 *   while(1) {
 *
 *   }
 *   return (0);
 * }
 * @endcode
 */
DAVE_APP_VERSION_t ADC_MEASUREMENT_GetAppVersion(void);

/**
 * @brief Initializes the APP to measure a set of analog inputs. <BR>
 * @param handle_ptr constant pointer to the APP handle structure<BR>
 * @return ADC_MEASUREMENT_STATUS_SUCCESS when initialization succeeds else, return ADC_MEASUREMENT_STATUS_FAILURE.<BR>
 *
 * \par<b>Description: </b><br>
 * Initializes the VADC background scan request source, group channels and result registers with the configuration
 * specified in the handle structure. The API configures the conversion timing parameters of VADC, by setting the
 * [GLOBICLASS] register. The API initializes the channel and result configurations by setting the [GxCHCTRy] and
 * [GxRCRy] registers respectively. It adds all channels into the background request source channel select register
 * [BRSSEL]. For microcontrollers apart from XMC1100, the APP uses background request source event to generate
 * the interrupt. For XMC1100 devices, global result event is used to generate the interrupt. If "Start conversion after
 * initialization" has been selected in the GUI, the ADC conversions starts immediately at the end of this API call.
 *
 * @code
 * #include <DAVE.h>
 * int main(void)
 * {
 *    DAVE_Init(); //ADC_MEASUREMENT_Init is called within DAVE_Init
 *    return 0;
 * }
 @endcode
 */ 
ADC_MEASUREMENT_STATUS_t ADC_MEASUREMENT_Init(ADC_MEASUREMENT_t *const handle_ptr);

/**
 * @brief Starts the conversion of the required measurements. <BR>
 * @param handle_ptr Constant pointer to the APP handle structure<BR>
 * @return None <BR>
 *
 * \par<b>Description: </b><br>
 *  If "Start conversion after initialization" option is not selected in the GUI, the conversions can be started by
 *  calling this API. A call to this API sets the register bit field BRSMR.LDEV to generate a load event. The
 *  load event triggers the conversion of selected channels in a fixed sequence. A conversion request can also be raised
 *  upon detection of a hardware trigger. Hence, if "Start conversion after initialization" option enabled or
 *  "Trigger edge Selection" is configured to any edge, this API call is not mandatory to start the conversions.
 *
 * @code
  // Ensure that end of measurements interrupt has been enabled
  #include <DAVE.h>

  XMC_VADC_RESULT_SIZE_t result;
  void Adc_Measurement_Handler()
  {
  #if(UC_SERIES != XMC11)
    result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_A);
  #else
    result = ADC_MEASUREMENT_GetGlobalResult();
  #endif
  }

  int main(void)
  {
     DAVE_Init();
     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
     while(1);
     return 0;
  }
 @endcode
 */
void ADC_MEASUREMENT_StartConversion(ADC_MEASUREMENT_t *const handle_ptr);

#if(XMC_VADC_GROUP_AVAILABLE == 1U)
/**
 * @brief Returns the converted value for a specific channel. Not Applicable for XMC1100.<BR>
 * @param handle_ptr Constant pointer to the channel handle structure of type @ref ADC_MEASUREMENT_CHANNEL_t.
 *                   (Use the channel handle related macros which are defined in adc_measurement_conf.h)<BR>
 * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off.
 *
 * \par<b>Description: </b><br>
 * Reads the converted result stored in the result register [GxRESy.RESULT], assigned to the specified channel. This API
 * is only used in the microcotrollers where separate result registers are available for storing each channel results.
 * For these microcontrollers, each channel is configured to a particular group result register. The result register
 * is defined in the channel handle structure @ref ADC_MEASUREMENT_CHANNEL_t. Hence this API shall call be called with a
 * pointer to the channel handle of type  @ref ADC_MEASUREMENT_CHANNEL_t (Directly use the channel handle related
 * macros which are defined in adc_measurement_conf.h).
 *
 * \par<b>Note: </b><br>
 * This API is not Applicable for XMC1100 microcontroller, because all the channels shares a common result register
 * called GLOBRES. Use @ref ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_t *const handle_ptr) for XMC1100 microcontrollers.
 *
 * @code
  // Ensure that end of measurements interrupt has been enabled
  #include <DAVE.h>

  XMC_VADC_RESULT_SIZE_t result;
  void Adc_Measurement_Handler()
  {
  #if(UC_SERIES != XMC11)
    result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_A);
  #endif
  }

  int main(void)
  {
     DAVE_Init();
     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
     while(1);
     return 0;
  }
 @endcode
 */
XMC_VADC_RESULT_SIZE_t ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr);

/**
 * @brief Returns a detailed conversion result. Not Applicable for XMC1100. <BR>
 * @param handle_ptr constant pointer to the channel handle structure.
 *                   (Use the channel handle related macros which are defined in adc_measurement_conf.h)<BR>
 * @return uint32_t The complete result register.<BR>
 *
 * \par<b>Description: </b><br>
 * Returns the 32 bit result register (GxRES[y]) completely. The result of conversion as well as other informations are
 * returned from this API. The detailed result register contains result of the most recent conversion, the
 * channel number requested the conversion, valid flag, converted request source and fast compare result. In polling
 * mechanism the converted result can be read out after checking the valid flag bit. This API can be used in
 * applications where, the channel number associated to the result register is also needed for verification.
 *
 * \par<b>Note: </b><br>
 * This API is not Applicable for XMC1100 microcontroller, because all the channels shares a common result register
 * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_t *const handle_ptr) for XMC1100
 * microcontrollers.
 *
 * @code
  #include <DAVE.h>

  typedef struct detailed_result_struct
  {
	uint8_t channel_num;
	uint8_t group_num;
	uint16_t conversion_result;
  }detailed_result_struct_t;

  uint32_t result;
  bool valid_result;
  detailed_result_struct_t detailed_result;

  void Adc_Measurement_Handler()
  {
	uint32_t result;
    valid_result = (bool)false;
  #if(UC_SERIES != XMC11)
    result = ADC_MEASUREMENT_GetDetailedResult(&ADC_MEASUREMENT_Channel_A);
    if((bool)(result >> VADC_G_RES_VF_Pos))
    {
       valid_result = (bool)true;
       detailed_result.channel_num = (result & VADC_G_RES_CHNR_Msk) >> VADC_G_RES_CHNR_Pos;
       detailed_result.group_num = ADC_MEASUREMENT_Channel_A.group_index;
       detailed_result.conversion_result = result & VADC_G_RES_RESULT_Msk;
    }
  #endif
  }

  int main(void)
  {
     DAVE_Init();
     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
     while(1);
     return 0;
  }
 @endcode
 */
uint32_t ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr);

#else /* Applicable for XMC1100 devices*/
/**
 * @brief Returns the converted value from the global result register. Only Applicable for XMC1100.<BR>
 * @param handle_ptr constant pointer to the APP handle structure.<BR>
 * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off.
 *
 * \par<b>Description: </b><br>
 * Reads the converted result stored in the common result register [GLOBRES], assigned to all the channels. This API
 * is only used in the microcotrollers where group result registers are not available. Hence for these microntroller
 * devices, all the conversion results are stored in the global result register in shared mode. The wait for read mode
 * hardware option will be enabled for the global result register to avoid overwriting of results. To get a new channel
 * conversion result, it is mandatory to read the previous result using the same API or @ref
 * ADC_MEASUREMENT_GetDetailedResult API.
 *
 * \par<b>Note: </b><br>
 * <ul>
 * <li>This API is only applicable for XMC1100 microcontroller, because all the channels shares a common result register
 * called GLOBRES. Hence this API shall be called with a pointer to the measurement handle of type  @ref
 * ADC_MEASUREMENT_t.</li>
 * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by either 2 or
 * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a shift
 * operation is needed.</li>
 * </ul>
 *
 * @code
  // Ensure that end of measurements interrupt has been enabled
  #include <DAVE.h>

  XMC_VADC_RESULT_SIZE_t result;
  void Adc_Measurement_Handler()
  {
  #if(UC_SERIES == XMC11)
   result = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_0);
  #endif
   result = result >> ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_standard * (uint32_t)2);
  }

  int main(void)
  {
     DAVE_Init();
     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
     while(1);
     return 0;
  }
 @endcode
 */
XMC_VADC_RESULT_SIZE_t ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_t *const handle_ptr) ADC_MEASUREMENT_DEPRECATED;

/**
 * @brief Returns a detailed conversion result. Only Applicable for XMC1100. <BR>
 * @param handle_ptr constant pointer to the APP handle structure.<BR>
 * @return uint32_t The complete Result register.<BR>
 *
 * \par<b>Description: </b><br>
 * Returns the 32 bit result register (GLOBRES) completely. The result of conversion as well as other informations are
 * returned from this API. The detailed result register contains result of the most recent conversion, the
 * channel number requested the conversion, valid flag, converted request source and fast compare result. In polling
 * mechanism the converted result can be read out after checking the valid flag bit. This API can be used in
 * applications where, the channel number associated to the result register is also needed for verification.
 * This API is only used in the microcotrollers where group result registers are not available. Hence for these
 * microntroller  devices, all the conversion results are stored in the global result register in shared mode. The wait
 * for read mode hardware option will be enabled for the global result register to avoid overwriting of results. To get
 * a new channel conversion result, it is mandatory to read the previous result using the same API or @ref
 * ADC_MEASUREMENT_GetResult API.
 *
 * \par<b>Note: </b><br>
 * <ul>
 * <li>This API is applicable only for XMC1100 microcontroller, because all the channels shares a common result register
 * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr) for other
 * microcontrollers.</li>
 * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by either 2 or
 * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a shift
 * operation is needed.</li>
 * </ul>
 *

 *
 * @code
  #include <DAVE.h>

  typedef struct detailed_result_struct
  {
	uint8_t channel_num;
	uint8_t group_num;
	uint16_t conversion_result;
  }detailed_result_struct_t;

  uint32_t result;
  bool valid_result;
  detailed_result_struct_t detailed_result[10];

  void Adc_Measurement_Handler()
  {
	static uint8_t index;
	uint32_t result;
    valid_result = (bool)false;
  #if(UC_SERIES == XMC11)
    result = ADC_MEASUREMENT_GetDetailedResult(&ADC_MEASUREMENT_0);
  #endif

    if((bool)(result >> VADC_GLOBRES_VF_Pos))
    {
       valid_result = (bool)true;
       detailed_result[index].channel_num = (result & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Pos;
       detailed_result[index].group_num = ADC_MEASUREMENT_Channel_A.group_index;
       detailed_result[index].conversion_result = (result & VADC_GLOBRES_RESULT_Msk) >>
                            ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_standard * (uint32_t)2);
    }
    index++;
  }

  int main(void)
  {
     DAVE_Init();
     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
     while(1);
     return 0;
  }
 @endcode
 */
uint32_t ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_t *const handle_ptr) ADC_MEASUREMENT_DEPRECATED;

/**
 * @brief Returns the converted value from the global result register. Only Applicable for XMC1100.<BR>
 * @param handle_ptr constant pointer to the APP handle structure.<BR>
 * @return XMC_VADC_RESULT_SIZE_t conversion result.<BR>
 *                                Range: [ 0x0 to 0x3FF] if accumulation of results is switched off.
 *
 * \par<b>Description: </b><br>
 * Reads the converted result stored in the common result register [GLOBRES], assigned to all the channels. This API
 * is only used in the microcotrollers where group result registers are not available. Hence for these microntroller
 * devices, all the conversion results are stored in the global result register in shared mode. The wait for read mode
 * hardware option will be enabled for the global result register to avoid overwriting of results. To get a new channel
 * conversion result, it is mandatory to read the previous result using the same API or @ref
 * ADC_MEASUREMENT_GetGlobalDetailedResult API.
 *
 * \par<b>Note: </b><br>
 * <ul>
 * <li>This API is only applicable for XMC1100 microcontroller, because all the channels shares a common result register
 * called GLOBRES. Hence this API shall be called with a pointer to the measurement handle of type  @ref
 * ADC_MEASUREMENT_t.</li>
 * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by either 2 or
 * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a shift
 * operation is needed.</li>
 * </ul>
 *
 * @code
  // Ensure that end of measurements interrupt has been enabled
  #include <DAVE.h>

  XMC_VADC_RESULT_SIZE_t result;
  void Adc_Measurement_Handler()
  {
  #if(UC_SERIES == XMC11)
   result = ADC_MEASUREMENT_GetGlobalResult();
  #endif
   result = result >> ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_standard * (uint32_t)2);
  }

  int main(void)
  {
     DAVE_Init();
     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
     while(1);
     return 0;
  }
 @endcode
 */
__STATIC_INLINE XMC_VADC_RESULT_SIZE_t  ADC_MEASUREMENT_GetGlobalResult(void)
{
	XMC_VADC_RESULT_SIZE_t result;

	result = XMC_VADC_GLOBAL_GetDetailedResult(ADC_MEASUREMENT_MODULE_PTR);

	return (result);
}

/**
 * @brief Returns a detailed conversion result. Only Applicable for XMC1100. <BR>
 * @param handle_ptr constant pointer to the APP handle structure.<BR>
 * @return uint32_t The complete Result register.<BR>
 *
 * \par<b>Description: </b><br>
 * Returns the 32 bit result register (GLOBRES) completely. The result of conversion as well as other informations are
 * returned from this API. The detailed result register contains result of the most recent conversion, the
 * channel number requested the conversion, valid flag, converted request source and fast compare result. In polling
 * mechanism the converted result can be read out after checking the valid flag bit. This API can be used in
 * applications where, the channel number associated to the result register is also needed for verification.
 * This API is only used in the microcotrollers where group result registers are not available. Hence for these
 * microntroller  devices, all the conversion results are stored in the global result register in shared mode. The wait
 * for read mode hardware option will be enabled for the global result register to avoid overwriting of results. To get
 * a new channel conversion result, it is mandatory to read the previous result using the same API or @ref
 * ADC_MEASUREMENT_GetResult API.
 *
 * \par<b>Note: </b><br>
 * <ul>
 * <li>This API is applicable only for XMC1100 microcontroller, because all the channels shares a common result register
 * called GLOBRES. Use @ref ADC_MEASUREMENT_GetDetailedResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr) for other
 * microcontrollers.</li>
 * <li> For either 10Bit or 8Bit ADC resolution the result value needs to be right shifted by either 2 or
 * 4 bits respectively. The 10Bit or 8 bit results are left aligned in the result register, hence a shift
 * operation is needed.</li>
 * </ul>
 *

 *
 * @code
  #include <DAVE.h>

  typedef struct detailed_result_struct
  {
	uint8_t channel_num;
	uint8_t group_num;
	uint16_t conversion_result;
  }detailed_result_struct_t;

  uint32_t result;
  bool valid_result;
  detailed_result_struct_t detailed_result[10];

  void Adc_Measurement_Handler()
  {
	static uint8_t index;
	uint32_t result;
    valid_result = (bool)false;
  #if(UC_SERIES == XMC11)
    result = ADC_MEASUREMENT_GetGlobalDetailedResult();
  #endif

    if((bool)(result >> VADC_GLOBRES_VF_Pos))
    {
       valid_result = (bool)true;
       detailed_result[index].channel_num = (result & VADC_GLOBRES_CHNR_Msk) >> VADC_GLOBRES_CHNR_Pos;
       detailed_result[index].group_num = ADC_MEASUREMENT_Channel_A.group_index;
       detailed_result[index].conversion_result = (result & VADC_GLOBRES_RESULT_Msk) >>
                            ((uint32_t)ADC_MEASUREMENT_0.iclass_config_handle->conversion_mode_standard * (uint32_t)2);
    }
    index++;
  }

  int main(void)
  {
     DAVE_Init();
     ADC_MEASUREMENT_StartConversion(&ADC_MEASUREMENT_0);
     while(1);
     return 0;
  }
 @endcode
 */
__STATIC_INLINE uint32_t ADC_MEASUREMENT_GetGlobalDetailedResult(void)
{
	uint32_t result;
	result = XMC_VADC_GLOBAL_GetDetailedResult(ADC_MEASUREMENT_MODULE_PTR);

	return (result);
}
#endif

/**
 * @}
 */

#include "ADC_MEASUREMENT_Extern.h"
#ifdef __cplusplus
}
#endif

#endif /* ADC_MEASUREMENT_H_ */
